update-tlmgr-latest
update-tlmgr-latest
#| echo: false
#| eval: true
# Define process_qmd function
process_qmd <- function(file, fpath_in = "", fpath_out = "") {
# Read the file
doc <- readLines(file)
# Find the line which ends the YAML-blcok (Second instance of "---")
end_yaml <- which(doc == "---")[2]
# Extract the YAML-block
yaml_block <- doc[1:end_yaml]
# Search for the line which includes the title
title_line <- grep("^title:", yaml_block, value = TRUE)
# If the title has at least one character...
if (length(title_line) > 0) {
# remove the "title:" tag as well as special characters
title <- sub("^title:\\s*\"?(.*?)\"?\\s*$", "\\1", title_line)
}
# Set an empty title if the title is missing
else {title <- ""}
# Save all lines expect the YAML-block
out_doc <- doc[(end_yaml+1):length(doc)]
# Replace the original path if needed
if (fpath_in != fpath_out) {
out_doc <- stringr::str_replace_all(out_doc, fpath_in, fpath_out)
}
# Replace Instances of "Images/Chapter_" by "Chapters/Images/Chapter_" to get the correct path
out_doc <- stringr::str_replace_all(out_doc, "Images/Chapter_", "Chapters/Images/Chapter_")
### Remove custom "downloadbox" blocks
# Lock for Lines which start a download-box
start_db <- grep("^:::::: downloadbox", out_doc)
# Find the lines which end the downloadbox
end_db <- grep("^::::::$", out_doc)
if (length(start_db) > 0 && length(end_db) > 0) {
# Create a logical vector to keep or discard lines
keep <- rep(TRUE, length(out_doc))
# For every sequence
for (i in seq_along(start_db)) {
s <- start_db[i]
# Find the first end marker that comes *after* this start
e <- end_db[end_db > s][1]
if (!is.na(e)) {
keep[s:e] <- FALSE
}
}
out_doc <- out_doc[keep]
}
# If a title was found, add the title in combination with a markdown-header (#) at the beginning
if (title != "") {
out_doc <- c(paste0("# ", title), "", out_doc)
}
# Use the modified text as child-document
res <- knitr::knit_child(text = out_doc, quiet = TRUE, options = list(eval = FALSE, echo = TRUE))
#Return the text
return(res)
}
### Credit for the foundation of this function goes to royal-statistical-society for their function in the datavisguide project
### https://github.com/royal-statistical-society/datavisguide/blob/main/_make_pdf.qmd
#| echo: false
#| eval: true
# Define process_qmd function
process_qmd <- function(file, fpath_in = "", fpath_out = "") {
# Read the file
doc <- readLines(file)
# Find the line which ends the YAML-blcok (Second instance of "---")
end_yaml <- which(doc == "---")[2]
# Extract the YAML-block
yaml_block <- doc[1:end_yaml]
# Search for the line which includes the title
title_line <- grep("^title:", yaml_block, value = TRUE)
# If the title has at least one character...
if (length(title_line) > 0) {
# remove the "title:" tag as well as special characters
title <- sub("^title:\\s*\"?(.*?)\"?\\s*$", "\\1", title_line)
}
# Set an empty title if the title is missing
else {title <- ""}
# Save all lines expect the YAML-block
out_doc <- doc[(end_yaml+1):length(doc)]
# Replace the original path if needed
if (fpath_in != fpath_out) {
out_doc <- stringr::str_replace_all(out_doc, fpath_in, fpath_out)
}
# Replace Instances of "Images/Chapter_" by "Chapters/Images/Chapter_" to get the correct path
out_doc <- stringr::str_replace_all(out_doc, "Images/Chapter_", "Chapters/Images/Chapter_")
### Remove custom "downloadbox" blocks
# Lock for Lines which start a download-box
start_db <- grep("^:::::: downloadbox", out_doc)
# Find the lines which end the downloadbox
end_db <- grep("^::::::$", out_doc)
if (length(start_db) > 0 && length(end_db) > 0) {
# Create a logical vector to keep or discard lines
keep <- rep(TRUE, length(out_doc))
# For every sequence
for (i in seq_along(start_db)) {
s <- start_db[i]
# Find the first end marker that comes *after* this start
e <- end_db[end_db > s][1]
if (!is.na(e)) {
keep[s:e] <- FALSE
}
}
out_doc <- out_doc[keep]
}
# If a title was found, add the title in combination with a markdown-header (#) at the beginning
if (title != "") {
out_doc <- c(paste0("# ", title), "", out_doc)
}
# Use the modified text as child-document
res <- knitr::knit_child(text = out_doc, quiet = TRUE, options = list(eval = FALSE, echo = TRUE))
#Return the text
return(res)
}
### Credit for the foundation of this function goes to royal-statistical-society for their function in the datavisguide project
### https://github.com/royal-statistical-society/datavisguide/blob/main/_make_pdf.qmd
#| output: asis
#| echo: false
#| eval: true
#| message: false
# List all data in the Chapter-Folder which start with "Chapter_" and have a ".qmd" suffix
files <- list.files("Chapters/", pattern = "^Chapter_.*\\.qmd$", full.names = TRUE)
# Extract the number of chapters from the filenames as integers
numbers <- as.integer(stringr::str_extract(basename(files), "(?<=Chapter_)[0-9]+"))
# Sort the chapter-files based on the extracted numbers
files <- files[order(numbers)]
# For all chapter-files
for (fileindex in 1:2){
# Get the current chapter-file
current_file <- files[fileindex]
# Process the current chapter
C1 <- process_qmd(current_file)
# Print the current chapter
cat(unlist(C1), sep = '\n')
}
C1
cat(unlist(C1), sep = '\n')
