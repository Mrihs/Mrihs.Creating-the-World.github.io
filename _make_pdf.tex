% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}

\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else  
    % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\setcounter{secnumdepth}{2}
% Make \paragraph and \subparagraph free-standing
\makeatletter
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}{
    \@ifstar
      \xxxParagraphStar
      \xxxParagraphNoStar
  }
  \newcommand{\xxxParagraphStar}[1]{\oldparagraph*{#1}\mbox{}}
  \newcommand{\xxxParagraphNoStar}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}{
    \@ifstar
      \xxxSubParagraphStar
      \xxxSubParagraphNoStar
  }
  \newcommand{\xxxSubParagraphStar}[1]{\oldsubparagraph*{#1}\mbox{}}
  \newcommand{\xxxSubParagraphNoStar}[1]{\oldsubparagraph{#1}\mbox{}}
\fi
\makeatother


\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

%%% load packages
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{eso-pic}
\usepackage{atbegshi}
\usepackage{fancyhdr}
\usepackage[explicit]{titlesec}
\usepackage{marginnote}
\usepackage{setspace}
\usepackage{enumitem}
\usepackage[most]{tcolorbox}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{pagecolor}
\usepackage{anyfontsize}
\usepackage[table, dvipsnames]{xcolor} % KEIN 'html'!
\usepackage{transparent}
\usepackage{tikzpagenodes}
\usepackage{ifthen}




%%% --- Define Colors ---
% Define Colors
\definecolor{my_orange}{HTML}{FF8E00}
\definecolor{blender_blue}{HTML}{236192}
\definecolor{remember_gold}{HTML}{FFDE7E}
\definecolor{orangeTop}{HTML}{FFA600}
\definecolor{orangeBottom}{HTML}{FF8E00}
\definecolor{blue_box}{HTML}{1E6AE2}




%%% --- Adjust Document Settings ---
% Set page size
\geometry{a4paper, left=30mm, top=25mm, bottom=25mm, right=30mm}

% Activate fancy-Style
\pagestyle{fancy}

% Delete default-Styles
\fancyhf{}






%%% --- Adjust Font ---
\renewcommand{\normalsize}{\fontsize{10pt}{13pt}\selectfont}
\makeatletter
\renewcommand\normalsize{%
  \@setfontsize\normalsize{12pt}{15pt}% 12pt Schrift und 15pt Zeilenabstand
  \abovedisplayskip 10pt plus 2pt minus 5pt%
  \abovedisplayshortskip \z@ plus 2pt%
  \belowdisplayshortskip 6pt plus 2pt minus 3pt%
  \belowdisplayskip \abovedisplayskip
  \let\@listi\@listI%
}
\makeatother
\normalsize

\makeatletter
\renewcommand\small{\@setfontsize\small{9pt}{11pt}}
\renewcommand\footnotesize{\@setfontsize\footnotesize{8pt}{10pt}}
\makeatother


% Increase space between lines
\setstretch{1.2}

% Remove spacing after lists
\setlist{nosep}

% Remove spacing for new paragraphs
\setlength{\parskip}{0pt}

% Adjust spacing after titles (\Section, left, before, after)
\titlespacing*{\chapter}{0pt}{0pt}{0pt}
\titlespacing*{\section}{0pt}{10pt}{0pt}
\titlespacing*{\subsection}{0pt}{10pt}{0pt}
\titlespacing*{\subsubsection}{0pt}{10pt}{0pt}





%%% --- Adjust Margins ---
% Change marginnotes
\let\oldmarginnote\marginnote

% Define width off the marings
\setlength{\marginparwidth}{2cm}


\newsavebox{\margibox}
\newcommand{\margicontent}{}

\renewcommand{\marginnote}[1]{%
  \sbox{\margibox}{%
    \vtop{%
      \hsize=\marginparwidth
      \footnotesize
      \linespread{0.8}\selectfont
      \raggedright
      #1
    }%
  }%
  \edef\margicontent{\noexpand\usebox{\noexpand\margibox}}%
  \oldmarginnote[\margicontent]{\margicontent}%
}





%%% --- Adjust chapter titles ---
% Remove "Chapter"-prefix from chapter-title
%Adjust title format
\titleformat{\chapter}[hang]
  % Font of the title
  {\normalfont\huge\bfseries}
  % Suppress Chapter-Number
  {\thechapter.\quad}
  % Remove space after (removed) chapter number
  {0pt}
  % Execute Chapter-title
  {#1}





%%% --- Adjust Page Header ---
% Remove default-Header
\renewcommand{\headrulewidth}{0pt}

% Increase space between header and text
\setlength{\headsep}{30pt}

% Set text for heading
\makeatletter
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
% Remove "Chapter"-Prefix
\renewcommand{\@chapapp}{}
\makeatother


%%% Odd pages (Recto)
\newcommand{\headerRecto}{%
  \AddToShipoutPictureFG*{%
    \begin{tikzpicture}[remember picture, overlay]
      \fill[my_orange] ([yshift=-30pt]current page.north west) rectangle ([yshift=-60pt]current page.north east);
      \node[anchor=west, text=white, font=\bfseries, yshift=-45pt, xshift=90pt]
        at (current page.north west) {\phantom{00}};
      \node[anchor=east, text=white, font=\bfseries, yshift=-45pt, xshift=-80pt]
        at (current page.north east)  {Creating the World};
    \end{tikzpicture}%
  }
}

%%% Even pages (Verso)
\newcommand{\headerVerso}{%
  \AddToShipoutPictureFG*{%
    \begin{tikzpicture}[remember picture, overlay]
      \fill[my_orange] ([yshift=-30pt]current page.north west) rectangle ([yshift=-60pt]current page.north east);
      \node[anchor=west, text=white, font=\bfseries, yshift=-45pt, xshift=80pt]
        at (current page.north west) {Creating the World};
      \node[anchor=east, text=white, font=\bfseries, yshift=-45pt, xshift=-90pt]
        at (current page.north east) {\phantom{00}};
    \end{tikzpicture}%
  }
}


%% Asign header to odd pages
\fancyhead[LO,RO]{\headerRecto}

%% Asign header to even pages
\fancyhead[LE,RE]{\headerVerso}

%% Asign header to even pages

%% Overwrite plain-Style at beginning of chapter
\fancypagestyle{plain}{%
  % Remove headers
  \fancyhf{}
  % No additional lines
  \renewcommand{\headrulewidth}{0pt}
  %% Asign header to even pages
  \fancyhead[LO,RO]{\headerRecto}
  %% Asign header to odd pages
  \fancyhead[LE,RE]{\headerVerso}
}





%%% --- Define Boxes ---
%## Tipp-box
% Define new colorbox
\newtcolorbox{tipp}[1]{
% Add space before box and cener box
before=\bigskip\centering,
% Add space after the box
after=\bigskip,
% Activate enhanced mode of colorbox
enhanced,
% Create round corners
arc=10pt,
% Create gold frame
colframe=green!75!black,
% Craete gold background color
colback=green!5!white,
% Define Font of title (black font, sans-serife and large)
fonttitle=\sffamily\bfseries\normalsize,
% Set content 1 as title
title=#1,
% Add space before and after the title inside the box
title={\vspace{2.5mm}#1\vspace{2.5mm}},
% Set space in upper left corner 
leftupper=2.5cm,
% Set round corners
rounded corners,
% Fix title to top of box
attach boxed title to top,
frame hidden,
% Define style of title
boxed title style={
    % Activate enhanced settings of title-field
    enhanced,
    % Set frame of title box
    colframe=green!75!black,
    % Set background of title box
    colback=green!75!black,
    % Set round-angle of title field
    arc=10pt,
    % Supress frame around title fileld
    bottomrule=0pt,
    rightrule=0pt,},
  % Overlay image
  overlay={
    % Set anchor north-west
    \node[anchor=north west] 
      % Adjust position in relation to frame
      at ([xshift=10pt,yshift=-1.75\baselineskip]frame.north west)
        % Add image
       {\includegraphics[width=1cm]{"icons/info.png"}};}}



%%%%% Exercise
% Define new colorbox
\newtcolorbox[auto counter]{exercise}[2][]{
% Add space before box and cener box
before=\bigskip\centering,
% Add space after the box
after=\bigskip,
% Activate enhanced mode of colorbox
enhanced,
% Create round corners
arc=15pt,
% Create blue frame
colframe=blender_blue,
% Craete blue background color
colback=blender_blue!5!white,
% Define Font of title (black font, sans-serife and large
fonttitle=\sffamily\bfseries\Large,
% Set title
title=Ãœbung~\thetcbcounter,
% Define sharp corners
sharp corners,
% Set space in upper left corner 
leftupper=2.5cm,
% Overlay image
overlay={
  % Set anchor north-west
  \node[anchor=north west] 
    % Adjust position
    at ([xshift=10pt,yshift=-.65\baselineskip]frame.north west)
     % Add image
     {\includegraphics[width=1cm,height=1cm]{"icons/exercise.png"}};},
% Set round corners
rounded corners=northeast,
% Fix title to top of box
attach boxed title to top left,
% Define style of title
boxed title style={
    % Activate enhanced settings of title-field
    enhanced,
    % Set frame of title box
    colframe=blender_blue,
    % Set background of title box
    colback=blender_blue,
    % Set round-angle of title field
    arc=5pt,
    % Supress frame around title fileld
    bottomrule=0pt,
    rightrule=0pt,
    % Set sharp corners
    sharp corners,
    % Set round corners norh-east
    rounded corners=northeast,},
% Define stly of (emtpy) interior block
interior style={},
% Define style of frame
frame style={
    % Set colors
    color= cyan!5!white,
    fill=none},
% Align additional overlays
overlay unbroken and first={
    % Place text
    \node[anchor=west,font=\sffamily\bfseries,color=blue] 
    % Position text east of title and with large font
    at (title.east) {{\Large #2}};
    %
    \node[anchor=north west] 
    % Set position
    at ([xshift=10pt, yshift=-1.75\baselineskip]frame.north west)
      % Add image
     {\includegraphics[width=1.5cm]{"icons/exercise.png"}};},#1}



%%%%% Remember
% Define new colorbox
\newtcolorbox{remember}[1]{
% Add space before box and cener box
before=\bigskip\centering,
% Add space after the box
after=\bigskip,
% Activate enhanced mode of colorbox
enhanced,
% Create round corners
arc=10pt,
% Create gold frame
colframe=remember_gold,
% Craete gold background color
colback=remember_gold,
% Define Font of title (black font, sans-serife and large
fonttitle=\color{black}\sffamily\bfseries\Large,
% Set content 1 as title
title=#1,
% Add space before and after the title inside the box
title={\vspace{2.5mm}#1\vspace{2.5mm}},
% Set space in upper left corner 
leftupper=2.5cm,
% Set round corners
rounded corners,
% Fix title to top of box
attach boxed title to top,
% Define style of title
boxed title style={
    % Activate enhanced settings of title-field
    enhanced,
    % Set frame of title box
    colframe=remember_gold,
    % Set background of title box
    colback=remember_gold,
    % Set round-angle of title field
    arc=10pt,
    % Supress frame around title fileld
    bottomrule=0pt,
    rightrule=0pt
    },
  % Overlay image
  overlay={
    % Set anchor north-west
    \node[anchor=north west] 
      % Adjust position in relation to frame
      at ([xshift=10pt,yshift=-1.75\baselineskip]frame.north west)
        % Add image
       {\includegraphics[width=1cm]{"icons/remember.png"}};}}
       


%%%%% Footer
\newcommand{\seitenzahlInFusszeile}{%
  \AddToShipoutPictureFG*{%
    \begin{tikzpicture}[remember picture, overlay]
      \ifodd\value{page}
        % Odd pages - box left
        \node[anchor=south west, font=\normalfont\small, text=black] 
          at ([xshift=29mm, yshift=0.65cm]current page.south west) {\thechapter.\ \leftmark};
        \node[anchor=south east] 
          at ([xshift=-2.0cm]current page.south east) {%
            \raisebox{-0.15\baselineskip}{%
              \colorbox{blue_box}{%
                \parbox[c][1.25\baselineskip][t]{0.5cm}{%
                  \vspace{0.28\baselineskip}%
                  \centering\color{white}\bfseries\small\thepage%
                }%
              }%
            }%
          };
      \else
        % even pages - box right
        \node[anchor=south east, font=\normalfont\small, text=black] 
          at ([xshift=-29mm, yshift=0.65cm]current page.south east) {\thechapter.\ \leftmark};
        \node[anchor=south west] 
          at ([xshift=2.0cm]current page.south west) {%
            \raisebox{-0.15\baselineskip}{%
              \colorbox{blue_box}{%
                \parbox[c][1.25\baselineskip][t]{0.5cm}{%
                  \vspace{0.28\baselineskip}%
                  \centering\color{white}\bfseries\small\thepage%
                }%
              }%
            }%
          };
      \fi
    \end{tikzpicture}%
  }
}


\AtBeginShipout{%
  \ifthenelse{%
    \NOT\(\value{page}=1 \OR \value{page}=2\)%
  }{%
    \seitenzahlInFusszeile%
  }{}%
}
\renewcommand{\familydefault}{\sfdefault}
\newcommand{\kbd}[1]{\fbox{\texttt{#1}}}
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Inhaltsverzeichnis}
\else
  \newcommand\contentsname{Inhaltsverzeichnis}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{Abbildungsverzeichnis}
\else
  \newcommand\listfigurename{Abbildungsverzeichnis}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{Tabellenverzeichnis}
\else
  \newcommand\listtablename{Tabellenverzeichnis}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Abbildung}
\else
  \newcommand\figurename{Abbildung}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Tabelle}
\else
  \newcommand\tablename{Tabelle}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{Listingverzeichnis}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother

\ifLuaTeX
\usepackage[bidi=basic]{babel}
\else
\usepackage[bidi=default]{babel}
\fi
\babelprovide[main,import]{ngerman}
% get rid of language-specific shorthands (see #6817):
\let\LanguageShortHands\languageshorthands
\def\languageshorthands#1{}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage{bookmark}

\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  pdflang={de},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}


\author{}
\date{}

\begin{document}
\frontmatter


\mainmatter
\begin{titlepage}
  \thispagestyle{empty}

  % Background Image
  \AddToShipoutPictureBG*{%
    \put(0,0){%
      \parbox[b][\paperheight][c]{\paperwidth}{%
        \includegraphics[width=\paperwidth,height=\paperheight]{icons/Title_Image.png}%
      }%
    }%
  }
  
  % Titlebox
  \begin{tikzpicture}[remember picture, overlay]
    \node[anchor=north west] at ([xshift=2.3cm,yshift=-9.3cm] current page.north west) {
      \begin{tikzpicture}
        % Box
        \shade[bottom color=orangeBottom, top color=orangeTop, opacity=0.45]
          (0,0) rectangle (16.51cm,3.91cm);
        % Text
        \node[anchor=west, text=white, align=left, font=\sffamily\bfseries\fontsize{24}{24}\selectfont]
          at (1.25cm,1.955cm) {
            Creating the World:\\
            Grafik, Design und Animation in 3D
          };
      \end{tikzpicture}
    };

  
    % Author-Box
    \node[anchor=north west] at ([xshift=2.3cm,yshift=-19.61cm] current page.north west) {
      \begin{tikzpicture}
        % Box
        \filldraw[fill=blue!90!cyan, opacity=0.35, draw=none]
          (0,0) rectangle (16.51cm,3.91cm);
        % Text
        \node[anchor=east, text=white, align=right, font=\sffamily\bfseries\fontsize{16}{18}\selectfont]
          at (16.31cm,1.955cm) {
            Michael Rihs\\
            Flurina Brodwolf\\
            Romina Schmid\\
            Fred Mast
          };
      \end{tikzpicture}
    };

  \end{tikzpicture}

  \newpage
\end{titlepage}

\clearpage
\thispagestyle{empty}

\chapter*{Creating the World:\protect\\Grafik, Design \& Animation}

\hfill\break

\vspace{1em}

\textbf{Version:} 2025\\
\textbf{Erstversion:} 2021\\

\textbf{Autoren:}\\
Michael Rihs\textsuperscript{*}\\
Flurina L. Brodwolf\\
Romina Schmid\\
Fred W. Mast\\
\strut \\
Abteilung fÃ¼r kognitive Psychologie, Wahrnehmung und Methodenlehre\\
Institut fÃ¼r Psychologie\\
UniversitÃ¤t Bern\\

\vspace{1em}
\section*{Kontakt}

\begin{tabular}{@{}l}
\textbf{*Dr. Michael Rihs}\\
Institut fÃ¼r Psychologie \\
Fabrikstrasse 8 \\
3012 Bern \\
{michael.rihs@unibe.ch} \\
\end{tabular}

\newpage
\section*{Erstellung der Website}

Die Unterlagen zu diesem Buch sind auf der dazugehÃ¶rigen Website
(\url{https://mrihs.github.io/Mrihs.Creating-the-World.github.io/}) zu
finden. Die Website wurde mit Hilfe von
\href{https://posit.co/download/rstudio-desktop/}{RStudio/Posit} und
\href{https://quarto.org}{Quarto} entwickelt. Die Website, sowie die
Unterrichts-Unterlagen sind im zur Website gehÃ¶rigen GitHub Repository
(\url{https://github.com/Mrihs/Mrihs.Creating-the-World.github.io})
hinterlegt

\vspace{1em}
\section*{Lizenz}

Dieses Buch und die dazugehÃ¶rige Website stellt eine offene
Bildungsressource (Open Educational Resource) dar. Sie darf frei
verwendet, bearbeitet und weitergegeben werden, sofern die Urheber
namentlich genannt und die Inhalte unter der Lizenz
\href{https://creativecommons.org/licenses/by-sa/4.0/deed.de}{CC BY-SA 4.0}
weitergegeben werden.

Abbildungen der BenutzeroberflÃ¤che von
\href{https://www.blender.org}{Blender} wurden als Screenshots erstellt
und unterliegen der Lizenzbedingungen von Blender.

\vspace{1em}
\section*{Danksagung}

Besonderer Dank geht an Rahel Steuri und Rebekka Borer, welche bei der
Adaption des Kurses im Jahre 2022 beteiligt waren. Weiterer Dank geht an
AurÃ©gane DÃ©vaud, welche die Erstellung der Website zum Buch unterstÃ¼tzt
hat.

\clearpage
\tableofcontents
\clearpage

\chapter*{Vorwort}

\hfill\break

\markboth{Vorwort}{}

Dieses Buch wurde fÃ¼r die Lehrveranstaltung ``Creating the World:
Grafik, Design \& Animation (inkl. EinfÃ¼hrung in die 3D Modellierung mit
Blender) entwickelt. Der Kurs wurde erstmals im Jahr 2021 als
Methodenkurs fÃ¼r Masterstudierende der
philosophisch-humanwissenschaftlichen FakultÃ¤t der UniversitÃ¤t
angeboten. Die Lehrveranstaltung wurde durch das FÃ¶rderprogramm''Der
Mensch in der digitalen Transformation'' von der
philosophisch-humanwissenschaftlichen FakultÃ¤t gefÃ¶rdert. In der
Veranstaltung wurde der Prozess der Erstellung virtueller 3D-Objekte,
-Welten und Animationen vor dem Hintergrund aktueller Forschung
erlÃ¤utert und durch praktische Beispiele veranschaulicht. Die
Studierenden erlernten die Inhalte praxisnah mithilfe der frei
zugÃ¤nglichen Software Blender und erhielten dabei fundierte Einblicke in
die grundlegenden Merkmale von 3D-Objekten, -Welten und Animationen.

\section*{Hinweise zur Verwendung von Boxen}

Im Verlaufe des Buches werden verschiedene Boxen verwendet, um wichtige
Informationen hervorzuheben. Die Boxen haben folgende Bedeutung

\begin{tipp}{Tipps}
Diese Box kennzeichnet nÃ¼tzliche Tipps.
\vspace{2\baselineskip}
\end{tipp}

\begin{remember}{Merke...}
Diese Box kennzeichnet besonders wichtige Inhalte, die nicht vergessen werden sollten.
\vspace{2\baselineskip}
\end{remember}

\begin{exercise}{Ãœbungen}
Diese Box kennzeichnet praktische Ãœbungen.
\vspace{2\baselineskip}
\vspace{2\baselineskip}
\end{exercise}

\section*{RÃ¼ckmeldung}

Haben Sie RÃ¼ckmeldungen, Anregungen oder Fehler entdeckt? Diese kÃ¶nnen
gerne an Dr.~Michael Rihs (michael.rihs@unibe.ch) zurÃ¼ckgemeldet werden.

\chapter{Vorbereitung von Blender}\label{vorbereitung-von-blender}

\section{Installation von Blender}\label{installation-von-blender}

\marginnote{Installationsdatei herunterladen}

Um Blender auf einem Rechner zu installieren, muss das
Installationspaket von Blender auf dessen Website
\url{https://www.blender.org/} unter dem Reiter Â«DownloadÂ»
heruntergeladen werden. Dort sollte bereits automatisch das
Betriebssystem des Rechners erkannt und die aktuellste Version angeboten
werden. Ansonsten lÃ¤sst sich mittels eines Auswahlfeldes auch die
entsprechende Version auswÃ¤hlen.

\marginnote{FrÃ¼here Versionen von Blender}

Unter \url{https://www.blender.org/download/releases/} lassen sich zudem
frÃ¼here Versionen von Blender herunterladen. Dieser Kurs ist auf Blender
3.3 ausgerichtet, weshalb der Download dieser Version empfohlen wird.

\subsection{Mac}\label{mac}

\marginnote{Installationsdatei fÃ¼r Mac-User}

Mac-Benutzer wÃ¤hlen den Link mit der Endung Â«\emph{.dmg}Â». AbhÃ¤ngig vom
Computermodell gibt es zwei Versionen. FÃ¼r Apple-Computer, welche Apples
hauseigenen Prozessor M1 eingebaut haben, wird die Version mit der
Endung Â«arm64.dmgÂ» benÃ¶tigt. FÃ¼r die anderen Apple-Computer die Version
mit der Endung Â«\emph{x64.dmg}Â». Um herauszufinden, welcher
Prozessor/Chip im eigenen Apple-GerÃ¤t eingebaut ist, kann man im MenÃ¼
Â«\emph{Ãœber diesen Mac}Â» (oben links beim Apfelsymbol zu finden)
nachschauen. Wenn Apples eigener Chip verbaut ist, wird Â«\emph{Chip
Apple M1}Â» aufgelistet. Wenn der Computer nicht Ã¼ber den M1-Chipf
verfÃ¼gt, wird an dieser Stelle der Prozessor aufgefÃ¼hrt.

\marginnote{Installation}

Nach dem Download sollte das entsprechende .dmg-Paket geÃ¶ffnet werden.
Anschliessend Ã¶ffnet sich ein Fenster, dass die Blender-Software und den
Applikationsordner zeigt. Hier sollte nun die Blender-Software in den
Applikationsordner gezogen werden. Anschliessend ist die Installation
abgeschlossen.

\subsection{Windows}\label{windows}

\marginnote{Installation fÃ¼r Windows-User}

Windows-Benutzer kÃ¶nnen den Link mit der Endung Â«\emph{.msi}Â» auswÃ¤hlen.
Nach dem Download kann die Datei geÃ¶ffnet werden und die Installation
konfiguriert werden.

\marginnote{Blender ohne Installation nutzen}

Es ist auch mÃ¶glich, Blender ohne eine Installation zu verwenden --
hierfÃ¼r muss der Link mit der Endung Â«\emph{.zip}Â» ausgewÃ¤hlt werden.
Nach dem Extrahieren der Dateien kann Blender Ã¼ber diesen Ordner
gestartet werden. Dadurch kann Blender auf ein externes Speichermedium
transferiert werden und an anderen Computern gestartet werden. Dies hat
allerdings einige Nachteile. Der Computer weiss dadurch etwa nicht, mit
welchem Programm er standardmÃ¤ssig die Dateien von Blender Ã¶ffnen kann,
und Blender wird auch nicht unter den installierten Programmen
aufgelistet.

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Seit der Version 2.81 von Blender werden nur noch Computer mit einer 64-Bit-Architektur unterstÃ¼tzt. Microsoft unterstÃ¼tzt diese Systeme seit 2020 nicht mehr und auch andere Software-Entwickler haben den Support dieser Systeme eingestellt.
\end{tipp}

\section{Der erste Start von Blender}\label{der-erste-start-von-blender}

Beim ersten Start von Blender erscheint ein Quick-Setup-MenÃ¼, bei dem
einige Grundeinstellungen eingestellt werden kÃ¶nnen. Diese kÃ¶nnen in der
Regel so belassen werden, wie sie sind. Die folgenden Einstellungen
stehen zur VerfÃ¼gung:

\begin{itemize}
\tightlist
\item
  \textbf{Language}: Hier kann die Sprache eingestellt werden.
\item
  \textbf{Shortcuts}: Hier kÃ¶nnen die Shortcut-Einstellungen ausgewÃ¤hlt
  werden. Dieser Kurs orientiert sich an der Default-Einstellung
  Â«\emph{Blender}Â».
\item
  \textbf{Select with}: Hier kann eingestellt werden, ob jeweils mit der
  linken oder der rechten Maustaste Objekte ausgewÃ¤hlt werden kÃ¶nnen.
  Dieser Kurs geht davon aus, dass eine Auswahl mit der linken Maustaste
  erfolgt.
\item
  \textbf{Spacebar}: Die Funktion der Leertaste kann drei verschiedenen
  Funktionen zugewiesen werden. Per Default wird die Leertaste
  verwendet, um Animationen zu starten (Option Â«\emph{Play}Â»).
  Allerdings kann sie auch der Option Â«\emph{Tools}Â» zugewiesen werden.
  Mittels der Einstellung Â«\emph{Search}Â» wird durch die Leertaste ein
  Suchfeld geÃ¶ffnet, mit dem Befehle gesucht werden kÃ¶nnen. FÃ¼r diesen
  Kurs spielt es keine grosse Rolle, welche Funktion der Leertaste
  zugewiesen wird. Die Befehlssuche ist allerdings sehr nÃ¼tzlich, kann
  aber alternativ auch mit der Taste \kbd{F3} geÃ¶ffnet werden.
\item
  \textbf{Theme}: Hier kann das farbliche Layout von Blender angepasst
  werden. Grafiken in diesem Kurs wurden mit dem Theme Â«\emph{Blender
  Dark}Â» erstellt.
\end{itemize}

\section{Die ArbeitsoberflÃ¤che von
Blender}\label{die-arbeitsoberfluxe4che-von-blender}

\subsection{Das Willkommensfenster}\label{das-willkommensfenster}

\marginnote{Optionen im Willkommensfenster}

Blender begrÃ¼sst seine Nutzer mit einem Willkommensfenster. In diesem
Fenster werden die letzten geÃ¶ffneten Projekte auf der rechten Seite
unter den Â«\emph{Recent Files}Â» aufgelistet. Auf der linken Seite des
Willkommensfenster kann unter Â«\emph{New File}Â» ein neues Projekt
erstellt werden. Dabei lÃ¤sst sich die Art des Projekts bereits genauer
definieren. Je nach ausgewÃ¤hlter Projektart werden unterschiedliche
Ansichtsvorlagen geladen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_1/1_1_Welcome_Screen.png}

\caption{\label{fig-1_1}Willkommensfenster}

\end{figure}%

\marginnote{Auswahl von Ansichtsvorlagen}

Zu den mÃ¶glichen Ansichtsvorlagen gehÃ¶ren:

\begin{itemize}
\tightlist
\item
  \textbf{General}: Ã–ffnet eine Standardvorlage fÃ¼r das Bearbeiten von
  3D-Objekten.
\item
  \textbf{2D Animation}: Ã–ffnet eine Vorlage zum Erstellen von
  2D-Animationen.
\item
  \textbf{Sculpting}: Ã–ffnet eine Vorlage, welche fÃ¼r das Sculpting von
  Objekten geeignet ist. Dabei werden Objekte anhand von Pinseln direkt
  in ihrer Form verÃ¤ndert.
\item
  \textbf{VFX}: Ã–ffnet eine Vorlage fÃ¼r die Erstellung visueller Effekte
  (VFX), beispielsweise in Videos.
\item
  \textbf{Video Editing}: Ã–ffnet eine Vorlage zum Bearbeiten von Videos.
\end{itemize}

\marginnote{Fokus auf Â«GeneralÂ»}

Dieser Kurs wird sich auf die 3D-Modellierung fokussieren. Deshalb wird
jeweils die Ansichtsvorlage Â«\emph{General}Â» verwendet. Diese Vorlage
ist so generell, dass sie im Hintergrund schon geladen ist, wÃ¤hrend das
Willkommensfenster dargestellt wird. Deshalb ist es auch mÃ¶glich,
einfach ausserhalb des Willkommensfensters zu klicken. Dadurch
verschwindet das Willkommensfenster und die General-Vorlage, die bereits
im Hintergrund besteht, wird sichtbar.

\subsection{Die verschiedenen Areale beim
General-Projekt}\label{die-verschiedenen-areale-beim-general-projekt}

\marginnote{Default Editoren}

Die verschiedenen Werkzeuge, welche Blender anbietet, sind innerhalb
verschiedener Editoren aufzufinden. Diese Editoren werden als separate
und austauschbare Areale in Blender dargestellt. Beim Start eines neuen
Projekts (mit der Vorlage General) ist die Ansicht in vier Areale
unterteilt:

\begin{itemize}
\tightlist
\item
  \textbf{3D Viewport}: Ãœberspannt von der oberen linken Ecke den
  grÃ¶ssten Teil des Bildschirms.
\item
  \textbf{Outliner}: Befindet sich in der oberen rechten Ecke.
\item
  \textbf{Properties}: Befindet sich in der unteren rechten Ecke.
\item
  \textbf{Timeline}: Befindet sich links am unteren Rand.
\end{itemize}

Gerade der 3D-Viewport, der Outliner und die Properties sind fÃ¼r das
Erstellen von 3D-Objekten mit Blender von hoher Bedeutung. Die Timeline
wird bei Animationen verwendet.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_1/1_2_Default_Areal.jpg}

\caption{\label{fig-1_2}Default-Aufteilung der Arbeitsbereiche.}

\end{figure}%

\section{Ãœbersicht Ã¼ber die Editor-Fenster von
Blender}\label{uxfcbersicht-uxfcber-die-editor-fenster-von-blender}

\marginnote{Editoren austauschen}

In jedem Editor-Areal befindet sich in der linken oberen Ecke eine
SchaltflÃ¤che. Durch das DrÃ¼cken dieser SchaltflÃ¤che wird ein
Dropdown-MenÃ¼ geÃ¶ffnet. Darin sind alle verfÃ¼gbaren Editoren
aufgelistet. Indem ein anderer Editor ausgetauscht wird, wechselt die
Anzeige in diesem Areal zu dem ausgewÃ¤hlten Editor.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_1/1_3_Editor_Select.png}

\caption{\label{fig-1_3}Die Auswahl an verschiedenen Editoren, welche
Blender standardmÃ¤ssig mit sich bringt.}

\end{figure}%

\subsection{3D Viewport}\label{d-viewport}

\marginnote{Â«GeneralÂ» Edito-ren}

Der 3D-Viewport stellt die bearbeiteten Szenen und die dazugehÃ¶rigen
3D-Objekte dar. Er bietet die MÃ¶glichkeit zur direkten Interaktion mit
diesen Objekten und ist fÃ¼r das Modellieren von Objekten essenziell. Bei
der Arbeit mit 3D-Objekten ist es der wichtigste Editor.

\subsection{Image Editor}\label{image-editor}

Anhand des Image-Editors kÃ¶nnen 2D-Grafiken betrachtet und bearbeitet
werden. Gerenderte Bilder werden ebenfalls in diesem Editor angezeigt.

\subsection{UV Editor}\label{uv-editor}

Der UV-Editor wird verwendet, um den FlÃ¤chen von Objekten eine bestimmte
Position auf einer Textur (sogenannte UVs) zuzuweisen oder dessen
Zuweisung zu betrachten.

\subsection{Compositor}\label{compositor}

Mithilfe des Compositors lassen sich Bilder, welche beim Rendern
erstellt werden, nachtrÃ¤glichen Bearbeitungen unterziehen. Auch externe
Bilder kÃ¶nnen hier bearbeitet werden. Die Bearbeitung erfolgt mittels
einer visuellen Programmiersprache.

\subsection{Texture Node Editor}\label{texture-node-editor}

Mithilfe des Texture-Node-Editors kÃ¶nnen Texturen anhand einer visuellen
Programmiersprache erstellt werden. Dieser Editor wird allerdings in
Zukunft durch andere Bearbeitungsoptionen ersetzt.

\subsection{Geometry Node Editor}\label{geometry-node-editor}

Der Geometry-Node-Editor ermÃ¶glicht das Bearbeiten von Objekten mittels
einer visuellen Programmiersprache. Innerhalb dieses Editors erfolgt
dabei die Programmierung der geometrischen Figuren, wÃ¤hrend die
Darstellung der Figuren im 3D-Viewport erfolgt. Bei den Geometry Nodes
handelt es sich um eine neue Funktion von Blender.

\subsection{Shader Editor}\label{shader-editor}

Mithilfe des Shader-Editors kÃ¶nnen die Materialien, welche einem
dreidimensionalen Objekt zugewiesen sind, bearbeitet werden. Dadurch
lÃ¤sst sich bearbeiten, wie die OberflÃ¤che eines Objektes aussieht. Die
Bearbeitung erfolgt hier mittels einer visuellen Programmiersprache.
Innerhalb dieses Editors werden lediglich die Einstellungen fÃ¼r die
Materialien gemacht. Um die Auswirkungen der Materialien zu sehen, wird
der 3D-Viewport verwendet.

\subsection{Video Sequencer}\label{video-sequencer}

Mithilfe des Video-Sequencers kÃ¶nnen Videoaufnahmen bearbeitet werden.
Dieser Editor verfÃ¼gt zusÃ¤tzlich Ã¼ber eine Vorschau-Option, mit der sich
die Videos direkt betrachten lassen.

\subsection{Movie Clip Editor}\label{movie-clip-editor}

Der Movie-Clip-Editor ermÃ¶glicht das Erfassen von Bewegungen in Filmen,
sodass diese Bewegungen beispielsweise auch auf 3D-Objekte angewendet
werden kÃ¶nnen. Zudem lassen sich hier auch Videos maskieren.

\subsection{Dope Sheet}\label{dope-sheet}

\marginnote{Editoren fÃ¼r Animationen}

Das Dope-Sheet stellt einzelne Animationspunkte eines Projektes in einem
zeitlichen Ablauf tabellarisch dar. Dies basiert auf der frÃ¼her
angewendeten Planung von handgezeichneten Animationen.

\subsection{Timeline}\label{timeline}

Die Timeline stellt einen zeitlichen Verlauf von Animationen dar. FÃ¼r
die ausgewÃ¤hlten Objekte wird hier durch Punkte dargestellt, wann eine
Animation im Zeitstrang starten oder enden soll. Zudem befindet sich
hier auch eine SchaltflÃ¤che, um Animationen abspielen zu lassen.

\subsection{Graph Editor}\label{graph-editor}

Mittels des Graph-Editors kÃ¶nnen Animationen Ã¼ber die Zeit hinweg
verfeinert werden. HierfÃ¼r werden die einzelnen Animationen mittels
Grafen dargestellt. Durch eine VerÃ¤nderung dieser Grafen wird die
Animation verfeinert.

\subsection{Drivers}\label{drivers}

Der Driver-Editor ermÃ¶glicht es, Animationen gezielt zu steuern. Dabei
kÃ¶nnen die Eigenschaften eines Objektes verwendet werden, um ein anderes
Objekt zu steuern.

\subsection{Nonlinear Animation}\label{nonlinear-animation}

Mittels des Editors fÃ¼r nonlineare Animationen kÃ¶nnen Animationen
ausserhalb eines linearen Ablaufes gesteuert werden. Dies kommt etwa bei
komplexeren VerÃ¤nderungen von Szenen zum Einsatz.

\subsection{Text Editor}\label{text-editor}

\marginnote{Editoren fÃ¼r Programmier-Skripte}

Im Text-Editor kÃ¶nnen Textdokumente eingesehen und erstellt werden.
Diese Textdokumente kÃ¶nnen auch verwendet werden, um mittels der
Programmiersprache Python Funktionen fÃ¼r Blender zu verfassen. Zudem
kÃ¶nnen im Text-Editor auch direkt Programmfunktionen in Textdokumenten
ausgefÃ¼hrt werden.

\subsection{Python Console}\label{python-console}

Anhand der Python-Konsole lassen sich Codes in der Programmiersprache
von Python eingeben. Blender fÃ¼hrt diese Codes anschliessend aus.

\subsection{Info}\label{info}

Im Info-Editor werden durchgefÃ¼hrte Aktionen in der
Python-Programmiersprache nacheinander aufgelistet. Hier lassen sich
auch Fehlermeldungen und Warnungen nachtrÃ¤glich einsehen.

\subsection{Outliner}\label{outliner}

\marginnote{Â«DataÂ»-Editoren}

Im Outliner werden alle Daten, welche sich in einer Blender-Datei
befinden, aufgelistet. Hier lassen sich Objekte innerhalb einer Szene
auswÃ¤hlen oder in Ordnerstrukturen (sogenannten Collections) anordnen
und gruppieren.

\subsection{Properties}\label{properties}

Im Properties Editor lassen sich eine Reihe von Einstellungen machen. Es
umfasst neben Einstellungen zu einem aktuell ausgewÃ¤hlten Objekt auch
Einstellungen zum Rendern, zur Szenengestaltung oder zu physikalischen
Simulationen.

\subsection{File Browser}\label{file-browser}

Mithilfe des File-Browsers lassen sich Dateien auf dem Computer
darstellen und suchen. Dadurch kÃ¶nnen Dokumente direkt in die Szene
hineingezogen werden, ohne dass Blender minimiert werden muss. Zudem
kÃ¶nnen hier auch Dateien abgespeichert werden.

\subsection{Spreadsheet}\label{spreadsheet}

Mithilfe des Spreadsheets lassen sich alle Datenpunkte eines Objektes
mitsamt deren Positionen in der 3D-Welt angeben. Nebst den Punkten
kÃ¶nnen auch die Positionen der verschiedenen Kanten und FlÃ¤chen von
Objekten angezeigt werden.

\subsection{Preferences}\label{preferences}

Unter den Preferences lassen sich die Einstellungen von Blender
bearbeiten. Die Preferences kÃ¶nnen auch unter Â«\emph{Edit \textbar{}
Preferences}Â» geÃ¶ffnet werden.

\section{Vorgefertigte
Editor-Anordnungen}\label{vorgefertigte-editor-anordnungen}

\marginnote{Schnelle Auswahl von Editoren mittels Editor-Anordnungen}

In der MenÃ¼leiste sind fÃ¼r verschiedene Arbeitsschritte bei der
3D-Modellierung bereits vorgefertigte Ansichtsoptionen verfÃ¼gbar. Durch
einen Klick auf den Reiter Â«\emph{Texture Paint}Â» wird beispielsweise
eine Anordnung gezeigt, welche ideal dafÃ¼r ist, um ein Objekt mit einer
Textur zu bemalen. In diesem Falle wird beispielsweise nebst dem
3D-Viewport auch der Image Editor geÃ¶ffnet. Mittels der Registerkarte
Â«+Â» kÃ¶nnen zudem weitere Editor-Anordnungen basierend auf einer Vorlage
fÃ¼r die Schnellauswahl hinzugefÃ¼gt werden.

\section{Neuanordnen der
Editor-Areale}\label{neuanordnen-der-editor-areale}

\marginnote{GrÃ¶sse der Edito-ren verÃ¤ndern}

Die einzelnen Editor-Fenster kÃ¶nnen nicht nur beliebig ausgetauscht
werden, sondern auch nach eigenem Belieben vergrÃ¶ssert oder verkleinert
werden. In den Abgrenzungsbereichen zwischen den Fenstern verÃ¤ndert sich
der Mauszeiger. Von dort aus lassen sich die Editor-Areale durch Hin-
und Herziehen vergrÃ¶ssern oder verkleinern.

\marginnote{Neue Editoren Ã¶ffnen}

In den Ecken der einzelnen Editor-Fenster gibt es zudem die MÃ¶glichkeit,
durch Ziehen der Ecke in eine Richtung das Fenster in zwei Editoren
aufzuteilen. Wenn dabei gleichzeitig die \kbd{Shift}-Taste gedrÃ¼ckt
wird, wird derselbe Editor in einem neuen, einzelnen Fenster geÃ¶ffnet.

\marginnote{Editor-Areal schliessen}

Um ein Editor-Fenster zu schliessen, wird jeweils ein anderes
Editor-Fenster Ã¼ber das zu schliessende Fenster gezogen. Dadurch werden
die beiden Fenster verbunden. Um zwei Fenster zu verbinden, wird eine
der beiden Ecken, welche sich zwischen den beiden Fenstern befindet,
ausgewÃ¤hlt und das zu behaltende Fenster Ã¼ber das zu entfernende Fenster
gezogen. Dies ist manchmal etwas knifflig, da die Aktion Ã¤hnlich zum
Ã–ffnen von neuen Fenstern ist.

Ãœbung 1: Editor-Auswahl

\textbf{Ãœbung 1.1}

Ordnen Sie die ArbeitsoberflÃ¤che entsprechend der nachfolgenden
Abbildung an.

\includegraphics{Chapters/Images/Chapter_1/Exercise_1_1.png}\hfill

\textbf{Ãœbung 1.2}

Ordnen Sie die ArbeitsoberflÃ¤che entsprechend der nachfolgenden
Abbildung an.

\includegraphics{Chapters/Images/Chapter_1/Exercise_1_2.png}\hfill

\chapter{Die ArbeitsoberflÃ¤che des
3D-Viewports}\label{die-arbeitsoberfluxe4che-des-3d-viewports}

\marginnote{Funktion des 3D-Viewports}

Der 3D-Viewport stellt eine der wichtigsten ArbeitsoberflÃ¤chen in
Blender dar. In ihm werden die 3D-Objekte sowie die Szenen, in denen sie
integriert werden, angezeigt. Zudem werden im 3D-Viewport eine Reihe
anderer Einstellungen dargestellt, welche in anderen Editoren
konfiguriert werden kÃ¶nnen. Die Bearbeitung der grundlegenden Struktur
von 3D-Objekten erfolgt in der Regel direkt im 3D-Viewport. Der
Arbeitsbereich des 3D-Viewports lÃ¤sst sich in verschiedene Areale
aufteilen, welche nachfolgend genauer betrachtet werden.

\section{Toolbar}\label{toolbar}

\marginnote{Toolbars}

Die Toolbar befindet sich auf der linken Seite der 3D-View. Allerdings
sind Toolbars auch in anderen Editoren anzutreffen. Die Toolbars lassen
sich jeweils mit der Taste \kbd{T} ein- und ausblenden. Da es auch im
3D-Viewport verschiedene BearbeitungsmÃ¶glichkeiten gibt, variieren die
Elemente in der Toolbar abhÃ¤ngig vom Bearbeitungsmodus. Diese sind
entweder per Mausklick Ã¼ber diese Toolbar oder mithilfe von
Tastenkombinationen aufrufbar. In diesem Kurs wird vor allem auf
Tastenkombinationen verwiesen, wenn Operationen durchgefÃ¼hrt werden.

\section{Sidebar}\label{sidebar}

\marginnote{Sidebars}

Die Sidebar befindet sich auf der rechten Seite des Viewport-Displays,
muss allerdings noch mit der Taste \kbd{N} geÃ¶ffnet werden. Mit dieser
Taste lÃ¤sst sich die Sidebar ebenfalls wieder verbergen. Die Sidebar ist
auch in anderen Editoren anzutreffen und wird dort ebenfalls mit der
Taste\kbd{N} ein- und ausgeblendet. Die Sidebar ist zudem anhand von
Registerkarten in zusÃ¤tzliche Kategorien eingeordnet. Unter dem Register
Â«\emph{Item}Â» kÃ¶nnen etwa Einstellungen zum aktuell ausgewÃ¤hlten Objekt
betrachtet und verÃ¤ndert werden, im Register Â«\emph{Tool}Â» kÃ¶nnen
Einstellungen zum aktuell ausgewÃ¤hlten Werkzeug verfeinert werden und
unter dem Register Â«\emph{View}Â» kÃ¶nnen Einstellungen zur Ansicht
betrachtet und verfeinert werden.

\section{Header}\label{header}

Im Header sind zusÃ¤tzliche Einstellungen aufzufinden. Diese kÃ¶nnen nicht
nur zwischen den einzelnen Editoren variieren, sondern auch zwischen den
einzelnen Bearbeitungsmodi inner-halb der 3D-View.

\subsection{Aktions-Einstellungen}\label{aktions-einstellungen}

In der oberen linken Ecke, direkt neben dem Bedienfeld fÃ¼r die Auswahl
des Editors, befinden sich EinstellungsmÃ¶glichkeiten, welche basierend
auf der aktuell durchgefÃ¼hrten Aktion verfeinert werden kÃ¶nnen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_2/2_1_Actions_Parameters.png}

\caption{\label{fig-2_1}Aktions-Einstellungen am Beispiel der Auswahl.}

\end{figure}%

\subsection{Erweiterte Hilfsmittel zur
Bearbeitung}\label{erweiterte-hilfsmittel-zur-bearbeitung}

\marginnote{Hilfsmittel zur Bearbeitung von Objekten}

In der Mitte des Headers befinden sich eine Reihe von erweiterten
Einstellungen, welche bei der Objektbearbeitung als Hilfsmittel
verwendet werden kÃ¶nnen. Hierzu gehÃ¶rt beispielsweise die proportionale
Bearbeitung von Objekten oder das Festlegen von Bezugspunkten fÃ¼r
Transformationen. Diese Hilfsmittel werden in einem spÃ¤teren Kapitel
ausfÃ¼hrlich behandelt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_2/2_2_Extended_helper.png}

\caption{\label{fig-2_2}Erweiterte Hilfsmittel.}

\end{figure}%

\subsection{Bearbeitungsmodus}\label{bearbeitungsmodus}

\marginnote{Auswahl des Bearbeitungsmodus}

In der Zeile unterhalb des Headers befindet sich links das MenÃ¼ zur
Auswahl des Bearbeitungsmodus. Dabei wird definiert, wie das aktuelle
Objekt bearbeitet werden soll. So kann beispielsweise im Object-Mode das
Objekt als Ganzes bearbeitet werden, wÃ¤hrend im Edit-Mode die Struktur
des Objektes bearbeitet werden kann.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_2/2_3_Edit_Mode_Choice.png}

\caption{\label{fig-2_3}Auswahl des Bearbeitungsmodus.}

\end{figure}%

\subsection{Anzeige-Optionen}\label{anzeige-optionen}

\marginnote{Anzeige-Optionen}

In der rechten oberen Ecke befinden sich Optionen zur Darstellung der
Objekte in der 3D-View. Diese umfassen:

\begin{itemize}
\tightlist
\item
  View Object Types
\item
  Show Gizmo
\item
  Show Overlay
\item
  Toggle X-Ray
\item
  Viewport Shading
\end{itemize}

\subsubsection{View Object Types}\label{view-object-types}

\marginnote{Ein- und Ausblen-den von Objektarten}

Hier lassen sich verschiedene Arten von Objekten alle gemeinsam
innerhalb einer Szene verstecken, indem das Auge zu der entsprechenden
Objektart abgewÃ¤hlt wird. Durch das AbwÃ¤hlen des Auges neben dem
Objekttyp Â«\emph{Camera}Â» werde etwa alle Kameras aus der Szene
unsichtbar gemacht. Die Objekte sind allerdings noch vorhanden und
weisen immer noch dieselbe Funktion auf -- sie werden lediglich nicht
mehr im 3D-Viewport angezeigt. Neben dem Auge lÃ¤sst sich zudem anhand
der SchaltflÃ¤che mit einem abgebildeten Cursor einstellen, dass die
entsprechenden Objektarten nicht mehr auswÃ¤hlbar sind.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_2/2_4_Icon_Viewobjecttypes.png}

\caption{\label{fig-2_4}View Object Types.}

\end{figure}%

\subsubsection{Show Gizmo}\label{show-gizmo}

\marginnote{Navigations-Tools ein- und ausblen-den}

Innerhalb dieser Option lassen sich in der oberen rechten Ecke Tools zur
Navigation mittels der Kamera ein- und ausblenden. Zudem kann hier die
Darstellung eines Gizmos bei der aktuellen Auswahl aktiviert werden.
Dieses Gizmo kann verwendet werden, um Objekte mittels der Maus zu
rotieren, zu skalieren oder zu bewegen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_2/2_5_Icon_Show_Gizmos.png}

\caption{\label{fig-2_5}Show Gizmo.}

\end{figure}%

\subsubsection{Show Overlays}\label{show-overlays}

\marginnote{Orientierungsobjekte im Viewport ein- und ausblenden}

Durch die Deaktivierung der Viewport-Overlays wird im 3D-Viewport die
Ansicht bestimmter Hilfsmittel (beispielsweise die Achsen oder die
Markierung der aktuellen Auswahl) ausgeschal-tet. Im Dropdown-MenÃ¼ lÃ¤sst
sich zudem die Darstellung von einzelnen Hilfsmitteln individuell an-
und abwÃ¤hlen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_2/2_6_Icon_Showoverlays.png}

\caption{\label{fig-2_6}Show Overlays.}

\end{figure}%

\subsubsection{Toggle X-Ray}\label{toggle-x-ray}

\marginnote{RÃ¶ntgenblick ein- und ausschalten}

Wenn die SchaltflÃ¤che Â«Toggle X-RayÂ» ausgewÃ¤hlt ist, erweitert sich die
Ansicht von Objekten, sodass durch sie hindurchgesehen werden kann. Dies
ermÃ¶glicht es etwa, dass auch ein Objekt, welches hinter einem anderen
Objekt verborgen liegt, betrachtet werden kann. Wenn diese Option
aktiviert ist, kÃ¶nnen zudem die verborgenen Objekte mittels eines
Mausklicks angewÃ¤hlt werden. Die SchaltflÃ¤che kann auch mit den Tasten
\kbd{Alt} + \kbd{Z} ein- und ausgeschaltet werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_2/2_7_Icon_Xray.png}

\caption{\label{fig-2_7}Toggle X-Ray.}

\end{figure}%

\subsubsection{Viewport Shading}\label{viewport-shading}

\marginnote{Art der Objektdar-stellung im Viewport}

In der rechten oberen Ecke befinden sich vier SchaltflÃ¤chen, um
einzustellen, welche Elemente bei der Darstellung der Objekte
berÃ¼cksichtigt werden sollen. Je nach Auswahl werden dadurch die Objekte
unterschiedlich dargestellt:

\begin{itemize}
\tightlist
\item
  \textbf{Wireframe}: Die Objekte werden in ihrer Struktur als
  Gitternetz angezeigt, sodass deren Aufbaugitter klar ersichtlich wird.
  Hierbei werden die FlÃ¤chen der Objekte nicht dargestellt.
\item
  \textbf{Solid}: Die Objekte werden als Ganzes dargestellt, sodass auch
  die FlÃ¤chen sichtbar sind. Allerdings werden die verwendeten
  Materialien und Texturen nicht berÃ¼cksichtigt.
\item
  \textbf{Material Preview}: Die Objekte werden als Ganzes dargestellt,
  inklusive deren Materialien und Texturen. Die Umgebung wird anhand von
  vorgefertigten Szenen und Umgebungen beleuchtet, sodass eine schnelle
  Vorschau mÃ¶glich ist.
\item
  \textbf{Rendered}: Die Objekte werden als Ganzes dargestellt,
  inklusive deren Materialien und Texturen. Die Umgebung und die
  Beleuchtung entsprechen den Einstellungen der aktuellen Szene, sodass
  eine Vorschau fÃ¼r die gerenderte Szene mÃ¶glich ist.
\end{itemize}

Alternativ kann die Taste \kbd{Z} gedrÃ¼ckt werden. Dadurch erscheint
beim Mauszeiger ein MenÃ¼ mit allen vier Optionen zum Viewport Shading
zur Auswahl.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_2/2_8_Icon_Shaderbuttons.png}

\caption{\label{fig-2_8}SchaltflÃ¤chen fÃ¼r die Shading-Optionen im
Viewport.}

\end{figure}%

\section{Letzte Aktion verfeinern}\label{letzte-aktion-verfeinern}

\marginnote{TemporÃ¤res MenÃ¼ zur Verfeinerung der letzten Aktion}

Wenn eine Aktion in Blender durchgefÃ¼hrt wird, erscheint in der linken
unteren Ecke des 3D-Viewports temporÃ¤r ein MenÃ¼. Dieses MenÃ¼ kann
aufgeklappt werden und bietet abhÃ¤ngig von der durchgefÃ¼hrten Aktion
eine Reihe Verfeinerungen. Zu beachten ist jedoch, dass dieses MenÃ¼
sofort wieder verschwindet, sobald ein Mausklick ausserhalb des MenÃ¼s
erfolgt. Um das MenÃ¼ wieder erscheinen zu lassen, muss die Aktion
rÃ¼ckgÃ¤ngig gemacht und erneut durchgefÃ¼hrt werden.

\section{Dargestellte
Viewport-Overlays}\label{dargestellte-viewport-overlays}

\marginnote{Achsen}

Sofern die Ansicht der Viewport-Overlays aktiviert ist, werden im
3D-Viewport einige nÃ¼tzliche Dinge dargestellt. Zum einen werden die
verschiedenen drei Achsen in unterschiedlichen Farben vom Nullpunkt der
Szene aus dargestellt:

\begin{itemize}
\tightlist
\item
  X-Achse: rot
\item
  Y-Achse: grÃ¼n
\item
  Z-Achse: blau
\end{itemize}

Zudem wird leicht schattiert ein Gitternetz dargestellt, bei dem jedes
Quadrat eine Einheit von einem Meter darstellt. Wird aus der Szene
hinausgezoomt, werden diese Quadrate zunehmend kleiner, dafÃ¼r werden
anschliessend quadratische Felder mit der Einheit von 10 Metern
sichtbar.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_2/2_9_3DCursor.png}

\caption{\label{fig-2_9}3D-Cursor.}

\end{figure}%

\marginnote{3D-Cursor}

Innerhalb des 3D-Viewports ist ausserdem der 3D-Cursor sichtbar. Dieser
ist an einer bestimmten Position in der Szene platziert und dort mittels
eines rot-weissen Kreises dargestellt. Neu erstellte Objekte werden an
seiner Position in die Szene eingefÃ¼gt und der 3D-Cursor kann als
Bezugspunkt fÃ¼r Transformationen verwendet werden.

\chapter{Navigation der Ansicht im
3D-Viewport}\label{navigation-der-ansicht-im-3d-viewport}

\marginnote{Navigation in der 3D-Ansicht}

Die Ansicht auf die Objekte im 3D-Viewport kann beliebig verÃ¤ndert
werden. Nebst der standardmÃ¤ssigen Ansichtssteuerung Ã¼ber die Maus kann
auch das Nummernfeld der Tastatur verwendet werden. In der Regel werden
beide Optionen verwendet. Die Navigation mit der Maus bietet tendenziell
eine grÃ¶ssere FlexibilitÃ¤t, wÃ¤hrend die Navigation mit der Tastatur eine
grÃ¶ssere PrÃ¤zision ermÃ¶glicht.

\section{Navigation mit der Maus}\label{navigation-mit-der-maus}

\marginnote{Ansicht mit der Maus verÃ¤ndern}

Je nach Aufbau der verwendeten Computermaus unterscheidet sich die
Navigation durch den 3D-Viewport mit der Maus etwas. Bei einer
Computermaus mit einem Mausrad erfolgt die Navigation im 3D-Viewport
durch Mausbewegungen bei gedrÃ¼ckter Rad-Taste. Bei Trackpads oder MÃ¤usen
mit integriertem Trackpad erfolgt die Navigation mittels
Wischbewegungen. Bei einer normalen Bewegung wird dabei lediglich die
Ansicht entsprechend der Bewegung rotiert. Durch gleichzeitiges DrÃ¼cken
der \kbd{Shift}-Taste wird die Ansicht in die entsprechenden Richtungen
bewegt (ohne eine Rotation). Mittels gedrÃ¼ckter \kbd{Ctrl}-Taste kann
durch die Mausbewegung hinein- oder hinausgezoomt werden. Durch das
Drehen des Mausrads wird die Ansicht ebenfalls hinein- oder
hinausgezoomt.

\section{Navigation mit der Tastatur}\label{navigation-mit-der-tastatur}

\marginnote{Emulation des Nummernblocks}

Nebst der Maus kann auch die Tastatur verwendet werden, um die Ansicht
zu verÃ¤ndern. Diese Option ergibt sich allerdings nur, wenn man Ã¼ber
einen Nummernblock verfÃ¼gt. Wenn kein Nummernblock zur VerfÃ¼gung steht,
lassen sich auch die Zahlen-Tasten oberhalb der Buchstaben fÃ¼r die
Navigation verwenden. HierfÃ¼r muss allerdings in den
Benutzereinstellungen (Â«\emph{Edit \textbar{} Preferences}Â») in den
Einstellungen zum Â«\emph{Input}Â» beim Keyboard-Reiter die Einstellung
Â«\emph{Emulate Numpad}Â» aktiviert werden.

\marginnote{Rotieren und Drehen der Ansicht}

Mittels der Tasten \kbd{2}, \kbd{4}, \kbd{6} und \kbd{8} kann die
Ansicht entsprechend ihrer relativen Anordnung auf dem Nummernblock
rotiert werden: Die Taste \kbd{2} rotiert nach unten, die Taste \kbd{4}
nach links, die Taste \kbd{6} nach rechts und die Taste \kbd{8} nach
oben. Werden dieselben Tasten bei gedrÃ¼ckter \kbd{Ctrl}-Taste gedrÃ¼ckt,
wird die Ansicht in die entsprechende Richtung bewegt, ohne eine
Rotation durchzufÃ¼hren. Mittels gedrÃ¼ckter \kbd{Shift}-Taste kann die
Ansicht durch die Taste \kbd{6} zudem im Uhrzeigersinn und mittels der
Taste \kbd{4} gegen den Uhrzeigersinn gedreht werden. Um nÃ¤her
hineinzuzoomen wird die Taste \kbd{+} und zum Hinauszoomen die Taste
\kbd{-} verwendet.

\marginnote{PrÃ¤zise Ansichten ansteuern}

Mittels der Taste \kbd{1} kann die Ansicht direkt in die Vorderansicht
gedreht werden. Die Ansicht erfolgt anschliessend entlang der Y-Achse.
Die RÃ¼ckansicht ist mit der Tastenkombination \kbd{Ctrl} + \kbd{1}
einstellbar. Mittels der Taste wird die Seitenansicht -- von der rechten
Seite aus zum Objekt hingewÃ¤hlt. Das Objekt wird in diesem Falle entlang
der X-Achse betrachtet. Mit der Tastenkombination \kbd{Ctrl} + \kbd{3}
ist die Seitenansicht von der linken Seite aus einstellbar. Um die Szene
aus der Vogelperspektive zu betrachten, kann die Taste \kbd{7} gedrÃ¼ckt
werden. Hierbei erfolgt die Ansicht der Z-Achse entlang. Mittels der
Tastenkombination \kbd{Ctrl} + \kbd{7} erfolgt die Ansicht von unten.

\marginnote{Perspektivische und orthogonale Darstelung}

Jede der Ansichten kann auf zwei Arten erfolgen: perspektivisch oder
orthogonal. Die perspektivische Ansicht berÃ¼cksichtigt
Tiefeninformationen, sodass weiter entfernte Objekte kleiner dargestellt
werden. Die orthogonale Perspektive ignoriert die Tiefeninformationen,
wodurch weiter entfernte Objekte gleich gross angezeigt werden wie
nÃ¤here gleich grosse Objekte auf der entsprechenden Achse. Diese
Perspektive hat den Vorteil, dass Objekte in ihrer geometrischen Form in
2D betrachtet werden kÃ¶nnen. Mittels der Taste \kbd{5} kann zwischen
diesen beiden Ansichtsmodi gewechselt werden.

\marginnote{Kamera-Ansicht}

Mittels der Taste \kbd{0} kann die Ansicht direkt in die Position der
Kamera gelegt werden. Dadurch wird die Szene genau so betrachtet, wie
sie im finalen Render betrachtet werden wird. Wenn in einer Szene keine
Kamera vorhanden ist, steht diese Ansicht nicht zur VerfÃ¼gung.Wenn
mehrere Kameras vorhanden sind, wird jeweils die Kamera, welche die
aktive Render Kamera darstellt, anvisiert. Um die Kameraperspektive zu
verlassen kann die Ansicht mittels der Maus bewegt werden, oder erneut
die Taste \kbd{0} gedrÃ¼ckt werden.

Merke\ldots{}

\includegraphics{Chapters/Images/Chapter_3/3_1_Number_Tabel.png}\hfill

\marginnote{Fokus auf ein Objekt}

In komplexeren Szenen kann es sein, dass man die Ãœbersicht Ã¼ber die
Objekte verliert, oder dass sie sich gegenseitig im Weg stehen bei der
Ansicht. Mittels der Taste \kbd{.} auf dem Nummernblock wird die Ansicht
direkt auf ein ausgewÃ¤hltes Objekt gezoomt. Diese Aktion lÃ¤sst sich
nicht mit der Taste \kbd{.} ausserhalb des Nummernblocks emulieren.
Mittels der Taste \kbd{/} kann zudem die lokale Ansicht aktiviert
werden. In dieser Ansicht wird lediglich das ausgewÃ¤hlte Objekt
dargestellt, sodass es in komplexen Szenen besser betrachtet werden
kann. Allerdings muss anschliessend die Taste erneut gedrÃ¼ckt werden, um
die lokale Ansicht wieder zu verlassen. Auch diese Aktion lÃ¤sst sich
nicht mit einer anderen Taste ausserhalb des Nummernblocks emulieren.

\section{Navigation mittels Gizmos}\label{navigation-mittels-gizmos}

Auf der rechten Seite des 3D-Viewports lassen sich zudem SchaltflÃ¤chen
anzeigen, mit denen die Ansicht gesteuert werden kann. Um diese anzeigen
zu lassen, mÃ¼ssen die Gizmos eingeschaltet sein. Wird die linke
Maustaste auf das Kamera-Icon angewendet, wird die Kamera-Ansicht
aktiviert. Das Icon darunter, welches ein Gitternetz darstellt, dient
dem Wechsel zwischen perspektivischer und orthogonaler Ansicht. Die
beiden oberen Icons dienen dem Zoomen (mittels der Lupe) und dem Bewegen
der Ansicht (Hand). HierfÃ¼r muss das Icon angeklickt und die Maus
anschliessend bei weiterhin gedrÃ¼ckter Maustaste bewegt werden. Zuoberst
findet sich zudem ein Koordinatensystem, mit dem die Perspektive per
Mausklick oder mittels gedrÃ¼ckter Maustaste verÃ¤ndert werden kann.

\chapter{Erste Schritte}\label{erste-schritte}

\section{Die Default-Szene}\label{die-default-szene}

\marginnote{Objekte in der Default-Szene}

Beim Start eins neuen Projekts erscheint eine Default-Szene. Diese Szene
beinhaltet bereits die wesentlichen Dinge, welche fÃ¼r eine 3D-Szene
benÃ¶tigt werden:

\begin{itemize}
\tightlist
\item
  \textbf{WÃ¼rfel}: Genau in der Mitte der Szene befindet sich der
  Default-Cube. Bei diesem WÃ¼rfel handelt es sich um ein 3D-Objekt. Er
  hat eine GrÃ¶sse von 2x2x2 Metern.
\item
  \textbf{Kamera}: Von der Kamera aus wird eine Szene nach deren
  Verarbeitung (z.B. in einem geren derten Bild oder einem Video)
  betrachtet. In der Default-Szene ist die Kamera auf den WÃ¼rfel
  gerichtet.
\item
  \textbf{Lichtquelle}: Die Lichtquelle wird dafÃ¼r benÃ¶tigt, dass der
  WÃ¼rfel in der gerenderten Aufnahme beleuchtet wird. Ohne eine
  Lichtquelle sind die 3D-Objekte beim anschliessenden Rendern nicht
  sichtbar -- es sei denn, sie stellen selbst eine Lichtquelle dar.
\end{itemize}

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Die Default-Szene kann manuell angepasst werden. HierfÃ¼r muss zunÃ¤chst eine Default-Szene erstellt werden, welche bei jedem Start erscheinen soll. Diese kann dann unter Â«*File* \| *Defaults* \| *Save Startup File*Â» als neue Start-up Szene gespeichert werden.
\end{tipp}

\section{Auswahl von Objekten}\label{auswahl-von-objekten}

\marginnote{Auswahl und Abwahl mittels Mausklick}

Durch das Anklicken mittels der linken Maustaste kÃ¶nnen Objekte im
3D-Viewport ausgewÃ¤hlt werden. Die ausgewÃ¤hlten Objekte sind
anschliessend anhand einer farblichen Markierung erkennbar. Durch das
Klicken in den leeren Raum des Viewport-Displays lassen sich die Objekte
wieder abwÃ¤hlen. Zudem wird durch die Auswahl eines anderen Objektes das
vorher ausgewÃ¤hlte Objekt abgewÃ¤hlt.

\marginnote{Mehrfachwahl mittels \kbd{Shift}}

Um mehrere Objekte gleichzeitig auszuwÃ¤hlen, gibt es verschiedene
MÃ¶glichkeiten. Eine MÃ¶glichkeit besteht darin, dass nacheinander Objekte
bei gedrÃ¼ckter \kbd{Shift}-Taste angeklickt und so zur Auswahl
hinzugefÃ¼gt werden. Durch die Auswahl von mehreren Objekten wird das
zuletzt ausgewÃ¤hlt Objekt mit einer orangen und die vorherig
ausgewÃ¤hlten Objekte mittels einer roten Farbe markiert.

\marginnote{Aktives Objekt}

Die Markierung mit einer orangen Farbe gibt jeweils an, dass es sich bei
diesem Objekt um das aktive Objekt handelt. Diese Unterscheidung wird in
spÃ¤teren Kapiteln noch von Bedeutung sein, etwa wenn Merkmale vom
aktiven Objekt auf andere Objekte Ã¼bertragen werden sollen, oder wenn
ein Objekt in Bezug zum aktiven Objekt verÃ¤ndert werden soll. FÃ¼r den
aktuellen Stand ist jedoch vor allem wichtig, wie die Objekte ausgewÃ¤hlt
werden, und hierfÃ¼r macht die rote oder orange Markierung noch keinen
Unterschied aus.

\marginnote{Box-Selection mittels \kbd{B}}

Alternativ kann auf den Box-Select-Modus zurÃ¼ckgegriffen werden. Dieser
wird mit der \kbd{B} Taste aktiviert. Durch das GedrÃ¼ckthalten der
linken Maustaste lÃ¤sst sich anschliessend ein Viereck Ã¼ber den
Bildschirm ziehen. Alle Objekte, welche sich anschliessend innerhalb
dieser Box befinden, werden nach dem Loslassen der linken Maustaste
ausgewÃ¤hlt. Mittels der Taste \kbd{esc} oder der rechten Maustaste lÃ¤sst
sich die Box-Selection abbrechen.

\marginnote{Circle-Selection mittels \kbd{C}}

Alternativ kÃ¶nnen Objekte auch mit dem Circle-Select-Modus ausgewÃ¤hlt
werden. Der Circle-Select Modus wird mit der Taste \kbd{C} aktiviert.
Bei der Verwendung des Circle-Select-Modus ist der Mauszeiger von einem
Kreis umgeben. Mithilfe des Mausrads kann die GrÃ¶sse des Kreises
eingestellt werden. Durch einen Klick mit der linken Maustaste werden
die Objekte, welche sich innerhalb dieses Kreises befinden, alle
ausgewÃ¤hlt. Durch das Bewegen des Mauszeigers bei gedrÃ¼ckter linken
Maustaste kÃ¶nnen so eine Reihe weiterer Objekte ausgewÃ¤hlt werden. Der
Circle-Select-Modus muss allerdings aktiv beendet werden, da ein
weiterer Klick mit der linken Maustaste zu einer weiteren Auswahl von
Objekten fÃ¼hrt. Um den Circle-Select-Modus wieder zu verlassen, kann die
Taste \kbd{Enter}, \kbd{esc} oder der rechten Maustaste gedrÃ¼ckt werden.
Anschliessend sind alle Objekte, welche im Circle-Select-Modus
angeklickt wurden, ausgewÃ¤hlt.

\marginnote{Auswahl umkehren}

Mittels der Tastenkombination \kbd{Ctrl} + \kbd{I} ist es mÃ¶glich, die
Auswahl umzukehren. Dadurch werden alle ausgewÃ¤hlten Objekte abgewÃ¤hlt
und alle anderen Objekte ausgewÃ¤hlt. Wenn alle Objekte innerhalb einer
Szene ausgewÃ¤hlt werden sollen, kann die Taste \kbd{A} gedrÃ¼ckt werden.
Dadurch werden auch Objekte, die mÃ¶glicherweise ausserhalb des gerade
sichtbaren Bereichs liegen, ausgewÃ¤hlt.

\marginnote{Auswahl von Objekten im Outliner}

Im Outliner auf der rechten Seite wird mittels einer blauen Markierung
angezeigt, welches Objekt gerade ausgewÃ¤hlt ist. Zudem lassen sich auch
hier Objekte auswÃ¤hlen, indem sie mittels der linken Maustaste
angeklickt werden. Die Auswahl von mehreren Objekten kann analog wie im
Viewport-Display mittels des GedrÃ¼ckthaltens der \kbd{Shift}-Taste
getroffen werden oder durch eine Box-Auswahl mittels der Taste \kbd{B} .
Auch hier kÃ¶nnen alle Objekte mittels der Taste \kbd{A} gemeinsam
ausgewÃ¤hlt werden. Der Circle-Select-Modus funktioniert allerdings nicht
im Outliner.

\section{HinzufÃ¼gen von Objekten}\label{hinzufuxfcgen-von-objekten}

\marginnote{HinzufÃ¼gen von Objekten mittels \kbd{Shift} + \kbd{A}}

Mittels der Tastenkombination \kbd{Shift} + \kbd{A} erscheint beim
Mauszeiger das MenÃ¼-Feld Â«\emph{Add}Â». Dabei handelt es sich um dasselbe
MenÃ¼-Feld, welches auch unter dem Reiter Â«\emph{Add}Â» in der linken
oberen Ecke aufgerufen werden kann. Mithilfe dieses MenÃ¼-Felds kÃ¶nnen
eine Reihe von verschiedenen Objekten im Viewport Display hinzugefÃ¼gt
werden. Es gibt eine Reihe verschiedener Objektarten, welche hinzugefÃ¼gt
werden kÃ¶nnen. Beispielsweise kann unter Â«\emph{Mesh} \textbar{}
\emph{Cube}Â» ein WÃ¼rfel in die Szene hinzugefÃ¼gt werden. Ein neues
Objekt wird jeweils an der Position des 3D-Cursors eingefÃ¼gt.

\marginnote{Neue Objekte anpassen}

Wenn ein neues Objekt hinzugefÃ¼gt wird, wird dieses Objekt direkt
angewÃ¤hlt und farblich markiert. Zudem erscheint in der unteren linken
Ecke des Viewport-Displays ein Kontext-MenÃ¼-Feld. Dieses MenÃ¼-Feld kann
aufgeklappt werden und beinhaltet Einstellungen zum Objekt, welche noch
spezifiziert werden kÃ¶nnen. Beim HinzufÃ¼gen eines WÃ¼rfels besteht etwa
die MÃ¶glichkeit, dass man dessen GrÃ¶sse (Size), seine Position und seine
Rotation entlang der X-, Y- und Z-Achse anpassen kann. Da das Objekt
jeweils an der Stelle des 3D-Cursors erscheint, entspricht die Position
des Objektes in diesem MenÃ¼ jeweils auch der Position des 3D-Cursors.

\marginnote{Kontext-MenÃ¼ zum neuen Objekt}

Das Kontext-MenÃ¼, welches beim HinzufÃ¼gen von Objekten erscheint, ist
nur temporÃ¤r vorhanden. Sobald mit der linken Maustaste in einen Bereich
ausserhalb des Kontext-MenÃ¼s geklickt wird, verschwindet das MenÃ¼-Feld.
Es gibt keine MÃ¶glichkeit, dieses MenÃ¼-Feld zurÃ¼ckzuholen -- es ist fÃ¼r
immer fÃ¼r dieses Objekt verschwunden. Wenn das MenÃ¼ nochmals benÃ¶tigt
werden sollte, muss das entsprechende Objekt erneut zur Szene
hinzugefÃ¼gt werden.

Merke\ldots{}

Kontext-MenÃ¼-Felder erscheinen in der linken unteren Ecke des
Viewport-Displays und sind nur temporÃ¤r verfÃ¼gbar. Nach einem Klick
ausserhalb des MenÃ¼-Feldes verschwinden dieses Felder und kÃ¶nnen nicht
mehr zurÃ¼ckgeholt werden.

\section{LÃ¶schen von Objekten}\label{luxf6schen-von-objekten}

\marginnote{LÃ¶schen von Objekten mittels \kbd{X}}

Wenn ein Objekt gelÃ¶scht werden soll, muss dieses zunÃ¤chst ausgewÃ¤hlt
werden. Mittels der Taste \kbd{X} wird der Befehl fÃ¼r die LÃ¶schung des
ausgewÃ¤hlten Objektes gegeben. Dieser muss anschliessend bestÃ¤tigt
werden, entweder mit einem Mausklick auf das daraufhin beim Mauszeiger
erscheinende Â«\emph{Delete}Â»-Feld oder mittels der Taste \kbd{Enter}.
Alternativ kann auch die Taste \kbd{Delete} verwendet werden -- hierbei
wird das Objekt direkt gelÃ¶scht, ohne dass eine BestÃ¤tigung nÃ¶tig ist.

Ãœbung 2: HinzufÃ¼gen und LÃ¶schen

\textbf{Ãœbung 2.1}

LÃ¶schen Sie alle Objekte aus der Szene.

\textbf{Ãœbung 2.2}

Erstellen Sie einen neuen WÃ¼rfel mit der GrÃ¶sse 1 und einer Rotation von
90Â°. Welche Achse Sie hierfÃ¼r wÃ¤hlen, spielt keine Rolle.

Merke\ldots{}

Mittels \kbd{Shift} + \kbd{A} erscheint beim Mauszeiger das MenÃ¼ zum
HinzufÃ¼gen von Objekten.

Um Objekte zu lÃ¶schen, mÃ¼ssen sie zunÃ¤chst ausgewÃ¤hlt werden und kÃ¶nnen
anschliessend mit der Taste \kbd{X} oder \kbd{Delete} gelÃ¶scht werden.

\section{Objekte vervielfÃ¤ltigen}\label{objekte-vervielfuxe4ltigen}

\marginnote{Methoden zur VervielfÃ¤ltigung von Objekten}

AusgewÃ¤hlte Objekte kÃ¶nnen auf verschiedene Arten dupliziert werden.
Jede diese Arten hat ihre eigenen Besonderheiten:

\begin{itemize}
\tightlist
\item
  Duplizieren des Objektes
\item
  Verbundene Duplikate erstellen
\item
  EinfÃ¼gen einer Kopie des Objektes mittels Copy-Paste
\end{itemize}

\subsection{Objekte duplizieren}\label{objekte-duplizieren}

\marginnote{Duplikat eines Objektes erstellen mittels \kbd{Shift} + \kbd{D}}

Die schnellste Methode, um Objekte zu duplizieren, besteht darin, dass
die entsprechenden Objekte, welche dupliziert werden sollen, ausgewÃ¤hlt
werden und anschliessend mit der Tastenkombination \kbd{Shift} + \kbd{D}
der Befehl zur Duplikation der Objekte gegeben wird. Dadurch entsteht an
der Position des originalen Objekts ein Duplikat, welches mit der
Bewegung des Mauszeigers im Raum bewegt werden kann. Durch einen Klick
mit der linken Maustaste, \kbd{Space}- oder \kbd{Enter}-Taste wird das
Objekt anschliessend platziert. Die Bewegung des duplizierten Objekts
kann auch mittels abgebrochen werden. Dadurch wird das Duplikat
allerdings nicht gelÃ¶scht, sondern an derselben Position wie das
Original platziert.

\subsection{Verbundene Duplikate
erstellen}\label{verbundene-duplikate-erstellen}

\marginnote{Verbundene Duplikate erstellen mittels \kbd{Alt} + \kbd{D}}

Nebst einem normalen Duplikat kann auch ein verbundenes Duplikat
erstellt werden. HierfÃ¼r wird nach der Auswahl der zu duplizierenden
Objekte die Tastenkombination \kbd{Alt} + \kbd{D} gedrÃ¼ckt. Auch bei
dieser Methode kann das Objekt mit der Maus im Raum bewegt und mittels
der linken Maustaste oder \kbd{Enter}Taste platziert werden. Wird nun in
weiteren Arbeitsschritten entweder das originale oder das verbunden
duplizierte Objekt bearbeitet, fÃ¼hrt dies dazu, dass dieselben
VerÃ¤nderungen gleichzeitig auch bei allen verbundenen Objekten
durchgefÃ¼hrt werden.

\subsection{Copy-Paste von Objekten}\label{copy-paste-von-objekten}

\marginnote{Objekte mittels Copy-Paste vervielfÃ¤ltigen}

Eine weitere Methode zur VervielfÃ¤ltigung von Objekten besteht darin,
dass die zu vervielfÃ¤ltigenden Objekte ausgewÃ¤hlt und mittels \kbd{Ctrl}
+ \kbd{C} kopiert und anschliessend mittels \kbd{Ctrl} + \kbd{V} wieder
eingefÃ¼gt werden. Im Gegensatz zur normalen und zur verbundenen
Duplizierung werden die eingefÃ¼gten Objekte direkt platziert und mÃ¼ssen
durch weitere Befehle verschoben werden. Zudem werden bei dieser Methode
auch von den Materialien des Objektes eine Kopie erstellt, welche dann
dem neu eingefÃ¼gten Objekt zugewiesen wird. Dadurch fÃ¼hrt eine
Bearbeitung des Materials des originalen Objekts nicht zu einer
VerÃ¤nderung des Materials des neu eingefÃ¼gten Objekts. Allerdings kann
dem eingefÃ¼gten Objekt auch wieder das originale Material zugewiesen
werden.

\section{Verbinden von Objekten}\label{verbinden-von-objekten}

\marginnote{Join mittels \kbd{Ctrl} + \kbd{J}}

Mehrere Objekte lassen sich auch verbinden, sodass sie zu einem Objekt
werden. HierfÃ¼r mÃ¼ssen die zu verbindenden Objekte markiert werden. Die
Verbindung der Objekte erfolgt anschliessend mittels der
Tastenkombination \kbd{Ctrl} + \kbd{J} . Wichtig ist dabei, dass eines
der markierten Objekte das aktive Objekt darstellt. Ãœblicherweise
handelt es sich dabei um das zuletzt ausgewÃ¤hlte Objekt. Das aktive
Objekt ist jeweils anhand einer orangen statt einer roten Markierung
ersichtlich. Die anderen Objekte werden anschliessend zum aktiven Objekt
hinzugefÃ¼gt. Wenn mehrere Objekte ausgewÃ¤hlt sind, allerdings kein
Objekt der Auswahl das aktive Objekt darstellt, wird das Verbinden von
Objekten nicht durchgefÃ¼hrt.

\section{Verstecken von Objekten}\label{verstecken-von-objekten}

\marginnote{Verstecken von Objekten mittels \kbd{H}}

Gerade bei sehr komplexen Szenen kann es vorkommen, dass sich die
Objekte gegenseitig verdecken und die Bearbeitung etwas schwieriger
wird. In diesem Falle gibt es die MÃ¶glichkeit, Objekte in der Ansicht zu
verstecken. AusgewÃ¤hlte Objekte kÃ¶nnen mittels der Taste versteckt
werden. Im Outliner sind die Objekte nach wie vor noch angegeben,
allerdings grau hinterlegt. Mittels der Tastenkombination \kbd{Alt} +
\kbd{H} werden alle versteckten Objekte wieder angezeigt. Mittels der
Tastenkombination \kbd{Shift} + \kbd{H} lassen sich zudem alle Objekte,
ausser den ausgewÃ¤hlten Objekten, verstecken. Dadurch sind nur noch die
markierten Objekte sichtbar.

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Statt Objekte in einer Szene zu verstecken kann alternativ auch die lokale Ansicht mittels der Taste \kbd{/} auf diese Objekte angewendet werden. In dieser Ansicht werden alle anderen Objekte ausgeblendet. Um wieder in die normale Ansicht zu gelangen, muss erneut die Taste \kbd{/} gedrÃ¼ckt werden.
\end{tipp}

\marginnote{Versteckte Objekte im Outliner aufdecken}

Um einzelne Objekte wieder anzeigen zu lassen, kann im Outliner das
geschlossene Auge neben dem entsprechenden Objekt angewÃ¤hlt werden.
Analog kann auch ein geÃ¶ffnetes Auge angewÃ¤hlt werden, um die Objekte zu
verstecken. Das Verstecken von Objekten bezieht sich nur auf den
Viewport-Display. In einem finalen Render werden die Objekte trotzdem
gerendert und sind dementsprechend sichtbar.

\section{Anordnen in Collections}\label{anordnen-in-collections}

\marginnote{Collections}

Im Outliner lassen sich die verschiedenen Objekte in Collections
anordnen. HierfÃ¼r werden die Objekte jeweils in eine Collection
hineingezogen. Anschliessend werden die Objekte innerhalb dieser
Collection aufgelistet. Auch andere Collections kÃ¶nnen in eine
Collection hineingezogen werden. Somit kÃ¶nnen mithilfe der Collections
Ordnerstrukturen im Outliner erstellt werden. Dies ermÃ¶glicht, dass die
Objekte innerhalb einer Collection als gemeinsame Gruppe fÃ¼r komplexere
Vorhaben verwendet werden kÃ¶nnen -- etwa fÃ¼r Partikel-Effekte.

\marginnote{HinzufÃ¼gen und Deaktivieren von Collections}

Mithilfe der SchaltflÃ¤che oben rechts in der Ecke des Outliners kÃ¶nnen
neue Collections hinzugefÃ¼gt werden. HierfÃ¼r muss je nach
BildschirmgrÃ¶sse allenfalls der Header des Outliners nach rechts
gescrollt oder der Outliner vergrÃ¶ssert werden. Mittelt dem
KontrollkÃ¤stchen neben einer Collection lassen sich die Objekte
innerhalb einer Collection deaktivieren. Die entsprechenden Objekte
werden anschliessend im Viewport nicht mehr angezeigt und auch beim
Rendern nicht mehr berÃ¼cksichtig.

\section{Speichern}\label{speichern}

\marginnote{Zwischenspeichern mittels \kbd{Ctrl} + \kbd{S} ist unabdingbar}

Bisher wurden bereits einige Tastenkombinationen angesprochen. Die
wichtigste Tastenkombination stellt allerdings die Kombination fÃ¼r das
Abspeichern des aktuellen Projekts dar: \kbd{Ctrl} + \kbd{S}.
Zwischenspeichern ist bei der Arbeit mit Blender eine wichtige
Empfehlung. Je nach KomplexitÃ¤t des Projektes kann es manchmal
vorkommen, dass das Programm unerwartet abstÃ¼rzt und die Fortschritte
bis zum letzten Speicherpunkt verloren gehen. Aus diesem Grund empfiehlt
es sich, das Projekt lieber einmal zu viel als einmal zu wenig
abzuspeichern.

\marginnote{Kopie speichern}

Alternativ kann das Projekt auch unter Â«\emph{File} \textbar{}
\emph{Save}Â» abgespeichert werden. Nebst der MÃ¶glichkeit, dass ein
Projekt unter einem neuen Namen gespeichert und fortgefÃ¼hrt wird
(Â«\emph{File} \textbar{} \emph{Save} asÂ» bzw. \kbd{Ctrl} + \kbd{Shift} +
\kbd{S}), gibt es auch die MÃ¶glichkeit, mittels Â«\emph{File} \textbar{}
\emph{Save Copy}Â» (\kbd{Ctrl} + \kbd{Alt} + \kbd{S}) eine Backup-Version
abzuspeichern und in dem originalen File weiterzuarbeiten.

\marginnote{.blend-Files}

Die Projekte werden jeweils in Blenders programmeigenem Format
Â«\emph{.blend}Â» abgespeichert. Diese Datei enthÃ¤lt alle Objekte,
Animationen und Einstellungen des Projektes. Das .blend-Dateiformat kann
lediglich mit Blender geÃ¶ffnet werden. Wenn externe Dateien
(beispielsweise Texturen, Soundeffekte oder Videos) im Projekt
eingebunden werden, mÃ¼ssen diese ebenfalls mit dem Projekt weitergegeben
werden. Es gibt jedoch die MÃ¶glichkeit, unter Â«\emph{File} \textbar{}
\emph{External Data} \textbar{} \emph{Pack all into.blend}Â» alle diese
externen Dateien in das .blend-File einzuspeichern. Dadurch erhÃ¶ht sich
allerdings die GrÃ¶sse des abgespeicherten Files.

\marginnote{Exportieren}

Um Programme auch fÃ¼r andere Projekte verfÃ¼gbar zu machen, mÃ¼ssen sie in
einem anderen Dateiformat ausgegeben werden. Unter Â«\emph{File}
\textbar{} \emph{Export}Â» steht eine Reihe von verschiedenen
Dateiformaten zur VerfÃ¼gung, welche von unterschiedlichen Programmen
geÃ¶ffnet werden kÃ¶nnen. Die meisten dieser Dateiformate kann Blender
wiederum importieren und darstellen.

Merke\ldots{}

Lieber einmal mehr mit der Kombination \kbd{Ctrl} + \kbd{S}, speichern,
als die Fortschritte zu verlieren.

\chapter{Objektarten}\label{objektarten}

\marginnote{Verschiedene Arten von Objekten}

Beim HinzufÃ¼gen von Objekten mittels der Tastenkombination \kbd{Shift} +
\kbd{A} erscheint das MenÃ¼ fÃ¼r das HinzufÃ¼gen von Objekten beim
Mauszeiger. Die verschiedenen Objekte sind dabei in verschiedene Typen
von Objekten unterteilt. Diese Objekte unterscheiden sich hinsichtlich
ihres Aufbaus, aber auch hinsichtlich ihrer Funktion.

\section{Mesh}\label{mesh}

\marginnote{Meshes}

Ein Mesh stellt ein 3D-Objekt dar. Meshes haben eine gitterÃ¤hnliche
Struktur aus Punkten, Linien und verbundenen FlÃ¤chen, welche in ihrer
Gesamtstruktur das Objekt darstellen. Der Hauptfokus dieses Kurses wird
auf die Meshes gelegt, von daher werden sie spÃ¤ter noch ausfÃ¼hrlich
beschrieben.

\section{Curve}\label{curve}

\marginnote{Kurven}

Vor der Entwicklung der Meshes wurden in Computergrafiken Kurven und
OberflÃ¤chen verwendet. Sie haben den Vorteil, dass sie weniger
Computerleistung benÃ¶tigen. Kurven verfÃ¼gen Ã¼ber weniger Kontrollpunkte,
wodurch sie auch einfacher zu bearbeiten sind. In einigen Anwendungen
werden sie heute immer noch verwendet. Blender verfÃ¼gt Ã¼ber zwei Arten
von Kurven: BÃ©zier-Kurven und Nurbs-Kurven. Die beiden Arten von Kurven
unterscheiden sich hinsichtlich ihrer zugrundeliegenden Berechnungen.

\marginnote{Kurven kÃ¶nnen OberflÃ¤chen enthalten}

Neu hinzugefÃ¼gte Kurven beinhalten zunÃ¤chst keine OberflÃ¤che und
erscheinen dadurch nicht beim Rendern. Allerdings kÃ¶nnen ihnen
OberflÃ¤chen hinzugefÃ¼gt werden, sodass sie auch als Objekte erkennbar
werden. Zudem kÃ¶nnen Kurven auch als Hilfestellung bei Animationen
verwendet werden, indem etwa Pfade fÃ¼r eine Animation mit ihnen
vorgegeben werden.

\section{Surface}\label{surface}

\marginnote{Surfaces}

Die Surfaces sind Ã¤hnlich zu den Kurven. WÃ¤hrend Kurven 2D-Objekte
darstellen, sind die Surfaces ihre 3D-Erweiterungen. Obwohl Kurven und
Surfaces somit denselben Typ von Objekten darstellen, kÃ¶nnen sie nicht
gleichzeitig auftreten. In einem Objekt kÃ¶nnen somit nicht sowohl Kurven
als auch Surfaces vorhanden sein.

\section{Metaball}\label{metaball}

\marginnote{Metas}

MetabÃ¤lle gehÃ¶ren zur Objekt-Familie der Metas, welche Blender
prozedural aufbaut. Anders als beispielsweise Meshes oder Kurven sind
sie nicht durch Kontrollpunkte oder Gitternetze aufgebaut, sondern
werden mathematisch von Blender berechnet. Wenn zwei Meta-Objekte in der
NÃ¤he voneinander sind, kÃ¶nnen sie miteinander interagieren.

\section{Text}\label{text}

\marginnote{Text}

Text-Objekte beinhalten einen Text, der anschliessend als Objekt
dargestellt wird. Der Text hat dabei wie die Kurven oder die OberflÃ¤chen
lediglich zwei Dimensionen.

\section{Volume}\label{volume}

\marginnote{Volumen-Objekte}

Volumen-Objekte sind lediglich Objekt-Container. Ihnen kÃ¶nnen
OpenVDB-Dateien angehÃ¤ngt werden, um volumetrische Daten (beispielsweise
Wolken oder Rauch) zu erzeugen. Diese Dateien kÃ¶nnen mithilfe von
Blenders eigenen Simulationen erzeugt werden, oder in anderen Programmen
erzeugt und abgespeichert werden.

\section{Grease Pencil}\label{grease-pencil}

\marginnote{Grease Pencil}

Grease Pencils sind Objekte, welche es ermÃ¶glichen, direkt in den
dreidimensionalen Raum zu zeichnen. Zudem kÃ¶nnen mit ihnen
2D-Animationen erstellt werden -- etwa wenn Blender fÃ¼r ein 2D- statt
3D-Projekt verwendet wird. Objekte der Kategorie Â«Grease PencilÂ» sind
dabei eigentlich BehÃ¤lter-Objekte, in welche anschliessend die Linien
gezeichnet werden.

\section{Armature}\label{armature}

\marginnote{Armaturen}

Armaturen werden verwendet, um Meshes zu animieren. Hierbei wird
innerhalb eines Meshes ein GerÃ¼st erstellt, anhand dessen die Animation
anschliessend erfolgen soll. Dieses GerÃ¼st stellt sozusagen das Skelett
dar, welches anschliessend fÃ¼r die Animation verwendet werden soll.
Dementsprechend werden die einzelnen GerÃ¼stteile auch Bones (Knochen)
genannt. Armaturen werden beim Rendern nicht angezeigt. Bei ihnen
handelt es sich lediglich um ein Werkzeug zur Animation.

\section{Lattice}\label{lattice}

\marginnote{Lattice}

Das Lattice stellt ein dreidimensionales GerÃ¼st aus Punkten dar, welches
allerdings nicht gerendert werden kann. Es dient als Werkzeug zur
komplexeren Transformation von Objekten.

\section{Empty}\label{empty}

\marginnote{Empties}

Empties sind Knotenpunkte an einem einzigen Punkt in der virtuellen
Welt. Sie beinhalten weder OberflÃ¤chen noch Volumen und kÃ¶nnen auch
nicht gerendert werden. Sie lassen sich allerdings beispielsweise als
Bezugspunkte fÃ¼r Objekte verwenden.

\section{Image}\label{image}

\marginnote{Bilder}

Blender ermÃ¶glichet es, dass auch externe Bilddateien direkt einer Szene
hinzugefÃ¼gt werden kÃ¶nnen. HierfÃ¼r kann ein solches Image-Objekt
erstellt und das Bild anschliessend diesem Objekt angefÃ¼gt werden.
Bilder kÃ¶nnen allerdings auch direkt in den Viewport-Display gezogen
werden, wodurch sie anschliessend hinzugefÃ¼gt werden.

\section{Light}\label{light}

\marginnote{Lichtquellen}

Licht-Objekte stellen die Quelle fÃ¼r die Beleuchtung von Szenen dar. Sie
sind nicht als Mesh oder Kurve modellierbar, sondern stellen vielmehr
einen Punkt oder Bereich dar, von dem die Beleuchtung ausgeht.

\section{Light-Probe}\label{light-probe}

\marginnote{Light Probes}

Light Probes werden in der Eevee-Render-Engine als Hilfsobjekte
verwendet. Dabei werden beispielsweise Informationen Ã¼ber indirekte
Beleuchtungseffekte gespeichert. Diese Informationen werden
anschliessend im finalen Render berÃ¼cksichtigt, wÃ¤hrend das
Light-Probe-Objekt als solches nicht im finalen Render dargestellt wird.

\section{Camera}\label{camera}

\marginnote{Kamera}

Kameras stellen den Punkt dar, von dem aus die Welt in der gerenderten
Szene betrachtet wird. Die Kameras als solche sind in den gerenderten
Bildern nicht sichtbar.

\section{Speaker}\label{speaker}

\marginnote{Lautsprecher}

Speaker werden verwendet, um an bestimmten Positionen in der Szene TÃ¶ne
erklingen zu lassen. So wie die Lichtquellen sind die Speaker nicht
modellierbar, sondern stellen einen Punkt in der drei dimensionalen Welt
dar, von dessen Position ein Klang ausgeht.

\section{Force Field}\label{force-field}

\marginnote{Kraftfelder}

Force Fields sind Objekte, welche in Simulationen KrÃ¤fte auf andere
Objekte ausÃ¼ben kÃ¶nnen. So kÃ¶nnen andere Objekte beispielsweise
angezogen oder absorbiert werden. Beim Rendern sind diese Objekte als
solche nicht sichtbar, allerdings die Auswirkungen, welche deren KrÃ¤fte
auf Objekte haben kÃ¶nnen.

\section{Collection Instance}\label{collection-instance}

\marginnote{Collections}

Collections sind Einheiten, um Objekte anzuordnen und zu gruppieren. Sie
erscheinen nicht im Viewport, sind aber im Outliner aufzufinden. Sie
kÃ¶nnen wie Dateiordner verstanden werden.

\section{Zusammenfassung der
Objektarten}\label{zusammenfassung-der-objektarten}

\marginnote{Verschiedene Objektarten}

Die verschiedenen Objektarten dienen also entweder der Darstellung von
Objekten, der Darstellung von externen Dateien, der Darstellung der
Szene oder haben vor allem unterstÃ¼tzende Funktionen:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 12\tabcolsep) * \real{0.1429}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 12\tabcolsep) * \real{0.1429}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 12\tabcolsep) * \real{0.1429}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 12\tabcolsep) * \real{0.1429}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 12\tabcolsep) * \real{0.1429}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 12\tabcolsep) * \real{0.1429}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 12\tabcolsep) * \real{0.1429}}@{}}
\caption{Ãœbersicht Ã¼ber die verschiedenen Objektarten. Mit einem Stern
markierten Objektarten sind renderbare Objekte.}\tabularnewline
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Gitter-basiert*
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Kurven-basiert*
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Metas}*
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Linien*
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Szenen-Tools
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Externe Daten
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Hilfs-Werkzeuge
\end{minipage} \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Gitter-basiert*
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Kurven-basiert*
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Metas}*
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Linien*
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Szenen-Tools
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Externe Daten
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Hilfs-Werkzeuge
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Mesh & Curve & Metaball & Grease Pencil & Camera & Volume & Armature \\
& Surface & & & Light & Image & Lattice \\
& Text & & & Speaker & & Empty \\
& & & & & & Force Field \\
& & & & & & Speaker \\
& & & & & & Light Probe \\
& & & & & & Collection Instance \\
\end{longtable}

\chapter{Primitive Meshes}\label{primitive-meshes}

\marginnote{Primitives}

Wie bereits erwÃ¤hnt fokussiert sich dieser Kurs auf den Umgang mit
Meshes. In der Auswahl zum HinzufÃ¼gen werden verschiedene grundlegende
Formen von Meshes bereitgestellt. Diese grundlegenden Formen werden als
Primitives bezeichnet. Zu den Primitives gehÃ¶ren:

\begin{itemize}
\tightlist
\item
  Plane
\item
  Cube
\item
  Circle
\item
  UV Sphere
\item
  Ico Sphere
\item
  Cylinder
\item
  Cone
\item
  Torus
\item
  Grid
\item
  Monkey
\end{itemize}

\section{Plane}\label{plane}

\marginnote{FlÃ¤che}

Die Plane stellt das grundlegendste Primitive dar. Es handelt sich dabei
lediglich um eine einzelne FlÃ¤che, bestehend aus einer FlÃ¤che mit vier
Eckpunkten. Per Default hat die Plane eine DimensionalitÃ¤t von 2x2x0
Metern.

\section{Cube}\label{cube}

\marginnote{WÃ¼rfel}

Der Cube entspricht dem StandardwÃ¼rfel, den Blender bei der
Default-Szene anzeigt. Per Default hat der WÃ¼rfel eine DimensionalitÃ¤t
von 2x2x2 Metern.

\section{Circle}\label{circle}

\marginnote{Kreis}

Der Circle entspricht einem runden Kreis mit dem Radius von einem Meter,
wodurch er eine DimensionalitÃ¤t von 2x2x2 Metern innehat. Der Kreis
besteht lediglich aus mit Linien verbundenen Punkten, ohne eine innere
FlÃ¤che. Allerdings kann im Kontext-MenÃ¼ zum HinzufÃ¼gen des Kreises auch
eine FÃ¼llflÃ¤che erstellt werden.

\section{UV Sphere}\label{uv-sphere}

\marginnote{Kugel bestehend aus Vierecken}

Die UV-Sphere stellt eine Kugel dar, mit der DimensionalitÃ¤t von 2x2x2
Metern. Die Kugel besteht aus viereckigen FlÃ¤chen, wobei sie an den
Endpunkten der Z-Achse durch dreieckige FlÃ¤chen verbunden ist. Die
Anzahl der Segmente um die Kugel herum sowie die Anzahl Ringe lassen
sich im Kontext-MenÃ¼ beim Erstellen der Kugel einstellen. Die Segmente
beschreiben dabei die Anzahl Unterteilungen, welche ein Ring entlang der
XY-Achse der Kugel beinhaltet, wÃ¤hrend die Anzahl Ringe beschreibt, wie
oft die Kugel der Z-Achse entlang unterteilt werden soll.

\section{Ico Sphere}\label{ico-sphere}

\marginnote{Kugel bestehend aus Dreiecken}

Die Ico-Sphere stellt ebenfalls eine Kugel dar, allerdings mit den
Dimensionen 1.9x2x2 Meter. Anders als die UV-Sphere besteht sie nur aus
dreieckigen FlÃ¤chen. Dies hat den Vorteil, dass die Form der Faces Ã¼ber
die ganze Kugel hinweg etwa gleich bleibt. Im Kontext-MenÃ¼ zur
Erstellung der Ico Sphere kann mit der Anzahl Subdivisions eingestellt
werden, wie oft die Dreiecke dieser Kugel unterteilt werden sollen. Mit
zunehmenden Subdivisions nÃ¤hert sich die X-DimensionalitÃ¤t auch 2 Metern
an.

\section{Cylinder}\label{cylinder}

\marginnote{Zylinder}

Der Zylinder stellt zwei Kreise dar, welche durch FlÃ¤chen miteinander
verbunden sind. Seine DimensionalitÃ¤t entspricht 2x2x2 Metern mit einem
Radius der Kreise von 1 Meter. Im Kontext-MenÃ¼ zur Erstellung des
Zylinders lÃ¤sst sich die Anzahl Unterteilungen im Kreis einstellen.
Zudem lÃ¤sst sich hier analog zum Kreis einstellen, ob die KreisflÃ¤che
mit einer FÃ¼llflÃ¤che versehen werden soll und mit welcher Art von
FÃ¼llflÃ¤che.

\section{Cone}\label{cone}

\marginnote{Kegel}

Der Kegel stellt einen Spezialfall des Zylinders dar, bei dem die Radien
der beiden Enden variiert werden kÃ¶nnen und einer der beiden Kreise
einen Radius von 0 innehat. Auch hier kann wieder eingestellt werden,
wie viele Unterteilungen die Kreise innehaben sollen und wie die
KreisflÃ¤chen gestaltet werden sollen.

\section{Torus}\label{torus}

\marginnote{Torus}

Der Torus stellt eine ringfÃ¶rmige Gestalt dar, welche aus einer Major-
und einer Minor-Komponente besteht. Die Major-Komponente beschreibt
dabei den Kreis von der Vogelperspektive herab auf den Torus und die
Minor-Komponente den Kreis, welcher sich aus dem Querschnitt des Torus
ergibt. FÃ¼r beide Komponenten kann die Anzahl Unterteilungen Ã¼ber das
Segment-Feld im Kontext-MenÃ¼ eingegeben werden. Die DimensionalitÃ¤t kann
entweder hinsichtlich der Major- und Minor-Komponente festgelegt werden
oder alternativ als Radius des inneren und des Ã¤usseren Ringes.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_6/6_1_Major_Minor_Components_Torus.png}

\caption{\label{fig-1_1}Major- und Minor-Komponente des Torus.}

\end{figure}%

\section{Grid}\label{grid}

\marginnote{Gitternetz}

Das Grid stellt eine Alternative zur glatten FlÃ¤che dar, ist allerdings
bereits in weitere kleine viereckige FlÃ¤chen unterteilt. Im Kontext-MenÃ¼
lÃ¤sst sich anhand der Subdivisions eingeben, wie viele Unterteilungen
das Gitternetz entlang der X- und der Y-Achse haben soll. Die
DimensionalitÃ¤t des Grids ist analog zur Plane per Default 2x2x0 Meter.

\section{Monkey}\label{monkey}

\marginnote{Suzanne}

Bei der Auswahl des Monkeys generiert Blender das Modell eines
Affenkopfs. Dabei handelt es sich um Suzanne, das Maskottchen von
Blender.

\chapter{Methoden der
Objekt-Transformation}\label{methoden-der-objekt-transformation}

\section{Die drei grundlegenden
Objekt-Transformationen}\label{die-drei-grundlegenden-objekt-transformationen}

\marginnote{Grundlegende Transformationen}

Jegliche 3D-Meshes beinhalten drei grundlegende Eigenschaften. Diese
Grundeigenschaften kÃ¶nnen jederzeit variiert werden. Es handelt sich
dabei um:

\begin{itemize}
\tightlist
\item
  Position
\item
  Rotation
\item
  Skalierung
\end{itemize}

Alle drei Optionen sind in der Sidebar (ein /ausblenden mittels \kbd{N})
unter dem MenÃ¼ Â«\emph{Item}Â» unter dem Reiter Â«\emph{Transform}Â»
sichtbar. Die Eigenschaften beziehen sich jeweils auf das ausgewÃ¤hlte
Objekt. Wenn kein Objekt ausgewÃ¤hlt ist, beziehen sie sich auf das
zuletzt ausgewÃ¤hlte Objekt. Mittels der Einstellungen in der Sidebar
lassen sich diese drei Eigenschaften beliebig durch die Eingabe von
Zahlen variieren.

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Statt Zahlen kÃ¶nnen auch mathematische Berechnungen in die Felder eingegeben werden. Dadurch lassen sich komplexere Positionen ermitteln. Wenn etwa ein Objekt genau mittig zwischen einem Objekt mit einer Position von X = 4 und einem Objekt mit einer Position von X = 17 platziert werden soll, kann der X-Wert des zu platzierenden Objektes auf X = 4 + ((17 -- 4) / 2) festgelegt werden. Das Objekt wird anschliessend mittig der beiden Objekte (X = 10.5) platziert.
\end{tipp}

\section{Location}\label{location}

\marginnote{Position}

Die Location beschreibt die Position eines 3D-Meshes in der
dreidimensionalen Welt. Die Position wird mittels drei Werten angegeben:
einem Wert fÃ¼r die X-Achse, einem fÃ¼r die Y-Achse und einem fÃ¼r die
Z-Achse. Jeder dieser drei Werte lÃ¤sst sich individuell verÃ¤ndern. Durch
das Verschieben des X Wertes verschiebt sich das Objekt beispielsweise
der X-Achse entlang.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_7/7_1_Origin.png}

\caption{\label{fig-1_1}Der orangene Punkt markiert den Ursprung
(Origin) eines Objektes.}

\end{figure}%

\marginnote{Position befindet sich am Ursprung des Objekts}

Die genaue Position des Objektes wird anhand eines kleinen orangen
Punktes im Viewport-Display angezeigt. Bei diesem Punkt handelt es sich
um den Ursprung des Objektes (Origin). Die Position eines Objektes
bezieht sich immer auf diesen orangen Punkt, selbst wenn das Mesh selbst
diese Position gar nicht abdeckt.

\section{Rotation}\label{rotation}

\marginnote{Rotation}

Die Rotation eines Objektes beschreibt, wie sehr das Objekt entlang der
drei Achsen rotiert wird. Analog zur Position ist die Rotation ebenfalls
in die drei Achsen X, Y und Z aufgeteilt. Beispielsweise fÃ¼hrt eine
VerÃ¤nderung der Rotation beim Wert X dazu, dass das Objekt entsprechend
entlang der X-Achse rotiert wird. Durch die Verwendung aller drei Achsen
kÃ¶nnen so komplexe Rotationen erfolgen. Indem alle Werte erneut auf 0
gesetzt werden, befindet sich das Objekt wieder in seiner Grundposition.

\marginnote{Drehpunkt der Rotation}

Der Ursprung des Objektes stellt den Drehpunkt fÃ¼r die Rotation mittels
der Sidebar dar. Das heisst, die Objekte werden jeweils um den
Ursprungspunkt herumrotiert. Dies wird beispielsweise deutlich, wenn
sich der Ursprungspunkt ausserhalb des Objektes befindet.

\section{Scale}\label{scale}

\marginnote{Skalierung}

Die Skalierung eines Objekts beschreibt, wie stark ein Objekt
vergrÃ¶ssert oder verkleinert wird. Diese Objekteigenschaft lÃ¤sst sich
ebenfalls individuell fÃ¼r alle drei Achsen einstellen. So kann ein
Objekt entlang der X-Achse vergrÃ¶ssert werden, indem der dazugehÃ¶rige
X-Wert auf einen Wert Ã¼ber 1 festgelegt wird. Werte im Bereich von
grÃ¶sser als 0 und kleiner als 1 fÃ¼hren zu einer Verkleinerung des
Objektes entlang der entsprechenden Achse. Ein Wert von 0 fÃ¼hrt dazu,
dass das Objekt entlang der entsprechenden Achse keine GrÃ¶sse mehr hat
und aus der entsprechenden Perspektive dem entsprechend nicht mehr
sichtbar ist.

\marginnote{Bezugspunkt der Skalierung}

Analog zu der Position und der Rotation bezieht sich die Skalierung
ebenfalls auf den Ursprung des Objektes. Wenn sich das Mesh ausserhalb
des Ursprungs befindet, fÃ¼hrt dies dazu, dass auch der Leerraum zwischen
dem Mesh und dem Ursprung entsprechend skaliert wird. Befindet sich die
Grenze eines Objektes etwa um den Wert 1 vom Ursprung entfernt, fÃ¼hrt
eine Skalierung um den Wert 2 dazu, dass das Mesh selbst verdoppelt wird
-- allerdings wird die Distanz zum Ursprung des Objektes ebenfalls
verdoppelt.

\section{Dimension}\label{dimension}

\marginnote{Dimensionen von Objekten}

Unterhalb des Eingabefeldes fÃ¼r die Skalierung befindet sich ein
weiteres Feld, welches die Dimensionen eines 3D-Meshes basierend auf den
drei Achsen angibt. Die Dimensionen des Objektes sind direkt mit der
Skalierung des Objektes verbunden. Eine VerÃ¤nderung der
X-Achsen-Dimension fÃ¼hrt dazu, dass die Skalierung anhand der X-Achse so
angepasst wird, dass sie der eingegebenen GrÃ¶sse des Objektes
entsprechen. Dadurch kann etwa direkt bestimmt werden, dass ein Objekt
entlang der verschiedenen Achsen eine bestimmte GrÃ¶sse innehat, ohne
dass die Skalierung der entsprechenden GrÃ¶sse angepasst wird.

\section{Transformationen sperren}\label{transformationen-sperren}

\marginnote{Transformationen sperren}

Neben den Werten fÃ¼r die Position, Rotation und Skalierung befinden sich
drei aufgeschlossene SchlÃ¶sser. Durch das Anklicken dieser SchlÃ¶sser
lÃ¤sst sich die dazugehÃ¶rige Eigenschaft auf einer Achse sperren, sodass
sie nicht mehr verÃ¤ndert werden kann. Das entsprechende Symbol verÃ¤ndert
sich dadurch zu einem geschlossenen Schloss.

\marginnote{Sperrung gilt nur fÃ¼r Viewport-Display}

Die Werte links neben dem Schloss lassen sich allerdings immer noch
verÃ¤ndern, was kontraintuitiv wirken mag. Dies liegt daran, dass sich
diese Sperrung auf VerÃ¤nderungen mittels des Viewport Displays bezieht,
welche nun als NÃ¤chstes betrachtet werden.

Ãœbung 3: Verwendung der Sidebar

\textbf{Ãœbung 3.1}

Versuchen Sie den StandardwÃ¼rfel so zu skalieren, dass er entsprechend
der Abbildung einen in die HÃ¶he ragenden Quader darstellt.

\includegraphics{Chapters/Images/Chapter_7/Exercise_3_1.png}

\textbf{Ãœbung 3.2}

Versuchen Sie den StandardwÃ¼rfel so zu verÃ¤ndern, dass er aus der
orthogonalen (Taste \kbd{5} ) Vorder/RÃ¼ck-Ansicht (Taste \kbd{1} ) nicht
mehr sichtbar ist.

Merke\ldots{}

Die drei Transformationen Location, Rotation und Scale aus der Sidebar
beziehen sich alle drei jeweils auf den Ursprung des Objektes.

Dimension des Objektes hÃ¤ngt mit dessen Skalierung zusammen.

\chapter{Objekte im Viewport-Display
transformieren}\label{objekte-im-viewport-display-transformieren}

\marginnote{Befehle fÃ¼r Transformationen}

Statt mit der Sidebar kÃ¶nnen Objekte auch direkt im 3D-Viewport-Display
transformiert werden. Sobald ein Objekt -- oder auch mehrere Objekte --
ausgewÃ¤hlt sind, lassen sich die Objekte direkt im Viewport mittels der
folgenden Befehle transformieren:

\begin{itemize}
\tightlist
\item
  Position: \kbd{G} (Â«GrabÂ»)
\item
  Rotation: \kbd{R}
\item
  Skalierung: \kbd{S}
\end{itemize}

\section{Position}\label{position}

\marginnote{Objekte bewegen mittels \kbd{G}}

Durch das DrÃ¼cken der Taste \kbd{G} lÃ¤sst sich ein ausgewÃ¤hltes Objekt
mit der Maus im Raum verschieben. Blender aktualisiert parallel die
Position des Objektes in der Sidebar, sodass diese klar nachvollziehbar
ist.

\marginnote{Bewegung entlang einer Achse}

Es ist auch im Viewport mÃ¶glich, ein Objekt nur entlang einer Achse zu
bewegen. HierfÃ¼r wird nach dem DrÃ¼cken der Taste \kbd{G} die Taste fÃ¼r
die entsprechende Achse festgelegt (\kbd{X},\kbd{Y} oder \kbd{Z}). Der
farbige Strich im Viewport-Display, welcher die entsprechende Achse
markiert, leuchtet dadurch heller auf. Wenn die Maus nun bewegt wird,
bewegt sich das Objekt lediglich entlang dieser Achse. Um die Bewegung
zu beenden oder zu bestÃ¤tigen, wird entweder die linke Maustaste oder
die \kbd{Enter}-Taste gedrÃ¼ckt. Um die Transformation abzubrechen, kann
die rechte Maustaste oder die \kbd{esc}-Taste gedrÃ¼ckt werden. Das
Objekt wird dadurch wieder in seine Ursprungsposition zurÃ¼ckgestellt.

\marginnote{Bewegung entlang einer Achse sperren}

Es ist auch mÃ¶glich, zwei Achsen gleichzeitig fÃ¼r eine Bewegung
auszuwÃ¤hlen. Dabei wird die Bewegung entlang einer Achse gesperrt,
sodass nur die beiden anderen Achsen fÃ¼r eine Bewegung freigegeben
werden. HierfÃ¼r wird die Taste \kbd{Shift}in Kombination mit der Taste
fÃ¼r die zu sperrende Achse (\kbd{X},\kbd{y} oder \kbd{Z}) gedrÃ¼ckt. Wenn
ein Objekt also lediglich entlang der X- und Y-Achse bewegt werden soll,
aber die Z-Achse nicht verÃ¤ndert werden soll, kann nach dem DrÃ¼cken der
Taste \kbd{G} bei gedrÃ¼ckter \kbd{Shift}-Taste die Z-Achse mittels der
Taste \kbd{Z} gesperrt werden.

\marginnote{Bewegung mittels Zahlen prÃ¤zise angeben}

Statt mit der Maus kann wÃ¤hrend des Bewegungsvorgangs eine Zahl
eingegeben werden, um eine Bewegung zu quantifizieren. Soll ein Objekt
etwa um 2 Meter entlang der X-Achse verschoben werden, so wird, nachdem
die Bewegung mittels der Taste \kbd{G} gestartet und mittels der Taste
\kbd{X} auf die X-Achse festgelegt wird, die Taste \kbd{2} gedrÃ¼ckt, um
die Bewegung auf 2 Meter festzulegen. Durch das gleichzeitige DrÃ¼cken
der Taste \kbd{-} kÃ¶nnen auch negative Werte eingegeben werden, sodass
die Bewegung in die entgegengesetzte Richtung geschieht. In der linken
oberen Ecke des Viewport Displays wird jeweils die entsprechende Zahl
angezeigt. Es ist zudem mÃ¶glich, Zahlenangaben mit Dezimalstellen fÃ¼r
Bewegungen einzugeben.

\section{Rotation}\label{rotation-1}

\marginnote{Objekte rotieren mittels \kbd{R}}

Um ein ausgewÃ¤hltes Objekt mit der Maus zu rotieren, wird die Taste
\kbd{R} gedrÃ¼ckt. Wie auch bei der Bewegung lÃ¤sst sich eine
Transformation entlang einer Achse ansteuern, indem die Taste fÃ¼r die
entsprechende Achse gedrÃ¼ckt wird (\kbd{X},\kbd{Y} oder \kbd{Z}). Ebenso
lÃ¤sst sich eine Achse fÃ¼r die Rotation sperren, indem die entsprechende
Taste fÃ¼r diese Achse bei gedrÃ¼ckter \kbd{Shift}-Taste gedrÃ¼ckt wird.
Wenn nun also ein Objekt entlang der Z-Achse rotiert werden soll, wird
zunÃ¤chst das entsprechende Objekt ausgewÃ¤hlt und anschliessend die Taste
\kbd{R}fÃ¼r den Befehl der Rotation gedrÃ¼ckt. Indem die Taste \kbd{R}
anschliessend gedrÃ¼ckt wird, lÃ¤sst sich das Objekt nun lediglich entlang
der Z-Achse rotieren. WÃ¤hrend der Rotation verÃ¤ndert sich die Form der
Maus und sie ist mit einem Strich zu dem Punkt, um den die Rotation
erfolgt, verbunden. In der Regel handelt es sich dabei um den Ursprung
des Objektes. Allerdings kann die Rotation im Viewport-Display auch
hinsichtlich anderer Punkte im Raum erfolgen -- dies wird in einem
spÃ¤teren Kapitel ausfÃ¼hrlicher beschrieben.

\marginnote{PrÃ¤zise Rotation mittels Zahlen}

Auch wÃ¤hrend der Rotation kann mit der Eingabe von Zahlen gearbeitet
werden. Um ein Objekt beispielsweise um 45 Grad entlang der Z-Achse zu
drehen, wird nach dem Start der Rotation mittels der Taste \kbd{R} und
der Festlegung der Z-Achse mit der Taste \kbd{Z} die Zahl 45 mittels der
Tasten \kbd{4} \kbd{5} eingegeben. Auch hier lÃ¤sst sich die Richtung
umkehren, indem die Taste \kbd{-} gedrÃ¼ckt wird.

\section{Scale}\label{scale-1}

\marginnote{Objekte Skalieren mittels \kbd{S}}

Um ein ausgewÃ¤hltes Objekt mit der Maus zu skalieren, wird die Taste
\kbd{S} gedrÃ¼ckt. Wie auch bei der Bewegung und der Rotation lÃ¤sst sich
eine Transformation entlang einer einzelnen Achse ansteuern, indem die
Taste fÃ¼r die entsprechende Achse gedrÃ¼ckt wird (\kbd{X},\kbd{Y} oder
\kbd{Z}). Ebenso lÃ¤sst sich eine Achse fÃ¼r die Rotation sperren, indem
die entsprechende Taste fÃ¼r diese Achse bei gedrÃ¼ckter \kbd{Shift}-Taste
gedrÃ¼ckt wird.

\marginnote{Skalierung entlang einer Achse}

Um ein Objekt nur entlang der X-Achse zu vergrÃ¶ssern oder zu
verkleinern, wird nach der Auswahl des Objektes die Taste \kbd{S}
gedrÃ¼ckt, um mit der Skalierung zu starten. Anschliessend kann durch das
DrÃ¼cken der Taste \kbd{X} festgelegt werden, dass die Transformation
lediglich entlang der X-Achse vollzogen werden soll. WÃ¤hrend der
Skalierung verÃ¤ndert sich der Mauszeiger ebenfalls. Zudem ist er mittels
eines Striches mit dem Punkt verbunden, zudem hin sich die Skalierung
orientiert. Wird die Maus nÃ¤her zu diesem Punkt bewegt, verkleinert sich
das Objekt. Wenn die Maus von diesem Punkt weiter entfernt wird,
vergrÃ¶ssert sich das Objekt.

\marginnote{PrÃ¤zise Skalierung mittels Zahlen}

Die Skalierung kann mittels Zahleneingaben ebenfalls sehr genau
vorgenommen werden. Um ein Objekt etwa in seiner GrÃ¶sse zu verdoppeln,
kann nach dem Start der Transformation mittels der Taste \kbd{S} die
Zahl \kbd{2}eingegeben werden. Dadurch wird das Objekt um den Faktor 2
vergrÃ¶ssert. Auch hier lÃ¤sst sich ein negativer Wert mittels der Taste
\kbd{-} festlegen. Dies fÃ¼hrt dazu, dass das Objekt durch seinen
Bezugspunkt hindurch in die andere Richtung skaliert und gespiegelt
wird. WÃ¤hrend dies bei symmetrischen Objekten zu keinem bemerkbaren
Unterschied fÃ¼hrt, wird der Effekt bei asymmetrischen Objekten deutlich.

Ãœbung 4 : Objekttransformationen

\textbf{Ãœbung 4.1}

Skalieren Sie einen WÃ¼rfel entlang der X-Achse auf seine halbe GrÃ¶sse.

\textbf{Ãœbung 4.2}

Bilden Sie das unten abgebildete Objekt nach.

\includegraphics{Chapters/Images/Chapter_8/Exercise_4_2.png}

Merke\ldots{}

Mittels der Tasten \kbd{G},\kbd{R} und \kbd{S} lassen sich Objekte auch
im Viewport-Display bewegen, rotieren und skalieren.

Mittels der Eingabe von Zahlen kÃ¶nnen Bewegungen, Rotationen und
Skalierungen genau vorgenommen werden.

Mittels der Tasten \kbd{X},\kbd{Y} und \kbd{Z} kÃ¶nnen Transformationen
auf der eine Achse festgelegt werden.

Mittels der Tasten \kbd{X},\kbd{Y} und \kbd{Z} bei gedrÃ¼ckter
\kbd{Shift}-Taste kÃ¶nnen Transformationen auf der entsprechenden Achse
unterbunden werden.

\chapter{Object- und Edit-Mode}\label{object--und-edit-mode}

\section{Die verschiedenen
Bearbeitungs-Modi}\label{die-verschiedenen-bearbeitungs-modi}

\marginnote{Object-Mode}

Die bisherigen Transformationen, die an Objekten gemacht wurden, haben
sich immer auf den Object-Mode bezogen. Dabei wurden grundlegende
Eigenschaften von Objekten (Position, Rotation und Skalierung)
verÃ¤ndert. Die Form des Objektes selbst wurde dabei nicht verÃ¤ndert,
sondern lediglich seine Darstellungsweise. Durch das ZurÃ¼cksetzen der
Werte in der Sidebar erscheint das Objekt wieder in seiner
ursprÃ¼nglichen Form.

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Das ZurÃ¼cksetzen der Transformationen kann direkt mittels folgenden Shortcuts erfolgen:  ZurÃ¼cksetzen der Position: \kbd{Alt} + \kbd{G}  ZurÃ¼cksetzen der Rotation: \kbd{Alt} + \kbd{R}  ZurÃ¼cksetzen der Skalierung: \kbd{Alt} + \kbd{S}
\end{tipp}

Durch die bisherigen Transformationen wurde das Objekt als Ganzes
bearbeitet. Dies zeichnet die Transformationen im Object-Mode aus. Nebst
dem Object-Mode gibt es noch eine Reihe anderer Modi. In der oberen
linken Ecke des Viewports ist jeweils ersichtlich, welcher Modus gerade
verwendet wird. Durch einen Klick auf das Dropdown-MenÃ¼ erscheint eine
Liste der verfÃ¼gbaren Modi:

\marginnote{Die verschiedenen Bearbeitungs-Modi}

\begin{itemize}
\item
  \textbf{Object Mode}: In diesem Modus kÃ¶nnen die Objekte in einer
  Szene als Ganzes transformiert und angeordnet werden.
\item
  \textbf{Edit Mode}: In diesem Modus kÃ¶nnen die einzelnen Bestandteile
  des Objekts anvisiert und bearbeitet werden.
\item
  \textbf{Sculpt Mode}: In diesem Modus kann das Objekt anhand von
  Sculpting-Tools bearbeitet werden.
\item
  \textbf{Vertex Paint}: In diesem Modus werden einzelne Punkte des
  Objekts angesteuert und mit Attributen versehen.
\item
  \textbf{Weight Paint}: In diesem Modus werden dem Objekt verschiedene
  Gewichte aufgemalt, welche anschliessend fÃ¼r weitere Funktionen
  verwendet werden kÃ¶nnen.
\item
  \textbf{Texture Paint}: In diesem Modus ist es mÃ¶glich, ein Objekt mit
  einer Textur zu bemalen.
\end{itemize}

\marginnote{Wechsel zwischen Object- und Edit-Mode}

Im Rahmen dieses Kurses wird vorwiegend mit dem Object- und dem
Edit-Mode gearbeitet. Der Wechsel zwischen diesen beiden Modi stellt
einen wichtigen Wechsel zwischen den Modi dar. Deshalb ist es mÃ¶glich,
mittels einer einzigen Taste zwischen dem Object- und dem Edit-Mode hin-
und herzuwechseln -- nÃ¤mlich mittels der Taste \kbd{Tab} . Dabei wird in
den Edit-Mode fÃ¼r das aktuell ausgewÃ¤hlte Objekt gewechselt. FÃ¼r
Objekte, welche nicht aus einzelnen Komponenten bestehen (beispielsweise
Kameras oder Lichtquellen), ist kein Edit-Mode verfÃ¼gbar.

\section{Struktur von 3D-Meshes}\label{struktur-von-3d-meshes}

\marginnote{Der Gitteraufbau von 3D-Meshes}

Beim Wechseln in den Edit-Mode erscheint das Mesh in seiner Struktur,
bestehend aus mehreren Polygonen. Dabei handelt es sich um einzelne
OberflÃ¤chenstrukturen der Meshes. Die Polygone -- und somit auch das
Mesh -- bestehen in ihrer Struktur aus folgenden Elementen:

\begin{itemize}
\tightlist
\item
  \textbf{Vertices}: Einzelne Punkte in einem Mesh
\item
  \textbf{Edges}: Linien zwischen zwei Vertices in einem Mesh
\item
  \textbf{Faces}: FlÃ¤chen zwischen mehreren Edges/Vertices in einem Mesh
\end{itemize}

\begin{figure}[H]

{\centering \includegraphics{Chapters/Images/Chapter_9/9_1_Vertices_Edges_Faces.png}

}

\caption{Vertices, Edges und Faces.}

\end{figure}%

\marginnote{Select-Modus wechseln}

Im Edit-Mode kÃ¶nnen wahlweise Vertices, Edges oder Faces ausgewÃ¤hlt
werden, je nachdem in welchem Select-Modus man sich befindet. Die drei
Select-Modi sind in der linken oberen Ecke direkt neben dem Auswahlfeld
fÃ¼r den Bearbeitungs-Modus (in dem Fall der Edit-Mode) aufzufinden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_9/9_2_ Select_Mode_Choice.png}

\caption{\label{fig-1_2}SchaltflÃ¤che fÃ¼r den Vertex-, Edge- und
Face-Select-Modus in der linken oberen Ecke des Edit-Modes.}

\end{figure}%

\subsection{Vertices}\label{vertices}

\marginnote{Vertices}

Ein Vertex (Mehrzahl: Vertices) stellt die grundlegendste Einheit in
einem Mesh dar. Jeder Vertex beschreibt einen Punkt in einem Mesh.
Anders als die Objekte als Ganzes, verfÃ¼gen Vertices nur Ã¼ber das
Merkmal ihrer jeweiligen Position. Die Merkmale Skalierung und Rotation
gibt es fÃ¼r Vertices nicht. Ein Vertex hat deshalb auch keine
Dimensionen.

\marginnote{Auswahl von Vertices}

Werden zwei miteinander verbundene Vertices ausgewÃ¤hlt, so wird
automatisch auch das dazwischenliegende Edge ausgewÃ¤hlt. Ebenso wird
automatisch das dazugehÃ¶rige Face mit ausgewÃ¤hlt, wenn alle Vertices
dieses Faces ausgewÃ¤hlt werden. Ein einzelner Vertex kann lediglich im
Vertex Select-Modus angewÃ¤hlt werden.

\subsection{Edges}\label{edges}

\marginnote{Edges}

Edges beschreiben Linien, welche zwischen zwei Vertices liegen. Da ein
Edge genau der Verbindung zwischen zwei Vertices entspricht, ist dessen
Mittelpunkt identisch zur Mitte zwischen den beiden Vertices.

\marginnote{Auswahl von Edges}

Im Edge-Select-Modus kÃ¶nnen die Edges als solche ausgewÃ¤hlt werden.
Dabei werden automatisch auch die beiden zum Edge dazugehÃ¶rigen Vertices
ausgewÃ¤hlt. Wenn alle Edges eines Faces ausgewÃ¤hlt werden, dann wird
automatisch auch das dazugehÃ¶rige Face ausgewÃ¤hlt.

\subsection{Faces}\label{faces}

\marginnote{Faces}

Faces stellen die FlÃ¤chen zwischen verbundenen Edges/Vertices dar. Die
Position des Faces entspricht dem Mittelpunkt dieser FlÃ¤che und somit
dem Mittelpunkt der dazugehÃ¶rigen Vertices. Es ist allerdings auch
mÃ¶glich, dass mehrere Vertices mittels Edges verbunden sind, ohne eine
FlÃ¤che zu beinhalten.

Mittels des Face-Select-Modus kÃ¶nnen Faces direkt angewÃ¤hlt werden.
Alternativ kann ein Face auch angewÃ¤hlt werden, indem im
Vertex-Select-Modus alle zum Face dazugehÃ¶rigen Vertices ausgewÃ¤hlt
werden, oder indem im Edge-Select-Modus alle zum Face dazugehÃ¶rigen
Edges ausgewÃ¤hlt werden.

\section{Anzahl Vertices in einem
Face}\label{anzahl-vertices-in-einem-face}

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Polygone und Faces sind in ihrer Bedeutung praktisch deckungsgleich. Faces beschreiben jedoch eher die FlÃ¤che eines Polygons, wÃ¤hrend das Polygon eher die Gesamtheit von Vertices, Edges und Faces beschreibt. Der Begriff Polygon wird innerhalb von Blender allerdings selten verwendet.
\end{tipp}

\marginnote{Anzahl Vertices in einem Face}

Der Default-Cube, den Blender jeweils beim Start eines neuen Projektes
zur VerfÃ¼gung stellt, besteht aus sechs Faces. Jedes dieser Faces
beinhaltet vier Vertices. Es ist allerdings auch mÃ¶glich, dass ein Face
aus mehr oder weniger Vertices besteht. Es gibt verschiedene Begriffe,
basierend auf der Anzahl Vertices in einem Face:

\marginnote{Bezeichnung von Faces aufgrund Anzahl Vertices}

\begin{itemize}
\tightlist
\item
  \textbf{Triangles} (\textbf{Tris}): Faces, die aus drei Vertices
  bestehen
\item
  \textbf{Quadrangles} (\textbf{Quads}): Faces, die aus vier Vertices
  bestehen
\item
  \textbf{N-Gons}: Faces, die aus n Vertices bestehen
\end{itemize}

\begin{figure}

\includegraphics{Chapters/Images/Chapter_9/9_3_Cube_ Tris.png}

\caption{\label{fig-1_3}Der StandardwÃ¼rfel bestehend aus Tris statt aus
Quads.}

\end{figure}%

\marginnote{Tris aus Quads ableiten}

Aus Quads lassen sich sehr einfach Tris bilden. HierfÃ¼r muss lediglich
jedes Quad zwischen zwei gegenÃ¼berliegenden Vertices zerschnitten
werden, sodass die FlÃ¤che in zwei Dreiecke unterteilt wird. Beim Rendern
von Bildern werden Quads in den 3D-Objekten automatisch in Tris
unterteilt, was im Normalfall fÃ¼r den Benutzer jedoch kaum ersichtlich
ist.

\marginnote{Bevorzugung von Quads}

Trotzdem ist es sinnvoll, sich beim Modellieren von 3D-Objekten eher an
die Verwendung von Quads zu gewÃ¶hnen. Viele Tricks und Kniffe der
Objektbearbeitung lassen sich einfacher oder teilweise sogar nur auf
Quads anwenden. Somit erleichtert die Arbeit mit Quads den
Arbeitsprozess erheblich. Weiterhin sind Quads auch in vielen
Animationsstudios der Standard.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_9/9_4_Prof_Figures.png}

\caption{\label{fig-1_4}Links eine gerenderte 3D-Figur und rechts die
Figur in ihrer Gitterstruktur.}

\end{figure}%

\marginnote{Anwendung von Tris}

Arbeiten mit Tris ist trotzdem durchaus mÃ¶glich und vereinzelte Tris in
Objekten sind auch nicht problematisch. In manchen Situationen sind Tris
sogar flexibler als Quads. Wenn allerdings die Objekte komplett aus Tris
bestehen sollen, macht dies gerade in gemeinschaftlichen Prozessen nur
Sinn, wenn alle beteiligten Personen mit Tris umgehen kÃ¶nnen.

Merke\ldots{}

Vertices beschreiben die einzelnen Punkte in einem 3D-Objekt.

Edges beschreiben die verbundenen Punkte in einem 3D-Objekt.

Faces beschreiben FlÃ¤chen zwischen mehr als zwei verbundenen Vertices.

Faces mit vier Vertices (Quads) sind gegenÃ¼ber Faces mit drei Vertices
(Tris) in den meisten FÃ¤llen zu bevorzugen.

\section{Auswahl von Vertices, Edges und Faces im
Edit-Mode}\label{auswahl-von-vertices-edges-und-faces-im-edit-mode}

\marginnote{Auswahl von Vertices, Edges und Faces im Edit-Mode}

AbhÃ¤ngig davon, welcher Select-Modus gerade aktiviert ist, lassen sich
entweder die Vertices, Edges oder Faces auswÃ¤hlen. Die Auswahl der
jeweiligen Elemente geschieht mittels der linken Maustaste. Wie auch im
Object-Mode kÃ¶nnen bei gedrÃ¼ckter \kbd{Shift}-Taste zusÃ¤tzliche Elemente
ausgewÃ¤hlt werden. Ebenso kÃ¶nnen mit der Taste \kbd{C} der
Circle-Select-Modus und mittels der Taste \kbd{B} der Box-Select-Modus
verwendet werden. Zudem kann mit der Tastenkombination \kbd{Ctrl} +
\kbd{I} die Auswahl umgekehrt werden.

\marginnote{Select linked mittels \kbd{L}}

Im Edit-Mode gibt es weitere Auswahl-Optionen. Wenn sich der Mauszeiger
Ã¼ber einem Element eines Objekts befindet, kÃ¶nnen mit der Taste \kbd{L}
alle Elemente, welche Ã¼ber Edges damit verbunden sind, ausgewÃ¤hlt
werden. Dies ermÃ¶glicht es, alle verbundenen Elemente auszuwÃ¤hlen. Um
alle Elemente eines Objektes -- also auch unverbundene Elemente --
auszuwÃ¤hlen, kann die Taste \kbd{A} gedrÃ¼ckt werden.

\marginnote{Edge-Loop-Select bei gedrÃ¼ckter Taste \kbd{Alt}}

Weiterhin lassen sich ganze Verbindungen von Edges auswÃ¤hlen, wenn die
Taste \kbd{Alt} wÃ¤hrend der Auswahl gedrÃ¼ckt wird. Dadurch werden alle
Edges, die gemeinsam eine Linie mit dem gerade ausgewÃ¤hlten Element
bilden, ausgewÃ¤hlt. Dies ist auch im Vertex-Select-Modus mÃ¶glich. Im
Face-Select-Modus werden alle Faces, die gemeinsam eine Linie bilden,
ausgewÃ¤hlt (hierfÃ¼r muss der Mausklick allerdings bei einem Edge
erfolgen -- nicht in der FlÃ¤che des Faces).

\section{Das Innere des Objekts}\label{das-innere-des-objekts}

\marginnote{Virtuelle Objekte haben meist keine FÃ¼llung}

So wie auch in der realen Welt haben virtuelle 3D-Objekte FlÃ¤chen,
welche aus mindestens drei Kanten bestehen und mindestens drei Ecken. Im
Gegensatz zu Objekten in der realen Welt bestehen virtuelle Objekte
nicht aus einer FÃ¼llung. Wird ein realer Apfel mit einem Messer in der
Mitte geteilt, so wird der Inhalt unter der Schale -- etwa das
Fruchtfleisch oder das KerngehÃ¤use -- sichtbar. Bei einem 3D-Mesh gibt
es jedoch kein Inneres, sodass lediglich die OberflÃ¤chen der Ã¤usseren
Struktur von der anderen Seite aus ersichtlich werden. Das Mesh besteht
somit nur aus der OberflÃ¤che, welche ein leeres Volumen Ã¼berdeckt.

Aus dem Umgang mit realen Objekten ist der Mensch sich gewohnt, dass
Objekte einen Inhalt haben. Dies trifft auf digitale Objekte selten zu.
Als Betrachter von digitalen Objekten ist dieser Sachverhalt nur in den
seltensten FÃ¤llen bemerkbar. Dadurch wird durch fehlende
Auseinandersetzung mit dieser Thematik die Illusion eines mÃ¶glichen
Inhaltes verstÃ¤rkt.

\marginnote{Wenn das Innere sichtbar wird}

In Videospielen kann es vorkommen, dass die Kamera durch einen Fehler in
ein Objekt hineingelangt. Dadurch wird das Objekt anschliessend von der
Innenseite aus betrachtet. Dies muss allerdings nicht immer der Fall
sein. In manchen Situationen ist dieses Objekt gar nicht mehr sichtbar,
wenn es von innen betrachtet wird.

\section{Normalen: die richtige Seite der Faces
finden}\label{normalen-die-richtige-seite-der-faces-finden}

\marginnote{Die zwei Seiten von Faces}

Da 3D-Meshes keinen inneren Hohlraum haben, bilden die Faces die
OberflÃ¤che, welche das Objekt abdeckt. Dies bedeutet aber auch, dass es
zwei Seiten von dieser OberflÃ¤che geben muss: eine Seite, die betrachtet
werden soll, und eine, die nicht betrachtet werden soll. In den meisten
FÃ¤llen ist schnell klar, welche Seite eines Objektes von Bedeutung ist.
Einen Apfel betrachtet man jeweils von aussen, also ist die nach aussen
gerichtete Seite jene Seite, welche betrachtet werden soll. Ebenso
verhÃ¤lt es sich bei einem Charakter. In diesem Fall ist ebenfalls die
nach aussen gerichtete Seite von Bedeutung und nicht das Innere seines
KÃ¶rpers.

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Bei bestimmten Einstellungen werden die RÃ¼ckseiten der OberflÃ¤chen von Objekten fehlerhaft dargestellt. In diesen FÃ¤llen hilft es oftmals, die Ausrichtung der Normalen zu Ã¼berprÃ¼fen und bei Bedarf anzupassen.  In manchen Game-Engines werden die RÃ¼ckseiten von Objekten in den Grundeinstellungen gar nicht angezeigt. Dadurch blickt man bei den OberflÃ¤chen mit der falschen Ausrichtung durch das Objekt hindurch. Dies vermittelt den Eindruck, dass ein Teil des Objekts fehlen wÃ¼rde. Dieser Teil ist noch da â€“ allerdings der falschen Richtung zugewendet.
\end{tipp}

\marginnote{Die zu betrachtende Seite eines WÃ¼rfels}

Wie verhÃ¤lt es sich bei Blenders StandardwÃ¼rfel? Bei diesem wird
zunÃ¤chst die Aussenseite betrachtet. Allerdings wÃ¤re es auch mÃ¶glich,
dass der Default-Cube von innen betrachtet werden soll -- etwa, wenn
eine Szene im Inneren eines Raumes dargestellt werden soll und der
WÃ¼rfel die WÃ¤nde, den Boden und die Decke des Raumes darstellt. In
diesem Fall ist nicht mehr die Aussenseite des WÃ¼rfels relevant, sondern
die Innenseite.

\marginnote{Normalen}

Die Normalen eines Objektes geben jeweils an, in welche Richtung
Vertices, Edges und Faces gerichtet sind. Wenn ein WÃ¼rfel etwa von innen
betrachtet werden soll, mÃ¼ssen die Normalen nach innen gekehrt werden.
Wenn der WÃ¼rfel allerdings als solcher von aussen betrachtet werden
soll, dann mÃ¼ssen die Normalen nach aussen gekehrt sein.

\marginnote{Normalen darstellen}

Die Normalen eines 3D-Objektes lassen sich im Edit-Mode betrachten,
indem die entsprechende Ansicht aktiviert wird. Diese wird im
Dropdown-MenÃ¼ zu den Viewport-Overlays in der rechten oberen Ecke des
3D-Viewports unter dem Abschnitt Â«\emph{Normals}Â» mit der SchaltflÃ¤che
Â«\emph{Display Normals}Â» aktiviert. Anschliessend erscheinen in den
Faces kleine blaue Striche, welche in diejenige Richtung zeigen, gegen
die das Face dargestellt ist.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_9/9_5_Icon_Normals.png}

\caption{\label{fig-1_5}Icon zur Darstellung der Normalen in den
Viewport-Overlays.}

\end{figure}%

\marginnote{Face-Orientation darstellen}

Es ist auch mÃ¶glich, in den Viewport-Overlays die Â«\emph{Face
Orientation}Â» zu aktivieren. Dadurch werden die OberflÃ¤chen eines
Objekts in blauer Farbe dargestellt, wenn es sich um die Seite der
Normalen handelt, oder in roter Farbe, wenn es sich um die Seite ohne
Normalen handelt. Diese Ansicht ist auch im Object-Mode verfÃ¼gbar,
allerdings nur in der Solid-Ansicht und wenn X-Ray deaktiviert ist.

\marginnote{Normalen umkehren und neu berechnen}

Wenn alle Faces innerhalb eines Objekts ausgewÃ¤hlt werden, kann mittels
der Tastenkombination \kbd{Alt} + \kbd{N} das MenÃ¼ Â«\emph{Normals}Â» beim
Mauszeiger geÃ¶ffnet werden. Mit der Option Â«\emph{Flip}Â» kÃ¶nnen
anschliessend alle Normalen in die umgekehrte Richtung gekehrt werden.
Zudem kÃ¶nnen die Normalen mittels der Option Â«\emph{Recalculate
Outside}Â» zur Ã¤usseren Seite hin oder mittels Â«\emph{Recalculate
Inside}Â» zur inneren Seite hin berechnet werden.

\chapter{Einstieg in den Edit-Mode}\label{einstieg-in-den-edit-mode}

Ein Grossteil der BearbeitungsmÃ¶glichkeiten, welche im Object-Mode mit
Objekten mÃ¶glich sind, kann im Edit-Mode auch auf die Strukturelemente
der Objekte angewendet werden.

\section{Grab, Scale, Rotate}\label{grab-scale-rotate}

\marginnote{Ein Vertex kann nur bewegt werden}

Wenn ein einzelner Vertex ausgewÃ¤hlt wird, sind die
TransformationsmÃ¶glichkeiten relativ beschrÃ¤nkt. Mittels der Taste
\kbd{G} lÃ¤sst sich der Vertex im dreidimensionalen Raum verschieben. Da
der Vertex allerdings nur einen isolierten Punkt ohne eine Dimension
darstellt, kann er weder skaliert, noch rotiert werden. Dementsprechend
wird in der Sidebar lediglich die Position des Vertex angegeben, wÃ¤hrend
die Skalierung und Rotation -- anders als im Object-Mode -- nicht
angegeben werden.

\marginnote{Skalierung und Rotation geschieht um den Median der Auswahl}

Sobald zwei Vertices ausgewÃ¤hlt werden, wird in der Sidebar nicht mehr
die Position der einzelnen Vertices angegeben, sondern die Position des
Medians zwischen diesen beiden Vertices. Dies ist unabhÃ¤ngig davon, ob
die Vertices mittels Edges oder Faces miteinander verbunden sind oder
nicht. Mittels der Taste \kbd{R} oder \kbd{S} kann die Auswahl rotiert
oder skaliert werden. Beide Transformationen beziehen sich dabei auf den
Median zwischen diesen beiden Vertices. Wird also beispielsweise eine
Skalierung um den Faktor 2 getÃ¤tigt (mittels der Tasten \kbd{S} und
\kbd{2}), verdoppelt sich der Abstand der beiden Vertices zum Median.
Rotationen fÃ¼hren dazu, dass die Vertices ebenfalls um den Median
rotiert werden.

\marginnote{Skalierung und Rotation verÃ¤ndert Position von Vertices}

Dadurch lÃ¤sst sich bereits ein wichtiges Merkmal der Bearbeitung im
Edit-Mode betrachten: Mittels einer Skalierung lÃ¤sst sich die Distanz
zwischen zwei Vertices verÃ¤ndern und dadurch auch ihre Position. Ebenso
werden Vertices bei der Rotation relativ zueinander im Raum rotiert und
so in ihren Positionen verÃ¤ndert. Dies macht auch einen Abschnitt fÃ¼r
die Skalierung oder Rotation in der Sidebar obsolet, da jegliche
Transformation lediglich zu einer VerÃ¤nderung der individuellen
Platzierung der Vertices fÃ¼hrt.

Anstatt der Vertices kÃ¶nnen auch Edges und Faces direkt angewÃ¤hlt
werden. Dabei werden automatisch die dazugehÃ¶rigen Vertices mit
ausgewÃ¤hlt. Die Transformationen beziehen sich immer noch auf den
rÃ¤umlichen Mittelpunkt zwischen den einzelnen Vertices, weshalb auch in
diesem Modus eine Skalierung oder Rotation zu einer VerÃ¤nderung der
Positionen dieser Vertices fÃ¼hren.

Merke\ldots{}

Wie auch im Object-Mode kÃ¶nnen Vertices, Edges und Faces mittels der
Taste \kbd{G} bewegt, mittels der Taste \kbd{S} und mittels der Taste
\kbd{R} rotiert werden.

Skalierungen und Rotationen im Edit-Mode fÃ¼hren lediglich zu einer
VerÃ¤nderung der Positionen der einzelnen Vertices basierend auf dem
Median der Vertex-Positionen.

\section{Add, Delete, Dissolve}\label{add-delete-dissolve}

\marginnote{Primitives innerhalb eines Objektes hinzufÃ¼gen}

Innerhalb eines Objektes im Edit-Mode kÃ¶nnen weitere Mesh-Primitives
hinzugefÃ¼gt werden. Dies geschieht wie im Object-Mode mit der
Tastenkombination \kbd{Shift} + \kbd{A}. Die Auswahl ist allerdings nur
noch auf Mesh-Primitives beschrÃ¤nkt. Dementsprechend ist es nicht
mÃ¶glich, einem Mesh im Edit-Mode ein Kurven-Objekt anzufÃ¼gen. Allerdings
stehen alle primitiven Formen der Meshes zur VerfÃ¼gung. Wie auch im
Object-Mode werden die Objekte an der Position des 3D-Cursors
hinzugefÃ¼gt.

\marginnote{Elemente lÃ¶schen mit \kbd{X}}

Wie auch im Object-Mode kÃ¶nnen im Edit-Mode ausgewÃ¤hlte Elemente
gelÃ¶scht werden, indem die Taste \kbd{X} oder \kbd{Delete} gedrÃ¼ckt
wird. Anders als im Object-Mode erscheint bei beiden Tasten ein MenÃ¼
beim Mauszeiger, allerdings weil in diesem Fall der LÃ¶schvorgang
prÃ¤zisiert werden muss. So lassen sich jeweils die ausgewÃ¤hlten Faces,
die ausgewÃ¤hlten Edges oder die ausgewÃ¤hlten Vertices lÃ¶schen.

\marginnote{Elemente, welche beim LÃ¶schen eben falls entfernt werden}

Wird etwa beim Default-Cube eine einzelne FlÃ¤che ausgewÃ¤hlt und das Face
gelÃ¶scht, so bleiben die Edges, welche sich um die FlÃ¤che bilden,
erhalten -- lediglich das ausgewÃ¤hlte Face wird gelÃ¶scht. Wenn
allerdings die Edges gelÃ¶scht werden, verschwinden alle Edges, welche
das ausgewÃ¤hlte Face bilden -- lediglich die Vertices bleiben bestehen.
Durch die fehlenden Edges verschwinden nun allerdings auch die
angrenzenden Faces, da diesen nun je ein Edge fehlt. Wenn stattdessen
die Vertices gelÃ¶scht werden, fehlen auch fÃ¼r die angrenzenden Edges die
Bezugspunkte. Als Folge bleibt nur noch die gegenÃ¼berliegende FlÃ¤che
bestehen.

\marginnote{Faces und Edges isoliert lÃ¶schen}

Bei der Auswahl von mehreren FlÃ¤chen oder Edges kann das LÃ¶schen von
Elementen zu grÃ¶sseren VerÃ¤nderungen fÃ¼hren. So werden beim LÃ¶schen von
mehreren aneinandergereihten Faces auch die Edges, welche die Faces
abgrenzen, gelÃ¶scht. Um dies zu verhindern kann beim LÃ¶schen die Option
Â«\emph{Only Faces}Â» ausgewÃ¤hlt werden. Dadurch bleiben die Edges
bestehen. Zudem gibt es die Option Â«\emph{Only Edges \& Faces}Â» um
lediglich die einzelnen Vertices zu erhalten.

\marginnote{Elemente auflÃ¶sen}

Nebst dem LÃ¶schen von Elementen besteht auch die Auswahl, dass Elemente
aufgelÃ¶st werden. HierfÃ¼r wird die Option Â«\emph{Dissolve}Â» im
LÃ¶sch-MenÃ¼ angeboten. Dadurch werden die ausgewÃ¤hlten Elemente gelÃ¶scht
und die benachbarten Elemente anschliessend verbunden. Wird ein
einzelnes Edge ausgewÃ¤hlt, welches zwischen zwei Faces liegt, werden die
beiden Faces durch das AuflÃ¶sen zu einem Face kombiniert. Ã„hnlich
verhÃ¤lt es sich beim AuflÃ¶sen von Faces und Vertices.

\section{Duplicate}\label{duplicate}

\marginnote{Duplizieren mittels \kbd{D}}

Auch im Edit-Mode kÃ¶nnen Elemente mittels der Taste dupliziert werden,
wenn sie vorgÃ¤ngig ausgewÃ¤hlt wurden. Nach dem Tastendruck ist es direkt
mÃ¶glich, die Objekte zu bewegen und mittels der linken Maustaste,
\kbd{Enter}- oder \kbd{Space}-Taste zu platzieren. Mittels der Taste
\kbd{esc} oder der rechten Maustaste kann diese Bewegung abgebrochen
werden und das Objekt wird an seine ursprÃ¼ngliche Position
zurÃ¼ckgesetzt. Dadurch ist allerdings oftmals nicht mehr ersichtlich,
dass sich ein Duplikat an der Stelle des Originals befindet. Deshalb ist
es sinnvoll, in einem solchen Fall die letzte Aktion -- also das
Duplizieren -- ruckgÃ¤ngig zu machen oder das Duplikat direkt zu lÃ¶schen.
Empfehlenswert ist es auch, die Elemente trotzdem an einer anderen
Stelle zu platzieren und sie dann erst zu lÃ¶schen. Dadurch lÃ¤sst sich
erkennen, dass die Elemente dupliziert wurden und noch gelÃ¶scht werden
mÃ¼ssen.

\section{Globale vs.~lokale
Koordinaten}\label{globale-vs.-lokale-koordinaten}

\marginnote{Globale Koordinaten}

Im Edit-Mode gibt es zwei Arten von 3D-Koordinaten, mit denen die
Position eines Vertex -- respektive der Median der Auswahl mehrerer
Vertices -- angegeben wird: die globalen und die lokalen Koordinaten.
Die globalen Koordinaten entsprechen denselben Koordinaten, die auch im
Object Mode verwendet werden. Diese beziehen sich auf den Ursprung der
Welt, welcher sich an der Position 0 aller drei Achsen befindet. Dabei
handelt es sich auch um den Punkt, an dem sich die Achsen im 3D-Viewport
kreuzen.

\marginnote{Lokale Koordinaten}

Die lokalen Koordinaten beziehen sich jeweils auf die Koordinaten des
aktuellen Objektes. Das heisst, dass diese Koordinaten sich immer auf
den Ursprung des Objektes beziehen. Wenn sich der Ursprung des Objektes
am Nullpunkt aller drei Achsen befindet und keine Skalierung oder
Rotation auf das Objekt angewendet wird, dann sind die globalen und die
lokalen Koordinaten identisch. Wenn sich der Ursprung allerdings an
einer anderen Stelle im Raum befindet, beziehen sich die lokalen
Koordinaten immer auf den Ursprung des Objektes als Nullpunkt.

\marginnote{Skalierung und Rotation des Objekts sind unabhÃ¤ngig vom Edit-Mode}

Zudem bleiben die lokalen Koordinaten auch unangetastet von Skalierungen
und Rotationen, welche im Object-Mode fÃ¼r ein Objekt angegeben wurden.
Wird der Default-Cube im Object-Mode gedreht, verÃ¤ndert sich die
Position der Vertices also in den globalen Koordinaten, allerdings nicht
in den lokalen Koordinaten.

Ãœbung 5: Edit-Mode

\textbf{Ãœbung 5.1}

VerÃ¤ndern Sie den Default-Cube so, dass die Position der einzelnen
Vertices in der globalen Koordinate gegenÃ¼ber der lokalen Koordinate
doppelt so hohe absolute BetrÃ¤ge aufweisen.

\textbf{Ãœbung 5.2}

VerÃ¤ndern Sie den Default-Cube so, dass sich sein Ursprung nicht mehr in
der Mitte seines Volumens befindet, sondern in der Mitte seiner unteren
FlÃ¤che.

\chapter{Methoden der Objektbearbeitung im
Edit-Mode}\label{methoden-der-objektbearbeitung-im-edit-mode}

\section{Fill}\label{fill}

\marginnote{Elemente verbinden mittels \kbd{F}}

Wie bereits angesprochen kÃ¶nnen Elemente mittels der Taste \kbd{D}
dupliziert werden und an einer anderen Stelle platziert werden. Diese
neuen Elemente sind weder durch Edges noch durch Faces mit der
originalen Struktur verbunden. HierfÃ¼r kann der Befehl Â«\emph{Fill}Â»
benutzt werden, um Elemente zu verbinden. Mittels der Taste \kbd{F} wird
der Befehl Â«\emph{Fill}Â» gegeben. Werden etwa zwei einzelne Vertices
ausgewÃ¤hlt, werden diese mit diesem Befehl durch ein Edge verbunden.
Werden drei einzelne Vertices ausgewÃ¤hlt, werden diese nicht nur durch
Edges verbunden, sondern zugleich auch mit einem Face.

\section{Extrude}\label{extrude}

\marginnote{Extrudieren mittels \kbd{E}}

Wenn Elemente dupliziert werden, wird jeweils die Fill-Funktion
verwendet, um sie wieder mit ihren ursprÃ¼nglichen Elementen zu
verbinden. Dies ist beschwerlich. Zudem muss auch darauf geachtet
werden, dass allfÃ¤llige innere Faces wieder entfernt werden. Deshalb
wird selten mit dem Duplizieren gearbeitet, sondern mit der Funktion
Â«\emph{Extrude}Â». Diese Funktion ist in der Toolbar verfÃ¼gbar, kann aber
auch direkt mit der Taste \kbd{E} ausgewÃ¤hlt werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_11/11_1_Icon_Extrude.png}

\caption{\label{fig-1_1}Extrude-Icon.}

\end{figure}%

\marginnote{Extrusion verbindet Elemente direkt}

Beim Extrudieren von Elementen werden diese Elemente nicht nur
dupliziert, sondern auch automatisch mit den originalen Elementen
verbunden. Wird bei der Auswahl eines Faces die Taste gedrÃ¼ckt, wird
dieses Face von der originalen Position gelÃ¶st und kann verschoben
werden. Gleichzeitig ist es allerdings Ã¼ber weitere Faces noch mit den
Vertices des originalen Faces verbunden. Beim Extrudieren werden also
die ausgewÃ¤hlten Elemente aus dem Objekt herausgezogen, ohne die
originalen Vertices zu lÃ¶schen.

\marginnote{Beim Extrudieren erzeugte Elemente}

Nebst Faces lassen sich auch Vertices und Edges extrudieren. Wenn ein
einzelner Vertex extrudiert wird, generiert Blender automatisch ein Edge
zwischen dem originalen Vertex und dem extrudierten Vertex. Wenn ein
Edge extrudiert wird, generiert Blender automatisch ein Face zwischen
dem originalen Edge und dem neuen Edge. Wird ein Face extrudiert, werden
automatisch Faces zwischen den originalen Vertices/Edges und den neuen
Vertices/Edges erstellt.

\marginnote{Extrudieren prÃ¤zisieren}

Wie auch bei Transformationen kann die Extrusion mittels der Tasten
\kbd{X}, \kbd{Y} oder \kbd{Z} auf einzelne Achsen beschrÃ¤nkt werden und
mittels der Angabe von Zahlen angegeben werden, wie gross die Distanz
zum originalen Median der Auswahl sein soll. Zudem kann das Extrudieren
auch mittels der Taste \kbd{S} mit einer Skalierung verbunden werden.

\marginnote{Faces werden per Default entlang Normalen extrudiert}

Beim Extrudieren von Faces erfolgt die Bearbeitung per Default entlang
der Normalen des Faces. Dadurch wird automatisch entlang der Ausrichtung
der Faces extrudiert. Dies ist bei Vertices und Edges nicht der Fall.

Ãœbung 6: Extrudieren

\textbf{Ãœbung 6.1}

Erstellen Sie folgende Objekte ausgehend von einem WÃ¼rfel.

\includegraphics{Chapters/Images/Chapter_11/Exercise_6_1.png}\hfill

\section{Knife}\label{knife}

\marginnote{Schneiden mittels \kbd{K}}

Es ist mÃ¶glich, Faces und Edges mittels des Befehls Â«KnifeÂ» zu
zerschneiden. Dadurch resultieren neue Vertices und Edges innerhalb von
FlÃ¤chen und Kanten. Diese Operation lÃ¤sst sich ebenfalls in der Toolbar
auswÃ¤hlen. Allerdings ist es auch mÃ¶glich, mittels der Taste \kbd{K}
diese Operation direkt auf der Tastatur anzuwÃ¤hlen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_11/11_2_Icon_Knife.png}

\caption{\label{fig-1_2}Knife-Icon.}

\end{figure}%

\marginnote{Ansicht im Schnitt-Modus}

Sobald das Knife-Werkzeug Ã¼ber die Toolbar oder die Taste \kbd{K}
aktiviert wird, verwandelt sich der Mauszeiger in ein Messer. Wird die
Maus nun Ã¼ber das Objekt bewegt, wird mittels eines grÃ¼nen Vierecks
angezeigt, an welcher Stelle am Objekt gerade geschnitten werden kann.
Befindet sich an dieser Stelle zudem ein Vertex, wird dies durch eine
rote Umrandung des grÃ¼nen Vierecks signalisiert. Befindet sich das grÃ¼ne
Viereck an einem Edge, wird dieses Edge grÃ¼n markiert.

\marginnote{Schnitte setzen}

Um Schnitte zu platzieren, wird die linke Maustaste gedrÃ¼ckt. Die
Schnittpositionen werden anhand eines Vierecks markiert und weitere
Schnitte kÃ¶nnen ebenfalls mit der linken Maustaste an der entsprechenden
Position gesetzt werden. Dabei werden automatisch Edges zwischen den
einzelnen Schnittpunkten erzeugt. Passieren Schnittpunkte ein Edge, wird
an der Schnittstelle des Edges zudem automatisch ein Vertex erzeugt.

\marginnote{Schnitte bestÃ¤tigen oder abbrechen}

Mittels der Taste \kbd{Space} oder \kbd{Enter} wird der Schneidevorgang
bestÃ¤tigt. Dadurch wird der Schneidmodus verlassen und die
entsprechenden Vertices und Edges werden gesetzt. Um den Schneideprozess
abzubrechen, kann die rechte Maustaste oder \kbd{esc}-Taste gedrÃ¼ckt
werden.

\section{Loop Cut}\label{loop-cut}

\marginnote{Prinzip des Loop Cuts}

Das Messer-Werkzeug ist nÃ¼tzlich, um kreativ und flexibel Schnitte zu
erzeugen. Oftmals werden allerdings gerade Schnitte entlang einer ganzen
FlÃ¤che benÃ¶tigt, idealerweise auch in der Mitte der FlÃ¤che. HierfÃ¼r ist
das Loop-Cut-Werkzeug geeignet. Nebst der exakten Mitte kÃ¶nnen auch
andere Schnitteinheiten exakt berÃ¼cksichtig werden, beispielsweise dass
ein Bereich exakt nach einem Zehntel der LÃ¤nge geschnitten werden soll.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_11/11_3_Icon_LoopCut.png}

\caption{\label{fig-1_3}Loop-Cut-Icon.}

\end{figure}%

\marginnote{Loop Cut mittels \kbd{Ctrl} + \kbd{R}}

Das Loop-Cut-Tool kann entweder in der Toolbar oder mittels der
Tastenkombination \kbd{Ctrl} + \kbd{R} aktiviert werden. Wird
anschliessend der Mauszeiger Ã¼ber die OberflÃ¤che des Objekts bewegt,
werden VorschlÃ¤ge dargestellt, wie das Objekt gerade durchtrennt werden
kann. Dabei werden aneinandergrenzende Faces als Loop berÃ¼cksichtig,
sodass sie durchtrennt werden kÃ¶nnen.

\marginnote{Mehrere Schnitte im Loop Cut setzen}

Es kÃ¶nnen auch mehrere parallele Schnitte gemacht werden. HierfÃ¼r wird
die Anzahl Schnitte als Zahl Ã¼ber die Tastatur eingegeben. So kann etwa
der StandardwÃ¼rfel entlang einer FlÃ¤chenreihe in vier gleich grosse
FlÃ¤chen unterteilt werden, indem die Taste \kbd{3} gedrÃ¼ckt wird.
Dadurch werden drei Linien angezeigt, welche den Bereich in vier gleich
grosse Teile unterteilen.

\marginnote{Loop Cut bestÃ¤tigen oder abbrechen}

Durch einen Klick mit der linken Maustaste oder \kbd{Enter}-Taste wird
bestÃ¤tigt, dass das Objekt entlang der dargestellten Linie zerschnitten
werden soll. Um den Schneideprozess abzubrechen, kann die rechte
Maustaste, \kbd{Delete} oder \kbd{esc} gedrÃ¼ckt werden.

\marginnote{Loop Cut justieren}

Wenn die Auswahl der Linie bestÃ¤tigt wird, kann anschliessend noch
justiert werden, in welchem Bereich der Schnitt gemacht werden soll. Per
Default liegt der Schnitt genau in der Mitte. Mittels einer Bewegung mit
dem Mauszeiger kann der Schnitt entlang des Loops verschoben werden.
Alternativ kann auch mittels einer Zahleneingabe Ã¼ber die Tastatur
definiert werden, in welchem Bereich der Schnitt erfolgen soll. Mit
einem Wert von 0.5 wird ein einzelner Schnitt prozentual um die HÃ¤lfte
in die eine Richtung verschoben, mit einem Wert von -0.5 um die HÃ¤lfte
in die andere Richtung. Durch einen Klick mit der linken Maustaste oder
\kbd{Enter}-Taste wird die Linie bestÃ¤tigt und die Schnitte werden
gesetzt. Durch das DrÃ¼cken der \kbd{Delete}- oder \kbd{esc}-Taste wird
der Schnitt in der Mitte des Loops vollzogen.

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Der Loop Cut kann auch auf Edges angewendet werden, die noch nicht Teil eines Faces sind. Dabei wird das Edge genau in der Mitte durch einen Vertex in zwei Edges unterteilt.
\end{tipp}

\section{Edge Slide}\label{edge-slide}

\marginnote{Edge Slide}

Der Loop Cut beinhaltet somit zwei Schritte: Die Festlegung eines
Schnittes innerhalb eines Loops und zusÃ¤tzlich die Festlegung, in
welchem Bereich des Face-Loops der Cut erfolgen soll. Letzterer Prozess
kann bei der Auswahl eines Loops an bereits gesetzten Edges direkt
erfolgen. Dieser Prozess wird als Edge Slide bezeichnet und ist in der
Toolbar verfÃ¼gbar. Dadurch lÃ¤sst sich eine Reihe von Edges proportional
entlang anderer Edges verschieben.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_11/11_3_Icon_LoopCut.png}

\caption{\label{fig-1_4}Edge-Slide-Icon.}

\end{figure}%

\section{Subdivide}\label{subdivide}

\marginnote{Unterteilung mittels Loop Cut}

Dank des Loop Cuts ist es mÃ¶glich, dass der StandardwÃ¼rfel in gleich
grosse UnterwÃ¼rfel unterteilt wird. HierfÃ¼r muss lediglich auf alle drei
Loops -- also entlang der X-, Y- und Z-Achse -- des WÃ¼rfels ein Cut
angewendet werden. Anschliessend ist jede Seite des WÃ¼rfels in vier
Faces unterteilt.

\marginnote{Subdivision, um Objekte zu unterteilen}

Statt alle drei Loop Cuts einzeln zu erstellen, kann der WÃ¼rfel mittels
des Befehls Â«\emph{Subdivide}Â» unterteilt werden. Dieser ist Ã¼ber das
MenÃ¼ Â«\emph{Edge \textbar{} Subdivide}Â» verfÃ¼gbar. Anschliessend werden
alle ausgewÃ¤hlten Faces entlang zweier Achsen unterteilt, sodass sie aus
vier einzelnen Faces bestehen. Diese Aktion kann auch auf Edges
angewendet werden, die nicht Teil eines Faces sind. Im Kontext-MenÃ¼ zur
letzten durchgefÃ¼hrten Aktion kann zudem die Anzahl Unterteilungen
erhÃ¶ht werden.

\section{Bevel}\label{bevel}

\marginnote{Abrunden mittels \kbd{Ctrl} + \kbd{B}}

Mithilfe der Bevel-Transformation kÃ¶nnen Kanten abgerundet werden.
HierfÃ¼r wird das entsprechende Edge durch mehrere Edges ersetzt, sodass
eine Abrundung der Kante erfolgt. Der Befehl fÃ¼r das AbschrÃ¤gen kann
Ã¼ber die Toolbar erfolgen oder mittels der Tastenkombination \kbd{Ctrl}
+ \kbd{B}.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_11/11_5_Icon_Bevel.png}

\caption{\label{fig-1_5}Bevel-Icon.}

\end{figure}%

\marginnote{Abrundung durchfÃ¼hren}

Um eine Kante abrunden zu kÃ¶nnen, muss das entsprechende Edge zunÃ¤chst
ausgewÃ¤hlt werden. Nach der Auswahl kann die Bearbeitung mit der
Tastenkombination \kbd{Ctrl} + \kbd{B} gestartet werden. Dadurch
erscheint am Mauszeiger ein Faden, welcher zum Median der Auswahl fÃ¼hrt.
Durch das Bewegen des Mauszeigers vom Median weg werden die ausgewÃ¤hlten
Edges in je zwei Edges aufgeteilt, die sich von den originalen Edges
wegentfernen und dabei eine Abrundung bilden. Durch einen Klick mit der
linken Maustaste oder \kbd{Enter}-Taste wird die Abrundung zu einer
bestimmten Position bestÃ¤tigt. Durch das DrÃ¼cken der rechten Maustaste,
\kbd{Delete}- oder \kbd{esc}-Taste wird der Vorgang abgebrochen.

\marginnote{Abrundung verfeinern}

Im Kontext-MenÃ¼ zur letzten durchgefÃ¼hrten Aktion sind weitere Optionen
zur Abrundung mÃ¶glich. So kÃ¶nnen die Anzahl Segmente, mit der die
Abrundung erfolgt, noch erhÃ¶ht werden. Je mehr Segmente, desto glatter
wirkt die Abrundung. Zudem kann die Form anhand des Faktors fÃ¼r die
Â«\emph{Shape}Â» bearbeitet werden. Je nÃ¤her dieser Faktor gegen 0 strebt,
desto mehr erfolgt die Abrundung hin zum Inneren des Objektes, und je
nÃ¤her der Faktor gegen 1 strebt, desto mehr erfolgt die Abrundung hin
zum Ã„usseren des Objektes.

\marginnote{Vertices abrunden}

Die Bevel-Transformation kann sowohl fÃ¼r Edges als auch fÃ¼r Vertices
angewendet werden. HierfÃ¼r muss im Kontext-MenÃ¼ zur letzten
durchgefÃ¼hrten Aktion eingestellt werden, dass die Vertices bearbeitet
werden anstelle der Edges. HierfÃ¼r werden unter der Zeile
Â«\emph{Affect}Â» die Vertices ausgewÃ¤hlt. Dadurch lassen sich Ecken
abrunden. Durch die Auswahl von Edges bei der Zeile Â«\emph{Affect}Â»
werden die Kanten abgerundet.

\section{Inset Faces}\label{inset-faces}

\marginnote{Intrusion mittels \kbd{I}}

Die Transformation Â«Inset FacesÂ» stellt einen Spezialfall der Extrusion
dar. Dabei wird eine FlÃ¤che unterteilt in zusÃ¤tzliche FlÃ¤chen innerhalb
dieser FlÃ¤che. Wie auch bei der Extrusion werden dabei neue Vertices
erstellt, welche direkt an den originalen Vertices andocken.
Unterschiedlich ist allerdings, dass die neuen Vertices einen Teil der
originalen Faces darstellen und somit entlang der Ausrichtung der FlÃ¤che
vergrÃ¶ssert oder verkleinert werden kÃ¶nnen. Die Bearbeitung mittels
Inset Faces kann entweder Ã¼ber die Toolbar oder mittels der Taste
\kbd{I} erfolgen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_11/11_6_Icon_Inset_Faces.png}

\caption{\label{fig-1_6}Inset-Faces-Icon.}

\end{figure}%

\marginnote{Intrusion durchfÃ¼hren}

Um die Bearbeitung zu starten, muss mindestens ein Face ausgewÃ¤hlt
werden und die Taste \kbd{I} gedrÃ¼ckt werden. Wie auch beim Skalieren
von Elementen ist der Mauszeiger nun mittels eines Fadens zum Median der
Auswahl verbunden. Wenn die Maus nÃ¤her zum Median hin bewegt wird,
erscheinen zusÃ¤tzliche Faces innerhalb der Auswahl, die jeweils kleiner
werden, je nÃ¤her der Mauszeiger dem Median kommt.

\marginnote{Dicke der Intrusion}

Die Intrusion wird anhand der Breite der neu erstellten Faces
beschrieben. Wird beispielsweise nach dem DrÃ¼cken der Taste \kbd{I} die
Taste \kbd{1} gedrÃ¼ckt, sind die neuen Faces jeweils um einen Meter von
ihren ursprÃ¼nglichen Edges entfernt. Durch zu hohe Zahlen kann dies dazu
fÃ¼hren, dass sich die Faces kreuzen.

\marginnote{Individuelle Intrusion}

Die Funktion Inset Faces kann zudem auf die Faces individuell angewendet
werden. Im Normallfall werden zwei nebeneinander ausgewÃ¤hlte Faces
gemeinsam bearbeitet. Es ist jedoch auch mÃ¶glich, die Faces individuell
anzusteuern, sodass die ausgewÃ¤hlten Faces individuell bearbeitet
werden. HierfÃ¼r muss im Kontext-MenÃ¼ zur letzten durchgefÃ¼hrten Aktion
die Option Â«\emph{Individual}Â» angewÃ¤hlt werden.

\section{Spin}\label{spin}

\marginnote{Spin}

Mittels Â«SpinÂ» kÃ¶nnen einzelne oder mehrere Vertices in einer
kreisfÃ¶rmigen Anordnung extrudiert werden. Wenn diese Transformation
ausgewÃ¤hlt ist, erscheint in der NÃ¤he des 3D-Cursors ein Gizmo, welches
eine abgerundete Linie mit einem Plus-Symbol an beiden Enden darstellt.
Falls dieses Gizmo nicht angezeigt wird, sollte Ã¼berprÃ¼ft werden, ob die
Darstellung der Gizmos im 3D-Viewport aktiviert ist.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_11/11_7_Icon_Spin.png}

\caption{\label{fig-1_7}Spin-Icon.}

\end{figure}%

\marginnote{Spin durchfÃ¼hren}

Um Vertices nun kreisfÃ¶rmig zu extrudieren, mÃ¼ssen Sie zunÃ¤chst
ausgewÃ¤hlt werden. Anschliessend kann an einem der beiden Pluszeichen
gezogen werden und die Vertices werden kreisfÃ¶rmig um den 3D-Cursor
herum extrudiert. Dabei werden per Default zwÃ¶lf Vertices erstellt --
unabhÃ¤ngig davon, wie weit im Kreis extrudiert wird.

\marginnote{Spin verfeinern}

Im Kontext-MenÃ¼ zur letzten durchgefÃ¼hrten Aktion kann die Aktion noch
bearbeitet werden, sodass etwa die Anzahl extrudierter Vertices unter
Â«\emph{Steps}Â» verÃ¤ndert werden kann. Je mehr Vertices extrudiert
werden, desto glatter wirkt der Kreis. Unter Â«\emph{Angle}Â» kann mittels
einer Winkelangabe eingestellt werden, wie weit die Extrusion um den
3D-Cursor herum erfolgen soll. Wenn die Zeile Â«\emph{Auto Merge}Â»
aktiviert ist, werden Vertices an derselben Position -- beispielsweise
die Vertices am Anfang und Ende einer 360Â°-Umdrehung -- zu einem Vertex
kombiniert.

\section{Merge}\label{merge}

\marginnote{Verbinden mittels \kbd{M}}

In den bisherigen Transformationen wurden jeweils neue Vertices, Edges
oder Faces hinzugefÃ¼gt. Manchmal kommt es vor, dass einige Elemente
wieder entfernt werden mÃ¼ssen, oder dass sie an einer Stelle verbunden
werden mÃ¼ssen. HierfÃ¼r kann der Befehl Â«\emph{Merge}Â» verwendet werden.
Dieser lÃ¤sst sich mittels der Taste \kbd{M} innerhalb eines MenÃ¼s beim
Mauszeiger auswÃ¤hlen.

\marginnote{Elemente beim Median verbinden}

Wenn beispielsweise zwei Vertices ausgewÃ¤hlt werden und die Taste
\kbd{M} gedrÃ¼ckt wird, kÃ¶nnen die Vertices durch Â«\emph{At Center}Â» beim
Median zwischen den beiden Vertices verbunden werden. Dabei werden die
beiden Vertices zusammengefÃ¼hrt zu einem Vertex, welches alle Edges und
Faces der originalen Vertices aufnimmt. Das Mergen kann zudem mit
beliebig vielen Vertices vollzogen werden. Bei der Auswahl von Edges und
Faces werden dabei die beteiligten Vertices zur ZusammenfÃ¼hrung
verwendet.

\marginnote{Andere Verbindungspunkte}

Nebst dem Medianpunkt der Vertices kÃ¶nnen auch folgende Positionen zur
ZusammenfÃ¼hrung ausgewÃ¤hlt werden:

\begin{itemize}
\tightlist
\item
  \textbf{At Cursor}: Die Vertices werden an der Position des 3D-Cursors
  zusammengefÃ¼hrt.
\item
  \textbf{At First}: Die Vertices werden beim Vertex, welcher als Erstes
  ausgewÃ¤hlt wurde, zusammengefÃ¼hrt.
\item
  \textbf{At Last}: Die Vertices werden beim Vertex, welcher als Letztes
  ausgewÃ¤hlt wurde, zusammengefÃ¼hrt.
\item
  \textbf{Collapse}: Wenn mehrere Edges ausgewÃ¤hlt werden, die nicht
  miteinander verbunden sind, werden die Vertices jeweils in der Mitte
  des jeweiligen Edges zusammengefÃ¼hrt. Das ZusammenfÃ¼hren erfolgt also
  hierbei einzeln fÃ¼r jedes Edge in dessen Mitte (bei den anderen
  Optionen werden alle Vertices an demselben Punkt zusammengefÃ¼hrt).
\end{itemize}

\marginnote{Merge by Distance}

Eine besondere Rolle kommt der Funktion Â«\emph{Merge by Distance}Â» zu.
Dabei werden alle Vertices zusammen verbunden, deren Distanz geringer
als die vorgegebene Distanz ist. Im Kontext-MenÃ¼ zur letzten Aktion
lÃ¤sst sich die Distanz, unterhalb derer alle Vertices verbunden werden
sollen, anpassen. Die Funktion wird allerdings nur auf die ausgewÃ¤hlten
Vertices angewendet. In der Fussleiste von Blender wird temporÃ¤r
angegeben, wie viele Vertices bei dieser Aktion aufgelÃ¶st werden.

\marginnote{Merge erfolgt nur auf Auswahl}

Diese Methode ist besonders geeignet, um allfÃ¤llige Vertices, welche an
derselben Position wie andere Vertices liegen, zu eliminieren oder zu
verbinden. Da die Aktion allerdings nur auf ausgewÃ¤hlte Vertices
angewendet wird, empfiehlt es sich, vorgÃ¤ngig alle Vertices direkt mit
der Taste \kbd{A} auszuwÃ¤hlen.

\section{Weitere Operationen in der
Toolbar}\label{weitere-operationen-in-der-toolbar}

Nebst den bisher behandelten Operationen zur Objektbearbeitung im
Edit-Mode bietet die Toolbar noch eine Reihe weiterer Optionen, welche
der VollstÃ¤ndigkeit halber noch kurz aufgefÃ¼hrt werden.

\subsection{Add Cube}\label{add-cube}

\marginnote{WÃ¼rfel hinzufÃ¼gen}

Mittels des Befehls Â«\emph{Add Cube}Â» kann ein neuer WÃ¼rfel erstellt
werden. Um den Maus zeiger herum erscheint dadurch ein Gitternetz, um zu
signalisieren, wo der WÃ¼rfel erstellt wird. Anschliessend kann mittels
gedrÃ¼ckter linken Maustaste der Grundriss des WÃ¼rfels erstellt werden.
Nachdem die linke Maustaste losgelassen wurde, lÃ¤sst sich anschliessend
noch die HÃ¶he des WÃ¼rfels einstellen, welche anschliessend mit bestÃ¤tigt
werden muss. Mit \kbd{esc} oder die rechte Maustaste lÃ¤sst sich der
Vorgang abbrechen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_11/11_8_Icon_AddCube.png}

\caption{\label{fig-1_8}Add-Cube-Icon.}

\end{figure}%

Die neu erstellten WÃ¼rfel werden im Edit-Mode zu Bestandteilen des
Objekts, welches gerade bearbeitet wird. Der Befehl Â«\emph{Add Cube}Â»
steht allerdings auch im Object-Mode zur VerfÃ¼gung. Werden dort neue
WÃ¼rfel erstellt, bilden diese jeweils eigenstÃ¤ndige Objekte.

\subsection{Poly Build}\label{poly-build}

\marginnote{Poly-Build-Modus}

Beim Poly Build handelt es sich um einen interaktiven Modus, um
Geometrien zu erweitern. Dabei schlÃ¤gt Blender bei gedrÃ¼ckter
\kbd{Ctrl}-Taste vor, wie neue Elemente erstellt werden kÃ¶nnen, und
durch einen Klick mittels der linken Maustaste wird die Erstellung
bestÃ¤tigt. Mittels gedrÃ¼ckter linken Maustaste kÃ¶nnen Vertices bewegt
werden und mittels der Kombination \kbd{Shift} + linke Maustaste.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_11/11_9_Icon_PolyBuild.png}

\caption{\label{fig-1_9}Poly-Build-Icon.}

\end{figure}%

\subsection{Smooth}\label{smooth}

\marginnote{Objekte glÃ¤tten}

Mittels des Befehls Â«SmoothÂ» kÃ¶nnen Objekte glatter gemacht werden. Dies
geschieht, indem die Winkel der Edges gemittelt werden. Statt eines
90Â°-Winkels entsteht dann ein flacherer Winkel. Es ist allerdings auch
mÃ¶glich, den gegenteiligen Effekt zu erzielen und Winkel spitzer zu
machen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_11/11_10_Icon_Smooth.png}

\caption{\label{fig-1_10}Smooth-Icon.}

\end{figure}%

\subsection{Shrink/Fatten}\label{shrinkfatten}

\marginnote{Objekte zusammenziehen oder aufblÃ¤hen}

Beim Befehl Â«Shrink/FattenÂ» werden die ausgewÃ¤hlten Vertices entlang
ihrer eigenen Normalen bewegt. Dadurch kann das Objekt aufgeblÃ¤ht oder
zusammengezogen werden. Dies ist beispielsweise nÃ¼tzlich, wenn der
Mantel eines Zylinders ausgewÃ¤hlt und sein Radius vergrÃ¶ssert werden
soll, ohne dessen HÃ¶he zu verÃ¤ndern.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_11/11_11_Icon_ShrinkenFatten.png}

\caption{\label{fig-1_11}Shrink/Fatten-Icon.}

\end{figure}%

\subsection{Shear}\label{shear}

\marginnote{Objekte auseinanderziehen}

Mittels der Shear-Transformation werden die ausgewÃ¤hlten Punkte in einer
Achse aus einandergezogen. Die Transformation geschieht dabei so, dass
parallel verlaufende Linien geschert und in entgegengesetzte Richtungen
auf einer Achse verschoben werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_11/11_12_Icon_Shear.png}

\caption{\label{fig-1_12}Shear-Icon.}

\end{figure}%

\subsection{Rip Region}\label{rip-region}

\marginnote{Regionen aufteilen}

Mittels des Befehls Â«Rip RegionÂ» kÃ¶nnen Vertices, welche an mehreren
Faces andocken, aufgeteilt werden. Die Faces werden dabei an der Stelle
der entsprechenden Vertices getrennt und durch Vertices, welche
sozusagen von den originalen Vertices abgezogen werden, neu gebildet.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_11/11_13_Icon_RipRegion.png}

\caption{\label{fig-1_13}Rip-Region-Icon.}

\end{figure}%

Ãœbung 7: Objektbearbeitung

\textbf{Ãœbung 7.1}

VerÃ¤ndern Sie den StandardwÃ¼rfel im Edit-Mode so, dass er die Form eines
Hauses hat.

\textbf{Ãœbung 7.2}

Erstellen Sie eine Vase. Die Vase sollte rund sein und eine Ã–ffnung
haben -- ansonsten sind Sie frei in Ihrer Gestaltung. Achten Sie zudem
darauf, dass Sie unterschiedliche Faces fÃ¼r den Innenbereich und fÃ¼r den
Aussenbereich der Vase verwenden, sodass die Vase ein gewisse Dicke
besitzt.

\includegraphics{Chapters/Images/Chapter_11/Exercise_7_2.png}\hfill

\chapter{Hilfestellungen fÃ¼r die
Objektbearbeitung}\label{hilfestellungen-fuxfcr-die-objektbearbeitung}

Blender bietet eine Reihe von Hilfestellungen, welche nÃ¼tzlich fÃ¼r die
Erstellung von 3D-Objekten sind. Einige dieser Hilfestellungen sind im
Header des 3D-Viewports aufzufinden.

\section{Die Position des 3D-Cursors
verÃ¤ndern}\label{die-position-des-3d-cursors-veruxe4ndern}

\marginnote{3D-Cursor verschieben und rotieren}

Der 3D-Cursor wird fÃ¼r einige der Hilfsmittel benÃ¶tigt. Deshalb ist es
sinnvoll, sich damit zu befassen, wie der 3D-Cursor bewegt werden kann.
In der Sidebar, welche mit der Taste \kbd{N} ein- und ausgeblendet
werden kann, befindet sich unter dem Register Â«\emph{View}Â» ein
Abschnitt zum 3D-Cursor. An dieser Stelle kann die Position des Cursors
im dreidimensionalen Raum anhand der X-, Y- und Z-Achse definiert
werden. Nebst der Position verfÃ¼gt der 3D-Cursor Ã¼ber eine Rotation,
welche ebenfalls an dieser Stelle definiert werden kann. Durch eine
VerÃ¤nderung der Rotation des 3D-Cursors verÃ¤ndert sich auch die Rotation
der Linien, welche den 3D-Cursor im 3D-Viewport kreuzen. Diese Linien
stellen die Rotation des 3D-Cursors dar.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_12/12_1_Snap_Menu.png}

\caption{\label{fig-1_1}Snap-MenÃ¼.}

\end{figure}%

\marginnote{Snap-MenÃ¼}

Mittels der Tastenkombination \kbd{Shift} + \kbd{S} lÃ¤sst sich das
sogenannte Â«\emph{Snap}Â»-MenÃ¼ Ã¶ffnen. Dieses sich erscheint direkt beim
Mauszeiger und ermÃ¶glicht es, ausgewÃ¤hlte Objekte oder den 3D-Cursor an
bestimmte Positionen zu verschieben. Das MenÃ¼ beinhaltet folgende
Optionen:

\begin{itemize}
\tightlist
\item
  \textbf{Cursor to Grid}: Dadurch wird der 3D-Cursor an die
  nÃ¤chstliegende Position des Koordinatengitters verschoben, welches als
  Viewport-Overlay angezeigt wird.
\item
  \textbf{Cursor to World Origin}: Dadurch wird der 3D-Cursor an den
  Ursprung der Welt positioniert. Dies entspricht dem Nullpunkt aller
  drei Achsen.
\item
  \textbf{Cursor to Selected}: Der 3D-Cursor wird an der Position des
  ausgewÃ¤hlten Objektes respektive dem Median der aktuellen Auswahl
  positioniert.
\item
  \textbf{Cursor to Active}: Der 3D-Cursor wird an der Position des
  aktiven Elementes positioniert.
\item
  \textbf{Selection to Cursor (Keep Offset)}: Alle ausgewÃ¤hlten Elemente
  werden zum 3D-Cursor verschoben, sodass sich der Median der
  ausgewÃ¤hlten Elemente an der Position des 3D-Cursors befindet. Die
  Relationen zwischen den ausgewÃ¤hlten Objekten bleiben dabei bestehen.
\item
  \textbf{Selection to Cursor}: Alle ausgewÃ¤hlten Elemente werden zum
  3D-Cursor verschoben, sodass sich die Position jedes individuellen
  Elementes an der Position des 3D-Cursors befindet. Im Edit Mode fÃ¼hrt
  dies dazu, dass alle ausgewÃ¤hlten Vertices auf der Position des
  3D-Cursors liegen.
\item
  \textbf{Selection to Active}: Die Auswahl wird an die Position des
  aktiven Objektes verschoben. Im Edit Mode fÃ¼hrt dies dazu, dass alle
  ausgewÃ¤hlten Vertices auf derselben Position liegen.
\item
  \textbf{Selection to Grid}: Das ausgewÃ¤hlte Element oder der Median
  der ausgewÃ¤hlten Elemente wird an die nÃ¤chstliegende Position des
  Koordinatengitters verschoben, welches als Viewport-Overlay angezeigt
  wird. Im Edit-Mode werden die ausgewÃ¤hlten Elemente ebenfalls an die
  nÃ¤chstliegende Position des Koordinatengitters verschoben. Wenn die
  Ansicht jedoch zu weit hinausgezoomt wird und die Elemente dadurch
  visuell an derselben Stelle zu sein scheinen, werden alle ausgewÃ¤hlten
  Vertices dabei an derselben Position platziert.
\end{itemize}

\section{Transform Orientation}\label{transform-orientation}

\marginnote{Verschiedene Orientierungen fÃ¼r Transformationen}

Bei Transformationen kÃ¶nnen die X-, Y- und Z-Achsen zu Hilfe genommen
werden. Diese Achsen scheinen fix festgelegt zu sein. Es gibt allerdings
verschiedene Orientierungen fÃ¼r diese Achsen. Die Transform-Orientation
beschreibt diese Orientierung der Achsen. Es stehen folgende
Orientierungen zur VerfÃ¼gung:

\begin{itemize}
\tightlist
\item
  Global
\item
  Local
\item
  Normal
\item
  Gimbal
\item
  View
\item
  Cursor
\end{itemize}

\begin{figure}

\includegraphics{Chapters/Images/Chapter_12/12_2_Transform_orientation.png}

\caption{\label{fig-1_2}Auswahl der Transform-Orientation.}

\end{figure}%

\marginnote{Gizmos helfen bei der Orientierung}

Um ein besseres VerstÃ¤ndnis fÃ¼r die Unterschiede in den
Transform-Orientierungen zu bekommen, ist es sinnvoll, unter dem
Dropdown-MenÃ¼ fÃ¼r die Viewport-Gizmos das Gizmo fÃ¼r die Bewegung
einzuschalten. Dadurch erscheint ein Gizmo, welches vorgibt, in welche
Richtung die Achsen durch die Transform-Orientierung verlaufen.

\subsection{Global}\label{global}

\marginnote{Globale Orientierung}

Die globale Orientierung entspricht immer genau den Achsen der Welt. Das
heisst, man kann sich dabei immer an den vorgegebenen Achsen im
Viewport-Overlay orientieren.

\subsection{Local}\label{local}

\marginnote{Lokale Orientierung}

Die lokale Orientierung entspricht jeweils der Orientierung eines
Objektes. Wenn ein Objekt im Object-Mode um 20Â° rotiert wurde, sind auch
die Achsen um diese 20Â° rotiert. Dies Einstellung gilt sowohl fÃ¼r den
Object- als auch fÃ¼r den Edit-Mode. Im Object-Mode unterscheiden sich
die Gizmos zwischen den verschiedenen Objekten, je nach deren Rotation.

\subsection{Normal}\label{normal}

\marginnote{Orientierung entlang der Normalen}

Die Orientierung anhand der Normalen verlÃ¤uft im Edit-Mode so, dass die
Z-Achse immer den Normalen der ausgewÃ¤hlten Einheiten entspricht. Die X-
und Y-Achse beschreiben dann die Achsen im VerhÃ¤ltnis zu den Normalen.
Wenn mehrere Elemente ausgewÃ¤hlt sind, entspricht die Z-Achse dem
Mittelwert der Normalen. Im Object-Mode ist diese Orientierung
Ã¤quivalent zur lokalen Orientierung.

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Beim Extrudieren mittels \kbd{E} schlÃ¤gt Blender eine Extrusion entlang der Z-Achse in der Normal-Orientierung vor. Deshalb muss jeweils zweimal die Taste \kbd{Z}gedrÃ¼ckt werden, um entlang der globalen Z-Achse zu extrudieren â€“ einmal, um die Z-Achse entlang der Normal-Orientierung abzuwÃ¤hlen, und einmal, um die Z-Achse entlang der eingestellten Orientierung auszuwÃ¤hlen.
\end{tipp}

\subsection{Gimbal}\label{gimbal}

\marginnote{Gimbal-Orientierung}

Die Gimbal-Orientierung stellt eine fortgeschrittene
Orientierungsmethode dar, welche bei Euler-Rotationen von Nutzen sein
kann. Im Rahmen dieses Kurses werden Euler-Rotationen nicht behandelt,
weshalb nicht weiter auf diese Orientierung eingegangen wird.

\subsection{View}\label{view}

\marginnote{Orientierung entlang der Ansicht}

Die View-Orientierung entspricht der Orientierung entsprechend der
Ansicht auf dem Bildschirm. Die X-Achse verlÃ¤uft horizontal Ã¼ber den
Bildschirm und die Y-Achse vertikal. Die Z-Achse beschreibt die Achse
der eigenen Ansicht nach nÃ¤her oder weiter weg.

\subsection{Cursor}\label{cursor}

\marginnote{Orientierung entsprechend dem 3D-Cursor}

Die 3D-Cursor-Orientierung verlÃ¤uft entlang des 3D-Cursors. Dabei wird
die Rotation des 3D-Cursors berÃ¼cksichtig, sodass die Achsen
entsprechend der 3D-Cursor-Rotierung verlaufen.

\subsection{Custom}\label{custom}

\marginnote{Eigene Orientierung hinzufÃ¼gen}

Mittels der Plus-SchaltflÃ¤che ist es mÃ¶glich, eigene Orientierungen zu
erstellen. So kann die lokale Orientierung eines Objekts abgespeichert
werden, um sie bei Objekten, die eigentlich eine andere lokale
Orientierung aufweisen, ebenfalls verwenden zu kÃ¶nnen.

\section{Pivot Point}\label{pivot-point}

\marginnote{Verschiedene Drehpunkte}

Eine Reihe von Transformationen orientieren sich an einem bestimmten
Drehpunkt im dreidimensionalen Raum. Wenn vom StandardwÃ¼rfel etwa zwei
gegenÃ¼berliegende Faces ausgewÃ¤hlt werden, orientiert sich eine
Skalierung der Faces anhand der Medianposition der Vertices. Mittels des
MenÃ¼reiters Â«\emph{Transform Pivot Point}Â» kÃ¶nnen auch andere Drehpunkte
ausgewÃ¤hlt werden. Die Optionen sind dabei:

\begin{itemize}
\tightlist
\item
  Bounding Box
\item
  Center
\item
  3D Cursor
\item
  Individual Origins
\item
  Median Point
\item
  Active Element
\end{itemize}

\begin{figure}

\includegraphics{Chapters/Images/Chapter_12/12_3_Icon_Pivot_Point.png}

\caption{\label{fig-1_3}Icon fÃ¼r den Pivot-Point in der Default-Auswahl
(Median-Point).}

\end{figure}%

\subsection{Bounding Box Center}\label{bounding-box-center}

\marginnote{Bounding Box Center als Drehpunkt}

Die Option Â«\emph{Bounding Box Center}Â» berechnet jeweils eine
dreidimensionale Box um die ausgewÃ¤hlten Einheiten, welche gerade so
gross ist, dass sich die gesamte Auswahl darin befindet. Der Mittelpunkt
dieser Box wird als Drehpunkt fÃ¼r Transformationen verwendet. Im
Object-Mode werden lediglich die UrsprÃ¼nge von Objekten fÃ¼r die
Berechnung der Box verwendet, nicht die Meshes. Im Edit-Mode wird die
Box um alle ausgewÃ¤hlten Einheiten berechnet.

\subsection{3D Cursor}\label{d-cursor}

\marginnote{3D-Cursor als Drehpunkt}

Die Option Â«\emph{3D Cursor}Â» verwendet die Position des 3D-Cursors als
Drehpunkt fÃ¼r Transformationen. Der 3D-Cursor kann in seiner Position
verÃ¤ndert werden, wodurch sich jede beliebige Stelle im drei
dimensionalen Raum als Drehpunkt verwenden lÃ¤sst. Ein Objekt, das sich
an einer anderen Stelle als der 3D-Cursor befindet, wÃ¼rde bei dieser
Einstellung um den 3D-Cursor rotiert.

\subsection{Individual Origins}\label{individual-origins}

\marginnote{Individual Origin als Drehpunkt}

Die Option Â«\emph{Individual Origins}Â» benutzt fÃ¼r jede ausgewÃ¤hlte
Einheit den individuellen Ursprung als Drehpunkt. Wenn im Object-Mode
mehrere Objekte ausgewÃ¤hlt sind, deren UrsprÃ¼nge sich an verschiedenen
Positionen befinden, verwendet jedes Objekt seinen eigenen Ursprung als
Drehpunkt. Im Edit-Mode werden ausgewÃ¤hlte Einheiten, die nicht direkt
miteinander verbunden sind, als individuelle Einheiten betrachtet. Diese
verwenden den Median der Auswahl als Drehpunkt fÃ¼r Transformationen.
Werden vom Default-Cube beispielsweise zwei gegenÃ¼berliegende Faces
ausgewÃ¤hlt, wird von jedem Face individuell der Median berechnet und
dieser fÃ¼r das jeweilige Face als Drehpunkt verwendet. Wenn mehrere
Faces, die direkt nebeneinander liegen, ausgewÃ¤hlt sind, werden die
aneinanderliegenden Faces zusammengefasst und fÃ¼r diese gemeinsam ein
individueller Ursprung berechnet und als Drehpunkt verwendet.

\subsection{Median Point}\label{median-point}

\marginnote{Median als Drehpunkt}

Die Option Â«\emph{Median Point}Â» wird bei neuen Projekten als
Default-Auswahl fÃ¼r den Drehpunkt von Transformationen verwendet. Dabei
handelt es sich um die mittlere Position zwischen allen ausgewÃ¤hlten
Vertices im Edit-Mode. Wenn mehrere Objekte im Object-Mode ausgewÃ¤hlt
sind, wird der Median zwischen den Objekt-Ursprungspositionen als
Drehpunkt verwendet.

\subsection{Active Element}\label{active-element}

\marginnote{Ursprung des aktiven Elements als Drehpunkt}

Die Option Â«\emph{Active Element}Â» verwendet den Ursprung des aktiven
Elements als Drehpunkt fÃ¼r Transformationen. Beim aktiven Element
handelt es sich um das zuletzt ausgewÃ¤hlte Objekt, welches mit einer
orangen Umrandung gekennzeichnet ist. Der Ursprungspunkt dieses Objekts
wird als Drehpunkt fÃ¼r Transformationen verwendet. Im Edit-Mode ist das
aktive Element mit einer weissen EinfÃ¤rbung markiert. Dieses Element,
respektive der entsprechende Median bei mehreren Edges, Faces oder
Vertices, wird anschliessend als Drehpunkt fÃ¼r Transformationen
verwendet.

\section{Snap}\label{snap}

\marginnote{Elemente an anderen Elementen andocken lassen}

Die Option Â«\emph{Snap}Â» ist bei der Verschiebung von Objekten nÃ¼tzlich.
Dadurch kÃ¶nnen andere Elemente benutzt werden, um die zu verschiebenden
Objekte direkt an deren Struktur andocken zu lassen. So mÃ¼ssen nicht die
etwaigen Koordinaten ermittelt werden, sondern Blender rastet die zu
bewegenden Objekte direkt an anderen Objekten ein. Die anvisierten
Strukturen kÃ¶nnen dabei im Edit-Mode Teil des eigenen Objektes sein,
aber auch Teil eines anderen Objektes. Im Object-Mode wird zudem jeweils
der Ursprung des Objektes zum Andocken verwendet. Im Dropdown-MenÃ¼ kann
ein gestellt werden, an welchen Stellen jeweils angedockt werden soll:

\begin{itemize}
\tightlist
\item
  Increment
\item
  Vertex
\item
  Edge
\item
  Face
\item
  Volume
\item
  Edge Center
\item
  Edge Perpendicular
\end{itemize}

\begin{figure}

\includegraphics{Chapters/Images/Chapter_12/12_4_Icon_Snap.png}

\caption{\label{fig-1_4}Snap-Icon.}

\end{figure}%

\subsection{Increment}\label{increment}

\marginnote{Snap auf ein Inkrement}

Ist Snap auf Â«\emph{Increment}Â» eingestellt, so werden die Inkremente
der Welt verwendet, um Objekte anders zu platzieren. Mit diesen
Inkrementen sind die Gitterraster im Hintergrund der 3D-Ansicht gemeint.
Jedes Viereck stellt dabei ein Inkrement dar. Durch stÃ¤rkeres Hinein-
oder Hinauszoomen im 3D-Viewport werden jeweils grÃ¶ssere oder kleinere
Inkremente sichtbar. Die ausgewÃ¤hlten Objekte rasten proportional
zueinander an der Stelle in einem Inkrement ein.

\subsection{Vertex}\label{vertex}

\marginnote{Snap auf Vertices}

Ist Snap auf Â«\emph{Vertex}Â» eingestellt, so kÃ¶nnen andere Vertices
angesteuert werden und Blender verbindet die Auswahl direkt auf der
entsprechenden Position. Dabei kÃ¶nnen auch die Vertices von anderen
Objekten angesteuert werden, selbst wenn diese nicht innerhalb des
Edit-Modes mitaktiviert wurden.

\subsection{Edge}\label{edge}

\marginnote{Snap auf Edges}

Ist Snap auf Â«\emph{Edge}Â» eingestellt, so kÃ¶nnen andere Edges als Ziel
angesteuert werden und die Auswahl wird direkt passend auf eine Position
auf dem Edge eingestellt. Dabei kann die ganze LÃ¤nge eines Edges
ausgewÃ¤hlt werden. Es kÃ¶nnen zudem Edges von anderen Objekten
angesteuert werden, selbst wenn diese nicht innerhalb des Edit-Modes
aktiviert wurden.

\subsection{Face}\label{face}

\marginnote{Snap auf Faces}

Ist Snap auf Â«\emph{Face}Â» eingestellt, so versucht Blender, die Auswahl
direkt an der Position von anderen Faces anzudocken. Dabei kann jeder
Punkt auf einem Face ausgewÃ¤hlt werden. Zudem kÃ¶nnen auch hier die Faces
von anderen Objekten angesteuert werden.

\subsection{Volume}\label{volume-1}

\marginnote{Snap auf das Volumen}

Mittels der Einstellung von Snap auf Â«\emph{Volume}Â» lÃ¤sst sich das
Volumen eines Objektes als genaues Ziel zum Einrasten einer Auswahl
verwenden. Oft ist nicht klar ersichtlich, wo genau das Objekt nun
einrastet, da das Volumen eines Objektes hÃ¤ufig durch die Faces verdeckt
wird. Hierbei kann die Wireframe-Ansicht helfen.

\subsection{Edge Center}\label{edge-center}

\marginnote{Snap auf die Mitte von Edges}

Mittels der Einstellung von Snap auf Â«\emph{Edge Center}Â» werden jeweils
die Mittelpunkte von Edges anvisiert. Hierbei werden also keine Vertices
anvisiert, sondern der Median des Edges. Andere Punkte auf dem Edge
werden nicht zum Einhaken angeboten.

\subsection{Edge Perpendicular}\label{edge-perpendicular}

\marginnote{Snap auf senkrechte Edges}

Mittels der Einstellung von Snap auf Â«\emph{Edge Perpendicular}Â» wird
die Auswahl bei dem Punkt eines Edges eingerastet, welcher im Lot zur
aktuellen Auswahl steht. Dabei kÃ¶nnen nicht alle Edges verwendet werden,
da nicht alle einen solchen Winkel zur Auswahl aufweisen.

\subsection{Was wird angedockt?}\label{was-wird-angedockt}

\marginnote{Quelle des Snaps einstellen}

Wenn lediglich ein einzelner Vertex ausgewÃ¤hlt und verschoben wird, ist
klar, welcher Punkt jeweils an den anvisierten Stellen andockt: der
ausgewÃ¤hlte Vertex. Wenn allerdings mehrere Elemente ausgewÃ¤hlt wurden,
benutzt Blender per Default das jeweils ursprÃ¼nglich am nÃ¤chsten
liegende Element zum Andocken. Es kann allerdings eingestellt werden,
dass der Median der aktivierten Auswahl oder das aktive Element
verwendet wird. Dies kann unter Â«\emph{Snap With}Â» eingestellt werden.
ZusÃ¤tzlich gibt es noch die Auswahl Â«\emph{Center}Â», welche zusÃ¤tzlich
noch weitere Abweichungen vom Drehpunkt mitberÃ¼cksichtigt
(beispielsweise die ursprÃ¼ngliche Abweichung vom 3D-Cursor).

\section{Proportional Editing}\label{proportional-editing}

\marginnote{Proportionale Bearbeitung mittels \kbd{O} aktivieren}

Die Option Â«\emph{Proportional Editing}Â» ermÃ¶glicht es, dass nahe
beieinanderliegende Elemente proportional zu ihrer NÃ¤he bearbeitet
werden kÃ¶nnen. Diese Option kann auch mit der Taste \kbd{O} aktiviert
oder deaktiviert werden. Wenn diese Option aktiviert ist und eine
Transformation durchgefÃ¼hrt wird (z.B. eine Rotation), erscheint um den
Bezugspunkt ein Kreis. Alle Elemente, welche sich innerhalb dieses
Kreises befinden, werden diese Transformation nun ebenfalls durchfÃ¼hren.
Der Radius des Kreises kann mittels des Mausrads vergrÃ¶ssert oder
verkleinert werden. Dadurch wird der Erfassungsbereich der
proportionalen Bearbeitung variiert. Alternativ kann die Taste
\kbd{PageUp} zum VergrÃ¶ssern des Kreises oder \kbd{PageDown} zum
Verkleinern des Kreises gedrÃ¼ckt werden..

\begin{figure}

\includegraphics{Chapters/Images/Chapter_12/12_5_Icon_Proportional_Editing.png}

\caption{\label{fig-1_5}Icon fÃ¼r Proportional Editing.}

\end{figure}%

\marginnote{Proportionale Bearbeitung im Object-Mode}

Im Object-Mode mÃ¼ssen jeweils die UrsprÃ¼nge der Objekte, welche
proportional transformiert werden sollen, innerhalb des
Erfassungskreises liegen. Dabei spielt es keine Rolle, ob das Mesh des
Objektes ebenfalls erfasst wird oder nicht. Im Edit-Mode kÃ¶nnen
lediglich die Vertices der aktuell ausgewÃ¤hlten Objekte proportional
mittransformiert werden. Zudem gibt es im Edit-Mode die MÃ¶glichkeit, im
Dropdown-MenÃ¼ des Proportional Editings die Option Â«\emph{Connected
Only}Â» anzuwÃ¤hlen. Dadurch werden lediglich Vertices bei der
proportionalen Bearbeitung berÃ¼cksichtigt, die Ã¼ber Edges mit den zu
bearbeitenden Vertices verbunden sind.

\marginnote{Form der proportionalen Bearbeitung}

Die Elemente, welche sich innerhalb des Erfassungskreises befinden,
werden anschliessend alle proportional mittransformiert. Die Proportion
erfolgt dabei einer vorgegebenen Kurve, welche sich anhand des
Dropdown-MenÃ¼s genauer definieren lÃ¤sst. Mithilfe der proportionalen
Bearbeitung lassen sich durch die Bearbeitung eines einzigen Vertex
komplexe Strukturen erstellen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_12/12_6_Proportional_Editing_Examples.png}

\caption{\label{fig-1_6}Die verschiedenen Formen zur proportionalen
Bearbeitung im Vergleich. Beispiele zeigen eine FlÃ¤che von 2x2 Metern,
bestehend aus 16x16 Faces. Diese Faces wurden mittig um 0.5 Meter
entlang der Z-Achse bewegt.}

\end{figure}%

\marginnote{Anwendungsbereiche fÃ¼r proportionale Bearbeitung}

Gerade natÃ¼rliche Objekte (FrÃ¼chte, Landschaften, BÃ¤ume, Blumen, usw.)
sind selten symmetrisch. Oftmals gibt es Dellen oder andere
Verformungen. Mittels der proportionalen Bearbeitung kÃ¶nnen solche
Verformungen leicht auf grÃ¶ssere FlÃ¤chen angewendet werden, ohne dass
jeder Vertex einzeln bearbeitet werden muss.

Ãœbung 8: Proportional Editing

\textbf{Ãœbung 8.1}

Erstellen Sie eine UV-Sphere und versuchen Sie, damit eine Birne zu
modellieren. Nutzen Sie hierfÃ¼r die proportionale Bearbeitung.

\section{Weitere Optionen}\label{weitere-optionen}

\marginnote{Symmetrische Bearbeitung}

Im Edit-Mode sind in der oberen rechten Ecke weitere Optionen verfÃ¼gbar.
Zum einen sind die drei Achsen X, Y und Z als SchaltflÃ¤che anwÃ¤hlbar.
Durch das AnwÃ¤hlen eines dieser Icons wird das Objekt entsprechend der
ausgewÃ¤hlten Achse symmetrisch bearbeitet. Eine VerÃ¤nderung des Objekts
auf der einen Seite der Achse wird dabei also gleichzeitig auch auf der
gegenÃ¼berliegenden Seite durchgefÃ¼hrt. Gerade bei symmetrischen Objekten
hat dies den Vorteil, dass der Fokus nur auf eine Seite gelegt werden
muss, ohne dass die Bearbeitungsschritte auf der anderen Seite nochmals
wiederholt werden mÃ¼ssen.

\marginnote{Symmetrische Bearbeitung zu Beginn aktivieren}

Bei der symmetrischen Bearbeitung muss allerdings darauf geachtet
werden, dass diese Option nicht immer funktioniert. Sobald die
Bearbeitung des Objektes begonnen hat, kann Blender teilweise diese
Symmetrie nicht mehr berÃ¼cksichtigen. Wenn eine symmetrische Objektbe
arbeitung nÃ¶tig ist, sollte diese also gleich zu Beginn aktiviert
werden.

\marginnote{Vertices automatisch verbinden}

Neben den SchaltflÃ¤chen fÃ¼r die drei Achsen befindet sich zudem das Icon
fÃ¼r die Option Â«\emph{Auto Merge Vertices}Â». Durch das Aktivieren dieser
Option werden Vertices, welche wÃ¤hrend der weiteren Bearbeitung auf
derselben Position platziert werden, automatisch miteinander verbunden.
Dadurch ist es nicht mehr nÃ¶tig, von Hand Vertices zu einem Vertex zu
verbinden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_12/12_7_Icon_Automerge.png}

\caption{\label{fig-1_7}Icon fÃ¼r Auto Merge Vertices.}

\end{figure}%

\chapter{Tutorial: Erstellen eines
Glases}\label{tutorial-erstellen-eines-glases}

\marginnote{Ziel dieses Tutorials}

Bislang wurden die grundlegenden Prinzipien der Objektbearbeitung
behandelt. Diese ermÃ¶glichen eine Vielzahl von
BearbeitungsmÃ¶glichkeiten, sodass bereits sehr komplexe Objekte
modelliert werden kÃ¶nnen. Nachfolgend daher eine ErklÃ¤rung, wie
beispielsweise die erlÃ¤uterten BearbeitungsmÃ¶glichkeiten verwendet
werden kÃ¶nnen, um ein Glas zu modellieren, wie etwa in Abbildung 1.

\marginnote{WÃ¼rfel lÃ¶schen}

ZunÃ¤chst wird ein neues Blender-Projekt geÃ¶ffnet. Da das Glas eine runde
Form hat, ist der StandardwÃ¼rfel nicht geeignet, um das Glas
nachzubilden. Aus diesem Grund wird er mittels der Taste \kbd{X}
gelÃ¶scht.

\marginnote{Referenzbild einfÃ¼gen}

Generell ist es empfehlenswert, bei der Erstellung von Objekten mit
Referenzbildern zu arbeiten. Aus diesem Grund wird eine Bildvorlage fÃ¼r
das Glas benÃ¶tigt. HierfÃ¼r kann eine Bilddatei direkt aus einem Ordner
oder vom Desktop in den 3D-Viewport hineingezogen werden, sodass das
Bild anschliessend direkt in der Szene sichtbar wird. Das Bild wird
allerdings so eingefÃ¼gt, dass es senkrecht zur Benutzeransicht sichtbar
ist. Das bedeutet, dass das Bild entsprechend der eigenen
Benutzeransicht positioniert und rotiert wird. Aus diesem Grund
empfiehlt es sich, vor dem Hineinziehen des Bildes mit der Taste \kbd{1}
in die Frontansicht zu wechseln. Dadurch wird das Bild lediglich entlang
der X-Achse um 90Â° rotiert eingefÃ¼gt. Alternativ kann das Bild Ã¼ber das
Â«\emph{Add}Â»-MenÃ¼ (\kbd{Shift} + \kbd{A}) unter Â«\emph{Image \textbar{}
Reference}Â» hinzugefÃ¼gt werden. Zudem ist das Bild jeweils nur sichtbar,
wenn die Viewport-Overlays aktiviert sind.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_13/13_1_Image_Example.png}

\caption{\label{fig-1_1}Bildvorlage zur Erstellung eines Glases.}

\end{figure}%

\marginnote{Bild platzieren}

Allenfalls sollte das Referenzbild noch im Raum platziert werden.
Idealerweise wird das Bild so platziert, dass sich der Mittelpunkt des
unteren Endes des Glases am Nullpunkt der Welt befindet. An dieser
Stelle sollte sich ebenfalls der 3D-Cursor befinden.

\marginnote{Primitive Mesh erstellen}

Als NÃ¤chstes wird das Objekt hinzugefÃ¼gt, aus dem anschliessend das Glas
geformt werden soll. Dieses hat im Idealfall bereits eine Ã¤hnliche Form
wie das zu erstellende Objekt. In diesem Fall wÃ¼rde dies einem Zylinder
entsprechen. Ãœber das Â«\emph{Add}Â»-MenÃ¼ (\kbd{Shift} + \kbd{A}) wird
unter Â«\emph{Mesh \textbar{} Cylinder}Â» ein Zylinder an der Position des
3D-Cursors erstellt. Der Zylinder kann in seinen Default-Einstellungen
belassen werden.

\marginnote{Zylinder positionieren}

Mittels der Taste \kbd{Tab} wird in den Edit-Mode gewechselt, um die
Bearbeitung des Zylinders zu starten. Die HÃ¶he des Zylinders erstreckt
sich nun von Z = -1m bis Z = 1m. Somit lieg ein Teil des Zylinders
unterhalb des Ursprungs des Objektes. Deshalb wird der Zylinder nun um
einen Meter entlang der Z-Achse nach oben verschoben. Mittels der Taste
\kbd{A} werden alle Elemente des Zylinders ausgewÃ¤hlt. Um eine
Verschiebung entlang der Z-Achse um einen Meter zu bewirken, wird die
Taste \kbd{G} zum Starten der Bewegung, die Taste \kbd{Z} zum Einrasten
entlang der Z-Achse, die Zahl \kbd{1} zur Angabe der Bewegung um einen
Meter und die Taste \kbd{Enter} zum BestÃ¤tigen gedrÃ¼ckt. Nun sollte der
Boden des Zylinders am Nullpunkt liegen, so wie in Abbildung 2.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_13/13_2_Glass_Cylinder.png}

\caption{\label{fig-1_2}Zylinder, nachdem seine Vertices um einen Meter
entlang der Z-Achse nach oben verschoben wurden.}

\end{figure}%

\marginnote{HÃ¶he des Zylinderdeckels anpassen}

Der Zylinder ist nun an der Position des Glases, allerdings weist er die
falschen Dimensionen auf. Durch eine Skalierung des Zylinders wÃ¼rde sich
auch der soeben angepasste Boden verschieben. Deshalb werden die
Vertices des Deckels manuell ausgewÃ¤hlt und verschoben. HierfÃ¼r wird bei
gedrÃ¼ckter \kbd{Alt}-Taste ein Edge entlang des Zylinderdeckels
ausgewÃ¤hlt. Dadurch werden alle Vertices entlang der Schlaufe dieses
Edges ausgewÃ¤hlt -- also in dem Fall alle Vertices auf dem Deckel des
Zylinders. Diese Vertices werden nun entlang der Z-Achse um den Wert
-1.2 verschoben, sodass sie die HÃ¶he Z = 0.8 aufweisen.

\marginnote{Breite des Zylinders anpassen}

Als NÃ¤chstes wird der Mantel des Zylinders angepasst, sodass er der
maximalen Breite des Glases entspricht. HierfÃ¼r werden alle Vertices
ausgewÃ¤hlt und entlang der X- und Z-Achse kleiner skaliert. Mittels der
Taste \kbd{A} werden alle Vertices ausgewÃ¤hlt. Anschliessend wird
mittels der Taste \kbd{S} der Skalierungsvorgang gestartet, und mittels
der Tastenkombination \kbd{Shift} + \kbd{Z} die Z-Achse ignoriert. Durch
die Eingabe von \kbd{0} \kbd{.} \kbd{6} und der BestÃ¤tigung mittels
\kbd{Enter} wird anschliessend das Objekt entlang der X- und Y-Achse um
den Faktor 0.6 skaliert.

\marginnote{Zylindermantel in Edges unterteilen}

In den nÃ¤chsten Bearbeitungsschritten muss der Mantel des Zylinders
entsprechend der Form angepasst werden. HierfÃ¼r werden weitere Vertices
Innerhalb des Zylindermantels benÃ¶tigt. Um diese hinzuzufÃ¼gen, werden
mit einem Loop Cut zehn Edges entlang des Zylindermantels eingefÃ¼gt.
Hier fÃ¼r wird mit der Tastenkombination \kbd{Ctrl} + \kbd{R} zunÃ¤chst
der Loop-Cut-Modus gestartet. Anschliessend wird der Mauszeiger Ã¼ber die
Edges, welche vertikal dem Zylindermantel entlang verlaufen, bewegt.
Dadurch sollte Blender nun einen Schnitt entlang des Zylindermantels in
der Mitte der HÃ¶he vor schlagen. Um statt eines Schnittes gleich zehn
Schnitte zu erhalten, wird die Zahl \kbd{1} \kbd{0} eingegeben und der
Schnitt anschliessen mittels der linken Maustaste oder \kbd{Enter}
bestÃ¤tigt. Danach muss nochmals mittels der linken Maustaste oder
\kbd{Enter} bestÃ¤tigt werden, dass der Loop Cut mittig der FlÃ¤chen
verlaufen soll. Wenn die Maus bereits bewegt wurde, erfolgt der Schnitt
nicht mehr mittig. In diesem Fall sollte die Platzierung mittels
\kbd{esc} der Taste beendet werden.

\marginnote{Anpassen der Breite von Hand}

Die neu erstellten Edges werden nun horizontal der Breite des Glases auf
der jeweiligen HÃ¶he angepasst. Dies kann zum einen manuell von Hand fÃ¼r
jede Reihe an Edges erfolgen. HierfÃ¼r wird mittels \kbd{Alt} + der
linken Maustaste auf ein horizontales Edge die gesamte Reihe von Edges
ausgewÃ¤hlt. Mittels der Skalierung (\kbd{S}) entlang der X- und Y-Achse
(\kbd{Shift} + \kbd{Z}) kann der Radius fÃ¼r die entsprechende HÃ¶he
eingestellt werden. Der Radius wird nacheinander fÃ¼r jede Edge-Reihe
angepasst.

\marginnote{Anpassen der Breite mittels Proportional Editing}

Alternativ kann auch auf das Â«\emph{Proportional Editing}Â»
zurÃ¼ckgegriffen werden, welches mittels der Taste \kbd{O} aktiviert
wird. Dadurch kann etwa die oberste Reihe von Edges mittels \kbd{Alt} +
der linken Maustaste ausgewÃ¤hlt werden. Anschliessend wird mittels der
Taste \kbd{S} die Skalierung gestartet. FÃ¼r die proportionale
Bearbeitung wird nun ein Kreis dargestellt. Dieser kann mittels des
Mausrads verkleinert oder vergrÃ¶ssert werden. Sein Radius ist im oberen
Bildschirmrand angezeigt und sollte etwa 0.75 betragen. Anschliessend
kann die Skalierung entlang der X- und Y-Achse festgelegt (\kbd{Shift} +
\kbd{Z}) und um den Faktor 0.85 skaliert werden. Dieser Vorgang wird
anschliessend nochmals am unteren Rand des Zylinders wiederholt (mit
einem Radius von ca. 0.5 und einer Skalierung um den Faktor 0.5).
Anschliessend wird bei deaktivierter proportionaler Bearbeitung noch der
untere Rand erneut um den Faktor 0.9 entlang der X- und Y-Achse skaliert
und der obere Rand ebenfalls um den Faktor 0.975.

\marginnote{Zylinderdeckel lÃ¶schen}

Der Zylinder sollte nun bereits die Form des Glases aufweisen. Durch
einen Wechsel in den Face-Select-Modus ist es mÃ¶glich, direkt das Face,
welches den Deckel des Zylinders darstellt, auszuwÃ¤hlen und mittels
\kbd{X} zu lÃ¶schen. Anschliessend ist das Glas so gut wie fertig -- ihm
fehlt lediglich noch eine Dicke.

\marginnote{3D-Cursor verschieben}

Um die Dicke des Glases zu erstellen, sollen alle Faces gegen den
Mittelpunkt des oberen Randes des Zylinders hinausgezogen werden.
HierfÃ¼r muss zunÃ¤chst der 3D-Cursor mittig des oberen Randes platziert
werden. Dies geschieht, indem alle Edges entlang des oberen Randes
ausgewÃ¤hlt werden (hierfÃ¼r muss wieder in den Edge- oder
Vertex-Select-Modus gewechselt werden). Anschliessend wird mittels der
Tastenkombination \kbd{Shift} + \kbd{S} das Snap-MenÃ¼ geÃ¶ffnet. Mit der
Auswahl Â«\emph{Cursor to Selected}Â» wird der 3D-Cursor mittig in der
Auswahl zu platzieren.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_13/13_3_Proportional_Editing_Top.png}

\caption{\label{fig-1_3}Proportionale Anpassung der Breite des Zylinders
entsprechend der Bildvorlage.}

\end{figure}%

\marginnote{FlÃ¤che nach innen extrudieren}

Anschliessend wird der Bezugspunkt fÃ¼r Transformationen auf den
3D-Cursor gewechselt (unter der SchaltflÃ¤che Â«\emph{Transform Pivot
Point}Â» im Header). Nachdem alle Elemente des Zylinders mittels \kbd{A}
ausgewÃ¤hlt wurden, kÃ¶nnen nun alle FlÃ¤chen mit der Taste \kbd{E}
extrudiert werden. Mittels der Taste \kbd{S} wird skalierend extrudiert
und mit den Tasten \kbd{0} \kbd{.} \kbd{9} \kbd{5} der Faktor 0.95
festgelegt. Dies kann schliessend mittels der linken Maustaste oder
\kbd{Enter} bestÃ¤tigt werden. Mit diesem Schritt ist das Glas bereits
fertiggestellt. Es sieht noch etwas eckig und kantig aus, aber in den
nÃ¤chsten Kapiteln wird behandelt, wie das Glas noch glatter erscheint.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_13/13_4_Extrusion_Thickness.png}

\caption{\label{fig-1_4}Alle Faces des Glases werden zum 3D-Cursor hin
extrudiert, damit das Glas eine Dicke erhÃ¤lt.}

\end{figure}%

\section{Alternative Methode zur Erstellung eines
Glases}\label{alternative-methode-zur-erstellung-eines-glases}

\marginnote{Backup-Objekt erstellen}

Es gibt noch eine andere Methode zur Erstellung des Glases. Zur
Veranschaulichung dieser Methode kann im Object-Mode nach der Auswahl
des Glases mittels der Taste \kbd{D} ein Duplikat erstellt werden,
welches mit der Taste \kbd{H} versteckt werden kann. Dadurch bleibt
dieses Duplikat erhalten, sodass trotzdem die andere Methode ausprobiert
werden kann.

\marginnote{Querschnitt des Glases erstellen}

Nun wird das andere Glas im Edit-Mode bearbeitet. Das Ziel ist es
hierbei, dass ein Querschnitt des Glases entsteht. Diese Methode
erfordert den Vertex-Select-Mode. Mittels \kbd{A} + der linken Maustaste
wird ein Edge, welches vertikal dem Glas entlang verlÃ¤uft, ausgewÃ¤hlt
und mittels der Tastenkombination \kbd{Ctrl} + \kbd{I} die Auswahl
umgekehrt. Nun wird diese Auswahl von Vertices mittels \kbd{X} gelÃ¶scht.
Dadurch sollten nun lediglich die Vertices Ã¼brigbleiben, die den Rand
eines Glases vertikal darstellen. Die Ã¤ussersten Vertices werden
anschliessend extrudiert und auf ihrer jeweiligen HÃ¶he am Nullpunkt der
Szene plaziert.

\marginnote{KreisfÃ¶rmiges Herausziehen mittels des Spin-Tools}

Anhand eines solchen Querschnittes eines Glases kann nun mittels des
Spin-Tools kreisfÃ¶rmig die Form des Glases extrudiert werden. HierfÃ¼r
wird zunÃ¤chst in der Toolbar das Spin-Tool aktiviert. Anschliessend
werden alle Vertices mit der Taste \kbd{A} ausgewÃ¤hlt. Durch das Ziehen
entlang einer der beiden Â«+Â»-Symbole des Spin-Gizmos kann anschliessend
das Glas kreisfÃ¶rmig aus dem Querschnitt herausgezogen werden. Im
Kontext-MenÃ¼ zur letzten Aktion kann anschliessend der Radius noch auf
360Â° festgelegt werden und darunter Â«\emph{Auto Merge}Â» aktiviert
werden. Dadurch werden die beiden Enden des extrudierten Bereichs
zusammen verbunden. ZusÃ¤tzlich kann unter Â«\emph{Steps}Â» noch die Anzahl
extrudierter Faces erhÃ¶ht werden, um einen glatteren Kreis zu erhalten.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_13/13_5_Cross_Section.png}

\caption{\label{fig-1_5}Querschnitt des Glases. Die in der Abbildung
ausgewÃ¤hlten Vertices mÃ¼ssen entlang der X- und Y-Achse noch zum
Ursprung des Objektes extrudiert werden.}

\end{figure}%

Ãœbung 9: Eigenes Glas erstellen

\textbf{Ãœbung 9.1}

Nehmen Sie ein rundes Glas aus Ihrem eigenen Haushalt, welches Sie
anschliessend in Blender nachbauen. Idealerweise nehmen Sie ein Glas
ohne weitere OberflÃ¤chenstrukturen. Machen Sie ein Foto von diesem Glas
von der Seite in einem mÃ¶glichst rechten Winkel und verwenden Sie dieses
Foto anschliessend als Vorlage in einem Blender-Projekt. Bauen Sie
dieses Glas anschliessend als 3D-Objekt nach.

Speichern Sie das Glas zudem ab, um es in spÃ¤teren Kapiteln verwenden zu
kÃ¶nnen.

\chapter{Objekterstellung mittels
Modifiern}\label{objekterstellung-mittels-modifiern}

\marginnote{Destruktive Objektbearbeitung}

Die bislang besprochenen Methoden der Objektbearbeitung stellen
destruktive Methoden dar. Bei destruktiven Methoden wird das Objekt so
abgeÃ¤ndert, dass es seine originale Form verliert. Ein Zylinder, der mit
destruktiven Methoden zu einem Glas modelliert wird, verliert also seine
Form als Zylinder.

\marginnote{Destruktive Bearbeitung ist schwer zurÃ¼ckzuverfolgen}

Durch die destruktive Objektbearbeitung ist es schwierig, wieder an
einen frÃ¼heren Punkt der Bearbeitung zurÃ¼ckzukehren. Mittels der
Tastenkombination \kbd{Ctrl} + \kbd{Z} kÃ¶nnen zwar Schritte wieder
rÃ¼ckgÃ¤ngig gemacht werden, allerdings ist die Anzahl dieser Schritte
beschrÃ¤nkt. Zudem gehen diese Bearbeitungsschritte verloren, sobald
Blender geschlossen wird, sodass Bearbeitungsschritte von frÃ¼heren
Blender-Sessions nicht rÃ¼ckgÃ¤ngig gemacht werden kÃ¶nnen.

\marginnote{KomplexitÃ¤t durch destruktives Vorgehen}

Gerade wenn komplexe Objekte bearbeitet werden, kann es vorkommen, dass
frÃ¼here Schritte sich spÃ¤ter als Fehler herausstellen. Dann muss das
Objekt mÃ¶glicherweise Ã¼ber komplexe Umwege wieder in den gewÃ¼nschten
frÃ¼heren Zustand zurÃ¼ckgebracht werden. Zudem kÃ¶nnen gewisse Schritte
zum einen Zeitpunkt dazu fÃ¼hren, dass andere Schritte zu einem spÃ¤teren
Zeitpunkt komplexer werden.

\marginnote{Modifier zur nicht-destruktiven Bearbeitung von Objekten}

WÃ¤re es von daher nicht praktisch, wenn Objekte mittels mÃ¶glichst
simpler Parameter bearbeitet werden kÃ¶nnten, welche sich auch
nachtrÃ¤glich jederzeit wieder bearbeiten liessen? Genau hierfÃ¼r gibt es
die sogenannten Modifier. Die Modifier ermÃ¶glichen eine
nicht-destruktive Form der Objektbearbeitung. Sie kÃ¶nnen als Funktionen
verstanden werden, welche auf ein Objekt angewendet werden und deren
Einstellungen jederzeit nachjustiert werden kÃ¶nnen.

\section{Ein glas mittels Modifiern
erstellen}\label{ein-glas-mittels-modifiern-erstellen}

\subsection{Vorbereitung}\label{vorbereitung}

\marginnote{Bisheriges Glas stellt eine komplexe Struktur dar}

Im vorherigen Kapitel wurde bereits behandelt, wie ein Glas mittels
destruktiver Methoden erstellt werden kann. Die Form des
fertiggestellten Glases kann noch verÃ¤ndert werden, allerdings ist es
komplex, die Vertices so zu bearbeiten, dass die Struktur erhalten
bleibt. Deshalb wird nun ein neues Glas mittels Modifiern erstellt.

\marginnote{Objekt auf einen einzelnen Vertex reduzieren}

Um ein neues Glas zu erstellen, wird in diesem Fall ein beliebiges
primitives Mesh erstellt. Danach werden im Edit-Mode (Wechsel mittels
\kbd{Tab}) alle Vertices ausgewÃ¤hlt (\kbd{A}). Anschliessend werden
diese Vertices alle zu einem einzigen Vertex zusammengefasst, indem
mittels der Taste \kbd{M} der Merge-Befehl Â«\emph{At Center}Â» aufgerufen
wird. Nun sollte nur noch ein einziger Vertex vorhanden sein. Dieser
sollte am Ursprung des Objektes platziert werden. HierfÃ¼r kann in der
Sidebar (Aufrufen mittels \kbd{N}) der Vertex im lokalen
Koordinatensystem am Nullpunkt platziert werden. Dieser Vertex stellt
nun den Mittelpunkt des Glasbodens dar.

\marginnote{Neue Vertices extrudieren}

Als NÃ¤chstes wird die Form des Glases im Querschnitt erstellt. Am besten
wird das Objekt in der Vorderansicht betrachtet. ZunÃ¤chst wird der
Radius des Glasbodens festgelegt. HierfÃ¼r wird ein Edge entlang der
X-Achse beispielsweise um 0.1 Meter extrudiert ( \kbd{E}, \kbd{X},
\kbd{0} \kbd{.} \kbd{1}, danach bestÃ¤tigen mittels der Taste
\kbd{Enter}). Anschliessend wird von diesem Vertex ebenfalls ein Vertex
herausgezogen, welches entlang der Z-Achse (und bei Bedarf auch entlang
der Y-Achse) verschoben wird. Dadurch sollte nun ein Querschnitt eines
halben Glases erstellt worden sein, wie in Abbildung 1 dargestellt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_1_Cross_Section.png}

\caption{\label{fig-1_1}Der Querschnitt eines halben Glases.}

\end{figure}%

\marginnote{Vertices mit der Maus erstellen}

Eine alternative MÃ¶glichkeit, um Vertices zu extrudieren, besteht darin,
dass im Edit-Mode bei gedrÃ¼ckter \kbd{Ctrl}-Taste mit der rechten
Maustaste in den 3D-Viewport geklickt wird. An der Stelle des Klicks
wird anschliessend ein neuer Vertex erstellt. Wenn davor ein Vertex
ausgewÃ¤hlt wurde, wird der mit dem Klick erstelle Vertex Ã¼ber ein Edge
mit dem ausgewÃ¤hlten Vertex verbunden. So kann der Umriss des Glases
auch mittels der Maus erstellt werden.

\marginnote{Weitere Schritte zur Erstellung des Glases}

Mithilfe dieser drei Vertices kann bereits ein Glas erstellt werden.
HierfÃ¼r wird Folgendes benÃ¶tigt:

\begin{itemize}
\tightlist
\item
  Die drei Vertices mÃ¼ssen, wie mit dem Spin-Tool, im Kreis extrudiert
  werden.
\item
  Das Objekt benÃ¶tigt eine Dicke.
\end{itemize}

\subsection{HinzufÃ¼gen von Modifiern}\label{hinzufuxfcgen-von-modifiern}

\marginnote{Modifier-Panel im Properties-Editor}

Modifier sind jeweils im Properties-Editor aufzufinden, welcher das
Areal in der rechten unteren Ecke von Blender darstellt. Auf der linken
Seite dieses Editors befindet sich ein Reiter mit verschiedenen
Symbolen. Die Modifier werden dort als SchraubenschlÃ¼ssel symbolisiert.
Durch einen Klick auf den SchraubenschlÃ¼ssel wird der Modifier-Reiter
geÃ¶ffnet. Darin werden alle Modifier aufgelistet, die dem aktiven Objekt
oder dem gerade bearbeiteten Objekt zugewiesen sind.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_2_Icon_Modifiers.png}

\caption{\label{fig-1_2}Modifier-Icon, welches im Reiter des
Properties-Editors aufzufinden ist.}

\end{figure}%

\marginnote{Modifier hinzufÃ¼gen}

Der Reiter fÃ¼r die Modifier ist noch leer, da dem Objekt noch kein
Modifier hinzugefÃ¼gt wurde. In der Dropdown-Liste Â«\emph{Add Modifie}rÂ»
kÃ¶nnen Modifier hinzugefÃ¼gt werden. Diese Modifier werden auf das aktive
Element oder das Objekt, welches gerade im Edit-Mode bearbeitet wird,
angewendet.

\marginnote{Screw-Modifier, um im Kreis zu extrudieren}

Als Erstes wird ein Modifier benÃ¶tigt, der das Spin-Tool auf das Glas
anwendet. Dieser kann mittels des Modifiers Â«\emph{Screw}Â» erstellt
werden. Dieser Modifier extrudiert Objekte kreisfÃ¶rmig um den Ursprung
herum, analog zum Spin-Tool. Per Default wird das Objekt bei der
Anwendung des Modifiers um 360Â° im Kreis gedreht. Dadurch sollte aus dem
Querschnitt ein rundes Glas erstellt werden.

\marginnote{VerÃ¤nderbarkeit von Modifiern}

Bei der destruktiven Methode mit dem Spin-Tool war es unerlÃ¤sslich, dass
direkt bei der DurchfÃ¼hrung der Transformation bestimmt wird, um wie
viele Grad die Operation durchgefÃ¼hrt werden soll, wie viele Faces
gebildet werden sollen und ob die Elemente automatisch verbunden werden
sollen. Bei der Bearbeitung mittels des Screw-Modifiers kÃ¶nnen diese
Einstellungen jederzeit in den Einstellungen des Modifiers verÃ¤ndert
werden. FÃ¼r das aktuelle Glas-Objekt ist es sinnvoll, hier die
Einstellung Â«\emph{Merge}Â» zu aktivieren, sodass die Vertices am Start
und am Ende der Umdrehung zu je einem Vertex verbunden werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_3_Glass_Screw_Solidify_Modifiers.png}

\caption{\label{fig-1_3}Glas, erstellt mittels eines Screw- und eines
Solidify-Modifiers.}

\end{figure}%

\marginnote{Solidify-Modifier, um Dicke zu erstellen}

Das Glas benÃ¶tigt noch eine Dicke. Auch diese kann mittels eines
Modifiers hinzugefÃ¼gt werden. HierfÃ¼r wird mittels des Dropdown-MenÃ¼s
Â«\emph{Add Modifier}Â» ein Â«\emph{Solidify}Â»-Modifier hinzugefÃ¼gt. Dieser
extrudiert alle Faces entlang ihrer Normalen und verbindet sie
gemeinsam, sodass das Objekt eine Dicke erhÃ¤lt. Somit hat das Glas nun
bereits seine eigentliche Form erhalten.

\subsection{Der
Subdivision-Surface-Modifier}\label{der-subdivision-surface-modifier}

\marginnote{Subdivision Surface zum GlÃ¤tten}

Das Glas ist allerdings sehr eckig. An dieser Stelle kommt der wohl
wichtigste Modifier zur Anwendung: der Subdivision-Surface-Modifier. Der
Subdivision-Surface-Modifier unterteilt alle Faces im Modell durch zwei
Edges in jeweils vier kleinere Faces -- so wie auch der Befehl
Â«\emph{Subdivide}Â». ZusÃ¤tzlich passt der Modifier die neu gebildeten
Edges so an, dass die OberflÃ¤chen abgerundet und geglÃ¤ttet werden.
Dadurch kÃ¶nnen klobige und eckige Modelle besonders schnell zu
abgerundeten und glatten Modellen umgewandelt werden.

\marginnote{Subdivisions hinzufÃ¼gen}

Unter Â«\emph{Add Modifier}Â» kann der Â«\emph{Subdivision
Surface}Â»-Modifier ausgewÃ¤hlt werden. Beim Modifier kann anschliessend
unter Â«\emph{Levels Viewport}Â» eingegeben werden, wie viele Subdivisions
erzeugt werden sollen. Es kÃ¶nnen maximal sechs Subdivisions im Modifier
durchgefÃ¼hrt werden (wobei auch mehr Subdivisions mÃ¶glich sind, indem
ein weiterer Subdivision-Surface-Modifier hinzugefÃ¼gt wird). Je hÃ¶her
die Anzahl Subdivisions, desto glatter wird die FlÃ¤che. Allerdings
erhÃ¶ht sich dadurch auch die Anzahl Vertices zur Berechnung des
Objektes, was mehr Leistung vom Computer erfordert. Es ist deshalb
ratsam, es nicht mit diesem Modifier zu Ã¼bertreiben.

\marginnote{Subdivisions beim Rendern}

Unterhalb der Zeile Â«\emph{Levels Viewport}Â» befindet sich die Zeile
Â«\emph{Render}Â». Dadurch lÃ¤sst sich die Anzahl Subdivisions fÃ¼r den
finalen Render einstellen. Dies ermÃ¶glicht eine hÃ¶here Anzahl
Subdivisions fÃ¼r den finalen Render-Prozess, wÃ¤hrend die Bearbeitung mit
einer geringeren Anzahl erfolgt und weniger Leistung benÃ¶tigt wird.

\marginnote{Catmull vs. Simple}

ZusÃ¤tzlich verfÃ¼gt der Subdivision-Surface-Modifier Ã¼ber die
Einstellungsoption Â«\emph{Catmull-Clark}Â» oder alternativ
Â«\emph{Simple}Â». Per Default ist die Option Â«\emph{Catmull-Clark}Â»
eingestellt, welche dafÃ¼r sorgt, dass das Objekt geglÃ¤ttet wird. Die
Option Â«\emph{Simple}Â» unterteilt das Objekt lediglich in mehr Vertices,
ohne deren Position so anzupassen, dass das Objekt glatter erscheint.

\section{Funktionsweise von
Modifiern}\label{funktionsweise-von-modifiern}

\marginnote{Fehlende Dicke}

Nun sollten dem Glas drei Modifier in der folgenden Reihenfolge
zugeordnet sein: ein Screw-Modifier, welcher die drei Vertices
kreisfÃ¶rmig extrudiert, ein Solidify-Modifier, welcher den Faces eine
Dicke hinzufÃ¼gt, und ein Subdivision-Surface-Modifier, welcher das
Objekt durch zusÃ¤tzliche Vertices glÃ¤ttet. Das Objekt erscheint nun
glatt, aber nicht mehr besonders dick. Dies liegt daran, dass der
Solidify-Modifier dem Glas eine Dicke zuweist, der
Subdivision-Surface-Modifier allerdings die Vertices dieser Dicke so
stark glÃ¤ttet, dass die Dicke wieder verschwindet. Zudem fÃ¤llt auch auf,
dass der runde Boden des Glases stark verformt wird und
unverhÃ¤ltnismÃ¤ssig kantig erscheint.

\marginnote{Verwendung von Tris bei Modifiern}

Die seltsame Form am Boden ist auf die Form der Faces zurÃ¼ckzufÃ¼hren,
welche durch die Modifier entstehen. Durch die kreisfÃ¶rmige Extrusion
der Vertices im Screw-Modifier entstehen am Boden eine Reihe Tris, die
sich kreisfÃ¶rmig um den Mittelpunkt bilden. Die meisten Modifier kÃ¶nnen
mit Tris umgehen, allerdings nicht alle gleich gut. In diesem Fall liegt
die Ursache beim Subdivision-Surface-Modifier, welcher die kreisfÃ¶rmigen
Vertices unterschiedlich stark zum Mittelpunkt hin glÃ¤ttet.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_4_Tris_Bottom.png}

\caption{\label{fig-1_4}Verzerrung von Tris am Glasboden durch den
Subdivision-Surface-Modifier.}

\end{figure}%

\marginnote{Bevel-Modifier}

Sowohl das Problem der geringeren Dicke als auch das Problem der
unterschiedlich stark geglÃ¤tteten Vertices am Glasboden kann mittels
eines zusÃ¤tzlichen Modifiers behoben werden. Das Ziel hierfÃ¼r ist, dass
alle Edges mit grÃ¶sseren Winkeln abgerundet werden. Dies kann mittels
des Bevel-Modifiers erzielt werden. Dieser fÃ¼hrt einen Bevel-Prozess in
einer nicht-destruktiven Methode durch. Unter Â«\emph{Add Modifier}Â» kann
Â«\emph{Bevel}Â» ausgewÃ¤hlt werden, um diesen Modifier hinzuzufÃ¼gen.

\marginnote{Reihenfolge von Modifiern Ã¤ndern}

Das HinzufÃ¼gen des Bevel-Modifiers reduziert das Problem der Dicke des
Glases, allerdings bleiben die Verformungen am Boden des Glases
bestehen. Dies liegt daran, dass der Bevel-Modifier noch vor dem
Subdivision-Surface-Modifier angewendet werden sollte, respektive der
Subdivision-Surface-Modifier nach dem Bevel-Modifier. In der rechten
oberen Ecke des Subdivision-Surface-Modifiers befindet sich eine
SchaltflÃ¤che. Bei gedrÃ¼ckter linker Maustaste auf diese SchaltflÃ¤che
lassen sich die Modifier verschieben. Es muss nun entweder der
Bevel-Modifier Ã¼ber den Subdivision-Surface-Modifier gezogen werden oder
der Subdivision-Surface-Modifier unterhalb des Bevel-Modifiers. Nun
sollten beide Probleme gelÃ¶st sein. Mittels eines Wertes von 2 fÃ¼r die
Subdivisions im Viewport mÃ¼sste das Glas glatt aussehen.

\marginnote{SchaltflÃ¤chen im Header des Modifiers}

Nebst der SchaltflÃ¤che zum Verschieben beinhaltet der Header eines
Modifiers noch weitere Punkte:

\begin{itemize}
\tightlist
\item
  Innerhalb eines Textfeldes wird der Name des Modifiers angezeigt.
  Dieser kann auch abgeÃ¤ndert werden, damit etwa die Funktion des
  Modifiers klarer wird.
\item
  Daneben sind drei weitere SchaltflÃ¤chen anzutreffen, die wahlweise
  aktiviert oder deaktiviert werden kÃ¶nnen:

  \begin{itemize}
  \tightlist
  \item
    \textbf{On Cage}: Wenn diese SchaltflÃ¤che aktiviert ist, wird im
    Edit-Mode angezeigt, wie sich die Bearbeitung von Vertices auswirkt.
    Dieses Feld ist allerdings nicht bei allen Modifiern verfÃ¼gbar. Da
    es beim Screw-Modifier nicht verfÃ¼gbar ist, wird es im Beispiel mit
    dem Glas auch bei den nachfolgenden Modifiern nicht angezeigt. Durch
    das Deaktivieren der SchaltflÃ¤che Â«\emph{Edit Mode}Â» (siehe nÃ¤chsten
    AufzÃ¤hlungspunkt) beim Screw-Modifier wird die SchaltflÃ¤che
    Â«\emph{On Cage}Â» bei den darauffolgenden Modifiern jedoch wieder
    sichtbar.
  \item
    \textbf{Edit Mode}: Wenn diese SchaltflÃ¤che aktiviert ist, wird
    wÃ¤hrend der Bearbeitung im Edit-Mode der Effekt des Modifiers auf
    das gesamte Objekt gezeigt. Ansonsten bleibt dieser Modifier im
    Edit-Mode unberÃ¼cksichtigt.
  \item
    \textbf{Realtime}: Der Modifier wird im 3D-Viewport angezeigt.
  \item
    \textbf{Render}: Der Modifier wird beim Rendern berÃ¼cksichtigt.
  \end{itemize}
\item
  Innerhalb des Dropdown-MenÃ¼s sind folgende Optionen anzutreffen:

  \begin{itemize}
  \tightlist
  \item
    \textbf{Apply}: Der Modifier wird auf das Objekt angewendet. Dadurch
    verschwindet der Modifier aus der Ansicht und kann auch nicht mehr
    weiterbearbeitet werden. Wird zudem ein Modifier angewendet, der
    nicht an der obersten Position der Modifier-Reihenfolge liegt,
    werden alle vorgÃ¤ngigen Modifier bei der Anwendung ignoriert.
  \item
    \textbf{Duplicate}: Der Modifier wird dupliziert und direkt unter
    dem originalen Modifier platziert.
  \item
    \textbf{Copy to Selected}: Wenn mehrere Objekte ausgewÃ¤hlt sind,
    kann der Modifier des aktiven Elements durch diesen Befehl auf die
    anderen Objekte Ã¼bertragen werden.
  \item
    \textbf{Move to First}: Der Modifier wird in der Reihenfolge der
    Modifier an die erste Stelle verschoben.
  \item
    \textbf{Move to Last}: Der Modifier wird in der Reihenfolge der
    Modifier an die letzte Stelle verschoben.
  \end{itemize}
\item
  Mittels des Kreuzes wird ein Modifier gelÃ¶scht.
\end{itemize}

Merke\ldots{}

Modifier werden verwendet, um Objekte nicht-destruktiv bearbeiten zu
kÃ¶nnen.

Modifier werden auf Objekte angewendet.

Wenn mehrere Modifier auf ein Objekt angewendet werden, werden sie
nacheinander in der Modifier-Ansicht von oben nach unten angewendet.

\section{Weitere GlÃ¤ttung erzielen durch
Smooth-Shading}\label{weitere-gluxe4ttung-erzielen-durch-smooth-shading}

\marginnote{Shade Smooth und Shade Flat}

Blender bietet eine MÃ¶glichkeit, um Objekte noch Ã¼ber den
Subdivision-Surface-Modifier hinaus zu glÃ¤tten. HierfÃ¼r muss das
entsprechende Objekt im Object-Mode ausgewÃ¤hlt werden. Anschliessend
kann unter Â«\emph{Object \textbar{} Shade Smooth}Â» eingestellt werden,
dass das Objekt geglÃ¤ttet dargestellt wird. Unter Â«\emph{Object
\textbar{} Shade Flat}Â» kann ein geglÃ¤ttet dargestelltes Objekt wieder
ohne eine GlÃ¤ttung dargestellt werden.

\marginnote{HÃ¤ufige Fehler beim Smooth-Shading}

Bei dieser Art der GlÃ¤ttung wird nichts an der Struktur des Objektes
geÃ¤ndert, sondern dessen Darstellung geglÃ¤ttet. Diese Darstellung wirkt
allerdings bei sehr kantigen Objekten und daher auch beispielsweise bei
Objekten im Low-Poly-Stil befremdlich. In diesem Fall ist eher Â«Shade
FlatÂ» zu empfehlen. Zudem ist fÃ¼r die Berechnung dieser geglÃ¤tteten
FlÃ¤che wichtig, dass die Normalen in die richtige Richtung orientiert
sind. Nebst zu kantigen FlÃ¤chen sind falsch orientierte Normalen eine
hÃ¤ufige Ursache, wenn ein Objekt unter Â«Shade SmoothÂ» schlecht
dargestellt wird.

\section{Die Vielzahl von Modifiern}\label{die-vielzahl-von-modifiern}

\marginnote{Vielfalt der Modifier}

Blender verfÃ¼gt Ã¼ber eine sehr hohe Anzahl verschiedener Modifier,
welche auch stetig zunimmt. Einige dieser Modifier werden sehr selten
und fÃ¼r sehr spezifische Verfahren verwendet. Andere Modifier sind
hingegen praktisch unerlÃ¤sslich fÃ¼r die Arbeit mit 3D-Objekten.

\marginnote{Arten von Modifiern}

Die verschiedenen Modifier sind in vier verschiedene Arten unterteilt:

\begin{itemize}
\tightlist
\item
  \textbf{Modify}: Diese Modifier fokussieren sich auf die Datenstruktur
  innerhalb der Meshes.
\item
  \textbf{Generate}: Diese Modifier ermÃ¶glichen eine nicht-destruktive
  Bearbeitung von Objekten.
\item
  \textbf{Deform}: Diese Modifier ermÃ¶glichen eine VerÃ¤nderung der Form
  von Objekten.
\item
  \textbf{Physics}: Diese Modifier werden verwendet, um Objekten in
  Simulationen in Blender eine Rolle zuzuweisen.
\end{itemize}

\subsection{Generate-Modifier}\label{generate-modifier}

FÃ¼r die Objekterstellung werden vor allem die Generate-Modifier
verwendet. Auf ihnen liegt deshalb auch der Fokus in diesem Kurs.

\subsubsection{Array}\label{array}

\marginnote{Objekte wiederholen mittels Array-Modifier}

Der Array-Modifier erstellt beliebig viele Duplikate eines Objektes.
Diese Duplikate werden in einer Reihe aufgestellt. Dadurch kÃ¶nnen sich
wiederholende Muster mittels dieses Modifiers erstellt werden. HierfÃ¼r
lÃ¤sst sich die Anzahl Wiederholungen des Objektes unter Â«\emph{Count}Â»
einstellen. Anschliessend kann entlang der drei Achsen eingestellt
werden, in welchem Abstand die Wiederholungen jeweils zueinander stehen
sollen. Dieser Abstand kann relativ zur GrÃ¶sse des Objektes eingestellt
werden, indem Â«\emph{Relative Offset}Â» aktiviert wird. In diesem Fall
wird der Abstand um einen Faktor relativ zur ObjektgrÃ¶sse definiert. Ein
Wert von 1 wÃ¼rde bedeuten, dass das Objekt direkt an der Stelle
wiederholt wird, an der das Original seine Ã¤usserste Grenze hat. Wenn
hingegen Â«\emph{Constant Offset}Â» aktiviert wird, werden die
Wiederholungen ausgehend vom Ursprung des Objektes um den angegebenen
Wert verschoben wiederholt. Beide Abstandsoptionen lassen sich zudem
miteinander kombinieren. Mittels der Einstellung Â«\emph{Merge}Â» lassen
sich zudem die wiederholten Objekte an den Vertices zwischen den
Wiederholungen verbinden -- vorausgesetzt diese befinden sich an
derselben Position.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_5_Icon_Array_Modifier.png}

\caption{\label{fig-1_5}Icon fÃ¼r den Array-Modifier.}

\end{figure}%

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_6_Example_Array_Modifier.png}

\caption{\label{fig-1_6}Ein Objekt sowie eine Anwendung mittels eines
Array-Modifiers.}

\end{figure}%

\subsubsection{Bevel}\label{bevel-1}

\marginnote{Kanten abrunden mittels Bevel-Modifier}

Der Bevel-Modifier rundet die Kanten eines Objektes ab. Dabei kann
eingestellt werden, wie stark die Abrundung erfolgen soll und wie viele
Segmente fÃ¼r die Abrundung gebildet werden sollen. ZusÃ¤tzlich kann eine
Abrundung auch auf Edges mit bestimmten Merkmalen fixiert werden
(beispielsweise nur Edges mit bestimmten Winkeln oder einer bestimmten
Datenstruktur). Zudem kÃ¶nnen auch Vertices abgerundet werden. HierfÃ¼r
muss im oberen Bereich des Modifiers Â«\emph{Vertices}Â» statt
Â«\emph{Edges}Â» ausgewÃ¤hlt werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_7_Icon_Bevel_Modifier.png}

\caption{\label{fig-1_7}Icon fÃ¼r den Bevel-Modifier.}

\end{figure}%

\subsubsection{Boolean}\label{boolean}

\marginnote{Schnittmenge zwischen Objekten verwenden mittels Boolean-Modifier}

Der Boolean-Modifier wird verwendet, um die Teilmengen von zwei Objekten
zu bearbeiten. HierfÃ¼r wird im Modifier ein zweites Objekt ausgewÃ¤hlt.
Wahlweise kann anschliessend die gemeinsame Schnittmenge der beiden
Objekte ausgewÃ¤hlt (Â«\emph{Intersect}Â»), verbunden (Â«\emph{Union}Â») oder
entfernt werden (Â«\emph{Difference}Â»). Zu beachten ist jedoch, dass beim
Verbinden (Union) beide Objekte lediglich zu einem Objekt miteinander
verbunden werden. Die Vertice-Strukturen der originalen Objekte bleiben
erhalten und werden nicht miteinander kombiniert. Bei den beiden anderen
Optionen werden die Vertices der beiden Objekte verbunden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_8_Icon_Boolean_Modifier.png}

\caption{\label{fig-1_8}Icon fÃ¼r den Boolean-Modifier.}

\end{figure}%

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_9_Example_Boolean_Modifier.png}

\caption{\label{fig-1_9}Der Boolean-Modifier eines WÃ¼rfels in
Kombination mit einem Zylinder. Die drei verschiedenen
Boolean-Einstellungen fÃ¼hren zu unterschiedlichen Ergebnissen.}

\end{figure}%

\subsubsection{Build}\label{build}

\marginnote{Objekt-Aufbau animieren mittels Build-Modifier}

Der Build-Modifier ermÃ¶glicht es, dass ein Objekt im Rahmen einer
Animation sukzessive aufgebaut wird. Dabei lassen sich der Zeitpunkt des
Startes (Â«\emph{Start Frame}Â») und die Dauer der Animation festlegen
(Â«\emph{Length}Â»).

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_10_Icon_Build_Modifier.png}

\caption{\label{fig-1_10}Icon fÃ¼r den Build-Modifier.}

\end{figure}%

\subsubsection{Decimate}\label{decimate}

\marginnote{Vertice in einem Objekt reduzieren mittels Decimat-Modifier}

Der Decimate-Modifier reduziert die Anzahl Vertices in einem Objekt.
Dabei wird das Objekt entweder um einen Faktor runtergebrochen
(Â«\emph{Collapse}Â»), Â«\emph{un-subdivided}Â» oder abgeflacht
(Â«\emph{Planar}Â»). Der Un-Subdivide-Modus stellt das Gegenteil des
Subdivision-Surface-Modifiers dar. In diesem Modus muss allerdings
beachtet werden, dass die Anordnung der Edges zwischen den Faces bei
jedem ungeraden Schritt der Un-Subdivision verÃ¤ndert wird, wÃ¤hrend sie
bei geraden Anzahlen Un-Subdivisions erhalten bleibt, wie in Abbildung
12 dargestellt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_11_Icon_Decimate_Modifier.png}

\caption{\label{fig-1_11}Icon fÃ¼r den Decimate-Modifier.}

\end{figure}%

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_12_Example_Unsubdivide.png}

\caption{\label{fig-1_12}VerÃ¤nderung der Edge-Anordnung durch
Un-Subdivide.}

\end{figure}%

\subsubsection{Edge Split}\label{edge-split}

\marginnote{Edges zwischen Faces aufteilen mittels Edge-Split-Modifier}

Der Edge-Split-Modifier kann dazu verwendet werden, um Edges von zwei
aneinanderliegenden Faces aufzuteilen. Dadurch scheinen die Faces zwar
aneinanderzuliegen, allerdings handelt es sich dabei um zwei Faces, die
nicht miteinander verbunden sind. Dies hat den Vorteil, dass Kanten,
welche durch den Subdivision-Surface-Modifier abgerundet werden, nun als
einzelne Kanten betrachtet und nicht abgerundet werden. HierfÃ¼r muss der
Edge-Split-Modifier jedoch vor dem Subdivision-Surface-Modifier
platziert werden. Im Edge-Split-Modifier kann unter Â«\emph{Edge Angle}Â»
definiert werden, bis zu welchem Winkel die Edges jeweils separiert
werden sollen. Bei der Einstellung 30Â° werden alle Edges separiert,
deren Faces in einem grÃ¶sseren Winkel als 30Â° zueinander stehen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_13_Icon_Edge_Split_Modifier.png}

\caption{\label{fig-1_13}Icon fÃ¼r den Edge-Split-Modifier.}

\end{figure}%

\subsubsection{Geometry Nodes}\label{geometry-nodes}

\marginnote{Objekte bearbeiten mittels Geometry-Nodes-Modifier}

Der Geometry-Nodes-Modifier ist ein relativ neuer Modifier in Blender.
Er wird benÃ¶tigt, um ein Objekt mittels sogenannter Geometry Nodes zu
bearbeiten. Die entsprechende Einstellung des Geometry Nodes wird
jeweils im Geometry-Nodes-Editor vorgenommen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_14_Icon_Geometry_Nodes_Modifier.png}

\caption{\label{fig-1_14}Icon fÃ¼r den Geometry-Nodes-Modifier.}

\end{figure}%

\subsubsection{Mask}\label{mask}

\marginnote{Objekt-Teile maskieren mittels Mask-Modifier}

Mittels des Mask-Modifiers kÃ¶nnen Bestandteile eines Meshes versteckt
werden. HierfÃ¼r muss eine Gruppe aus Vertices definiert werden, welche
versteckt werdensoll, und diese Gruppe muss anschliessend im
Mask-Modifier angegeben werden. Wie Vertices zu Gruppen zusammengefÃ¼hrt
werden, wird im nÃ¤chsten Kapitel behandelt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_15_Icon_Mask_Modifier.png}

\caption{\label{fig-1_15}Icon fÃ¼r den Mask-Modifier.}

\end{figure}%

\subsubsection{Mirror}\label{mirror}

\marginnote{Objekte spiegeln mittels Mirror-Modifier}

Der Mirror-Modifier spiegelt ein Objekt entlang ausgewÃ¤hlter Achsen vom
Ursprung des Objektes aus. Dadurch muss lediglich die HÃ¤lfte eines
symmetrischen Objektes erstellt oder bearbeitet werden, weil die zweite
HÃ¤lfte direkt mittels des Mirror-Modifiers erstellt wird. Mittels der
Funktion Â«\emph{Clipping}Â» kann zudem eingestellt werden, dass die
Punkte, welche direkt auf der Spiegelungsachse liegen, miteinander
verbunden werden und nicht mehr voneinander losgelÃ¶st werden kÃ¶nnen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_16_Icon_Mirror_Modifier.png}

\caption{\label{fig-1_16}Icon fÃ¼r den Mirror-Modifier.}

\end{figure}%

\subsubsection{Multiresolution}\label{multiresolution}

\marginnote{Mesh fÃ¼r Sculpting subdividen mittels Multiresolution-Modifier}

Der Multiresolution-Modifier fÃ¼hrt bei einem Mesh eine Subdivision
durch, so wie auch der Subdivision-Surface-Modifier. Anders als beim
Subdivision-Surface-Modifier kÃ¶nnen diese Subdivisions jedoch beim
Sculpting von Objekten verwendet werden, ohne dass der Modifier
vorgÃ¤ngig auf das Objekt angewendet werden muss.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_17_Icon_Multiresolution_Modifier.png}

\caption{\label{fig-1_17}Icon fÃ¼r den Multiresolution-Modifier.}

\end{figure}%

\subsubsection{Remesh}\label{remesh}

\marginnote{Mesh neu generieren mittels Remesh-Modifier}

Mithilfe des Remesh-Modifiers kÃ¶nnen die Vertices, Edges und Faces eines
Objektes neu generiert werden. Hierbei stehen verschiedene MÃ¶glichkeiten
zur Auswahl, wie Blender bei dieser Neugenerierung vorgehen soll:

\begin{itemize}
\tightlist
\item
  \textbf{\emph{Â«BlocksÂ»}}: Die Form des Objektes wird blockartig
  erstellt.
\item
  \textbf{\emph{Â«SmoothÂ»}}: Die Form des Objektes wird mit einer
  geglÃ¤tteten OberflÃ¤che er stellt.
\item
  \textbf{\emph{Â«SharpÂ»}}: Die Form des Objektes wird mit einer
  geglÃ¤tteten OberflÃ¤che erstellt, allerdings werden spitze Ecken und
  Kanten beibehalten.
\item
  \textbf{\emph{Â«VoxelÂ»}}: Das Objekt wird basierend auf seinem Volumen
  neu erstellt.
\end{itemize}

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_18_Icon_Remesh_Modifier.png}

\caption{\label{fig-1_18}Icon fÃ¼r den Remesh-Modifier.}

\end{figure}%

\subsubsection{Screw}\label{screw}

\marginnote{Objekte kreisfÃ¶rmig extrudieren mittels Screw-Modifier}

Der Screw-Modifier wird verwendet, um Strukturen kreisfÃ¶rmig entlang
einer Achse um ihren Ursprung zu extrudieren. ZusÃ¤tzlich kann ein
Â«\emph{Screw}Â»-Faktor definiert werden. Dieser verschiebt die Umdrehung
um den Screw-Faktor entlang der ausgewÃ¤hlten Achse, sodass eine
Schraubenform entsteht.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_19_Icon_Screw_Modifier.png}

\caption{\label{fig-1_19}Icon fÃ¼r den Screw-Modifier.}

\end{figure}%

\subsubsection{Skin}\label{skin}

\marginnote{Vertices zu Mesh extrudieren mittels Skin-Modifier}

Der Skin-Modifier versieht den Vertices in einem Objekt eine zusÃ¤tzliche
Haut in Form eines WÃ¼rfels, der um den Vertex oder entlang der Edges
gebildet wird. So kann eine Form aus Vertices und Edges gebildet werden
und mittels des Skin-Modifiers mit einem KÃ¶rper entlang der Edges
versehen werden. Dieser Modifier ist Ã¤hnlich zum Solidify-Modifier,
wobei der Skin-Modifier vor allem fÃ¼r Objekte ohne Faces verwendet wird.
Die Verwendung bei Objekten mit Faces in Kombination mit dem
Skin-Modifier kann sehr viel Rechenleistung erfordern.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_20_Icon_Skin_modifier.png}

\caption{\label{fig-1_20}Icon fÃ¼r den Skin-Modifier.}

\end{figure}%

Durch das HinzufÃ¼gen des Skin-Modifiers ist es mÃ¶glich, jeden Vertex
mittels einer Skalierung zu bearbeiten. HierfÃ¼r muss ein Vertex im
Edit-Mode ausgewÃ¤hlt werden. Mittels der Tastenkombination \kbd{Ctrl} +
\kbd{A} kann der Radius des KÃ¶rpers bei diesem Vertex eingestellt
werden. Ohne das HinzufÃ¼gen des Skin-Modifiers steht diese Funktion
allerdings nicht zur VerfÃ¼gung.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_21_Example_Skin_modifier.png}

\caption{\label{fig-1_21}Ein Objekt aus Vertices und Edges sowie seine
Form mit dem Skin-Modifier.}

\end{figure}%

\subsubsection{Solidify}\label{solidify}

\marginnote{Faces extrudieren mittels Solidify-Modifier}

Der Solidify-Modifier wird verwendet, um Objekten eine Dicke
hinzuzufÃ¼gen. Dabei werden alle Faces um den Wert der Dicke extrudiert.
Die Extrusion erfolgt entlang der Normalen eines Faces um einen
Offset-Wert. Wenn dieser Wert 1 oder -1 betrÃ¤gt, werden die originalen
Vertices genau an derselben Stelle belassen und je nach Vorzeichen
verÃ¤ndert sich die Richtung der Extrusion. Bei einem negativen Wert
erfolgt die Extrusion entlang der Seite ohne Normalen, bei einem
positiven Wert entlang der Seite mit Normalen. Bei einem Wert von 0
werden die FlÃ¤chen so gebildet, dass sich die originalen Faces genau in
der Mitte der neuen Faces befinden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_22_Icon_Solidify_Modifier.png}

\caption{\label{fig-1_22}Icon fÃ¼r den Solidify-Modifier.}

\end{figure}%

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_23_Example_Solidify_Modifier.png}

\caption{\label{fig-1_23}Ein WÃ¼rfel ohne Deckel mit den Normalen nach
aussen gerichtet. Daneben Anwendungen des Solidify-Modifiers mit
unterschiedlichen Offset-Werten.}

\end{figure}%

\subsubsection{Subdivision Surface}\label{subdivision-surface}

\marginnote{Faces subdividen mittels Subdivision-Surface-Modifier}

Der Subdivision-Surface-Modifier wird verwendet, um die Struktur des
Objektes zu glÃ¤tten, indem die Struktur des Objektes unterteilt wird.
Dieser Modifier wurde vorgÃ¤ngig ausfÃ¼hrlich behandelt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_24_Icon_Subdivision_Surface_Modifier.png}

\caption{\label{fig-1_24}Icon fÃ¼r den Subdivision-Surface-Modifier.}

\end{figure}%

\subsubsection{Triangulate}\label{triangulate}

\marginnote{Quads zu Tris umwandeln mittels Triangulate-Modifier}

Der Triangulate-Modifier ermÃ¶glicht es, dass die Edges von Faces neu
berechnet werden, sodass die Faces lediglich aus Tris bestehen. Es
stehen dabei verschiedene Methoden zur Auswahl, welche individuell auf
Quads und N-Gons angewendet werden kÃ¶nnen. Durch eine ErhÃ¶hung der Zahl
unter Â«\emph{Minimum Vertices}Â» lÃ¤sst sich einstellen, dass nur Faces
mit mindestens der entsprechenden Zahl von Vertices zu Tris umgewandelt
werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_25_Icon_Triangulate_Modifier.png}

\caption{\label{fig-1_25}Icon fÃ¼r den Triangulate-Modifier.}

\end{figure}%

\subsubsection{Volume to Mesh}\label{volume-to-mesh}

\marginnote{Volumen zu Mesh umwandeln mittels Volume-to-Mesh-Modifier}

Mithilfe des Volume-to-Mesh-Modifiers kÃ¶nnen Volumen-Daten in ein Mesh
umgewandelt werden. Da dieser Kurs nicht auf Volumen-Objekte eingeht,
wird dieser Modifier nicht weiter behandelt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_26_Icon_Volume_to_Mesh-Modifier.png}

\caption{\label{fig-1_26}Icon fÃ¼r den Volume-to-Mesh-Modifier.}

\end{figure}%

\subsubsection{Weld}\label{weld}

\marginnote{Merge by Distance mittels Weld-Modifier}

Der Weld-Modifier stellt die Funktion Â«\emph{Merge by Distance}Â» als
Modifier dar. Dabei werden alle Vertices, die nahe beieinanderliegen, zu
einem Vertex zusammen gefasst. In den Einstellungen zum Weld-Modifier
kann unter Â«\emph{Distance}Â» festgelegt werden, bis zu welcher Distanz
die Vertices zusammengefasst werden sollen. Zudem kann unter
Â«\emph{Mode}Â» festgelegt werden, ob berÃ¼cksichtigt werden soll, ob dies
nur auf miteinander verbundene Vertices (Â«\emph{Connected}Â») oder alle
Vertices (Â«\emph{All}Â») angewendet werden soll.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_27_Icon_Weld_Modifier.png}

\caption{\label{fig-1_27}Icon fÃ¼r den Weld-Modifier.}

\end{figure}%

\subsubsection{Wireframe}\label{wireframe}

\marginnote{GerÃ¼st um Mesh mittels Wireframe-Modifier}

Mithilfe des Wireframe-Modifiers werden die FlÃ¤chen anhand eines
GerÃ¼stes dargestellt. Die Edges der Faces werden hierfÃ¼r aufgehoben und
mit vier Faces ersetzt, die entlang der Edges miteinander verbunden
werden. Die ursprÃ¼nglichen Faces werden zusÃ¤tzlich ebenfalls aufgehoben.
Der Wireframe-Modifier bezieht sich dabei lediglich auf die Faces:
Einzelne Edges, die nicht Teil eines Faces sind, werden dadurch entfernt
und nicht im GerÃ¼st mit aufgenommen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_28_Icon_Wireframe_Modifier.png}

\caption{\label{fig-1_28}Icon fÃ¼r den Wireframe-Modifier.}

\end{figure}%

\marginnote{GerÃ¼st anpassen}

Unter dem Reiter Â«\emph{Thickness}Â» in den Einstellungen zum
Wireframe-Modifier lÃ¤sst sich einstellen, wie gross das GerÃ¼st, welches
um die Edges herum gebildet wird, sein soll. Durch den
Wireframe-Modifier wird das originale Objekt per Default durch das
GittergerÃ¼st ersetzt. Dies kann jedoch in den Einstellungen zum
Wireframe-Modifier unter Â«\emph{Replace Original}Â» deaktiviert werden,
sodass das originale Objekt nebst dem GerÃ¼st bestehen bleibt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_29_Example_Triangulated Wireframe.png}

\caption{\label{fig-1_29}WÃ¼rfel mit Triangulate- und
Wireframe-Modifier.}

\end{figure}%

Ãœbung 10: Modifier

\textbf{Ãœbung 10.1}

Erstellen Sie eine Wasserflasche mittels Modifiern. Verwenden Sie dabei
so wenige Vertices wie mÃ¶glich.

\includegraphics{Chapters/Images/Chapter_14/Exercise_10_1.png}\hfill

\textbf{Ãœbung 10.2}

Erstellen Sie einen Gartenzaun mittels Modifiern. Verwenden Sie dabei so
wenige Vertices wie mÃ¶glich.

\includegraphics{Chapters/Images/Chapter_14/Exercise_10_2.png}\hfill

\section{Grenzen der Objektbearbeitung mittels
Modifiern}\label{grenzen-der-objektbearbeitung-mittels-modifiern}

\marginnote{Grenzen von Modifiern}

Wie beim Beispiel mit dem Glas zu erkennen ist, funktionieren Modifier
unter bestimmten UmstÃ¤nden nicht immer perfekt. Die Anwendung des
Subdivision-Surface-Modifiers auf einen Zylinder fÃ¼hrt beispielsweise
dazu, dass nicht nur der Mantel des Zylinders abgerundet wird, sondern
auch die Kanten zum Boden beziehungsweise Deckel des Zylinders. Dies
fÃ¼hrt dazu, dass der Zylinder seine Form verliert und eher einer Kugel
Ã¤hnelt. Der Boden und der Deckel des Zylinders stellen ein einzelnes
N-Gon dar. Durch die fehlenden Quads werden der Boden und der Deckel
somit in einer fehlerhaften Form abgerundet. In solchen FÃ¤llen macht die
Anwendung des Subdivision-Surface-Modifiers in dieser Form keinen Sinn.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_30_Cylinder_Subdivison_Surface_Modifier.png}

\caption{\label{fig-1_30}Ein Zylinder mit einem
Subdivision-Surface-Modifier im Edit-Mode.}

\end{figure}%

\marginnote{Abrundung verhindern}

Es gibt einige destruktive LÃ¶sungsansÃ¤tze, um die unerwÃ¼nschten Effekte
des Subdivision-Surface-Modifiers zu reduzieren. So kÃ¶nnen
beispielsweise zusÃ¤tzliche Loop Cuts (\kbd{Ctrl} + \kbd{R}) an den
Kanten hinzugefÃ¼gt werden, welche zu stark abgerundet werden. Dies fÃ¼hrt
dazu, dass Blender eine geringere LÃ¤nge zur VerfÃ¼gung hat, um Kanten
abzurunden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_31_Reduced_Smoothing_Loop_Cuts.png}

\caption{\label{fig-1_31}Reduzierte GlÃ¤ttung durch Loop Cuts.}

\end{figure}%

\marginnote{Abrundung von Tris/N-Gons verhindern}

Allerdings bleibt der Effekt einer ungenauen Abrundung entlang des
Deckels/Bodens bestehen. Um diesen Effekt zu reduzieren, kann das Face
des Deckels/Bodens ausgewÃ¤hlt und im Rahmen einer Extrusion kleiner
skaliert werden (Taste \kbd{E}, danach Taste \kbd{S}). Dadurch wird der
Ã¤usserste Rand des Deckels/Bodens mit Quads dargestellt, die gemeinsam
einen Kreis um ein paralleles N-Gon bilden (wie in Abbildung 32
dargestellt).

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_32_Quads_Smoothing_N_Gons.png}

\caption{\label{fig-1_32}Durch Quads am Rand wird das GlÃ¤tten des N-Gons
verhindert.}

\end{figure}%

\marginnote{ParallelitÃ¤t, um Abrundung zu verhindern}

Die kreisfÃ¶rmig angeordneten Quads liegen in diesem Beispiel nun
parallel zu dem N-Gon in der Mitte. Dadurch erÃ¼brigt sich eine GlÃ¤ttung
des N-Gons entlang seiner Edges. WÃ¼rde das N-Gon allerdings nicht
parallel verlaufen (z.B. wenn es weiter nach aussen gezogen wÃ¼rde, wie
in Abbildung 33), so wÃ¼rde das N-Gon wieder geglÃ¤ttet und eine
ungewollte Schraffierung entstÃ¼nde erneut.

\marginnote{Bearbeitung von Meshes trotz Modifiern notwendig}

Dieses Beispiel zeigt, dass die nicht-destruktive Bearbeitung mittels
Modifiern teilweise auch Anpassungen im Mesh erfordern. Zudem ist es
teilweise nÃ¶tig, dass Modifier auf ein Objekt angewendet werden, sodass
die Vertices, welche durch den Modifier entstehen, destruktiv
weiterbearbeitet werden kÃ¶nnen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_14/14_33_Smoothing_N_Gons.png}

\caption{\label{fig-1_33}GlÃ¤ttung des N-Gons entsteht wieder, wenn das
N-Gon nicht mehr parallel zu den umgebenden Quads liegt.}

\end{figure}%

\marginnote{Modifier auf Teilmengen des Meshes beschrÃ¤nken}

Es gibt allerdings auch noch LÃ¶sungsansÃ¤tze, damit Modifier nicht auf
alle Elemente eines Meshes angewendet werden, oder sogar unterschiedlich
stark auf unterschiedliche Elemente eines Meshes angewendet werden.
HierfÃ¼r wird im nÃ¤chsten Kapitel betrachtet, wie sich solche
Einstellungen fÃ¼r unterschiedliche Elemente innerhalb eines Meshes
einstellen lassen.

\chapter{Eigenschaften innerhalb eines Meshes
definieren}\label{eigenschaften-innerhalb-eines-meshes-definieren}

\section{Edge Crease}\label{edge-crease}

\marginnote{Subdivision-Surface-Modifier nicht auf alle Edges anwenden}

Im letzten Kapitel wurde gezeigt, wie der Effekt des
Subdivision-Surface-Modifiers reduziert werden kann. HierfÃ¼r wurde
erneut auf eine destruktive Bearbeitungsmethode zurÃ¼ckgegriffen. Es gibt
allerdings auch MÃ¶glichkeiten, um ohne eine destruktive Bearbeitung dem
Subdivision-Surface-Modifier mitzuteilen, dass er auf eine Anwendung an
bestimmten Stellen im Mesh verzichten soll. HierfÃ¼r wird der Edge Crease
verwendet.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_15/15_1_Use_Edge_Creases_N_Gons.png}

\caption{\label{fig-1_1}Anwendung des Edge Creases auf ein N-Gon des
Zylinders.}

\end{figure}%

\marginnote{Edge Crease}

Der Edge Crease stellt ein Merkmal dar, welches einem Edge hinzugefÃ¼gt
werden kann. Je hÃ¶her der Edge Crease, desto geringer die GlÃ¤ttung durch
den Subdivision-Surface-Modifier. Der Edge Crease kann dabei Werte von 0
(normale Anwendung des Modifiers) bis 1 (keine Anwendung des Modifiers)
annehmen. Auch Abstufungen dazwischen sind mÃ¶glich.

\marginnote{Edge Crease hinzufÃ¼gen}

Um Edges einen Edge Crease hinzuzufÃ¼gen, mÃ¼ssen sie zunÃ¤chst ausgewÃ¤hlt
werden. Anschliessend kann mittels der Tastenkombination \kbd{Ctrl} +
\kbd{E} das Â«\emph{Edge}Â»-MenÃ¼ beim Mauszeiger geÃ¶ffnet werden und
Â«\emph{Edge Crease}Â» ausgewÃ¤hlt werden. Mittels der Bewegung des
Mauszeigers oder durch die Eingabe einer Zahl kann anschliessend der
Faktor fÃ¼r den Edge Crease festgelegt werden. Im Edit-Mode wird die
StÃ¤rke eines Creases fÃ¼r ein Edge jeweils mit einer violetten Markierung
angegeben. Eine besonders starke violette Markierung des Edges weist auf
einen Edge Crease von 1 hin, eine fehlende Markierung auf einen Edge
Crease von 0. Alternativ kann der Edge-Crease auch direkt Ã¼ber die
Tastenkombination \kbd{Shift} + \kbd{E} bei ausgewÃ¤hlten Edges verÃ¤ndert
werden.

\marginnote{Edge Creases Ã¼ber die Sidebar einstellen}

Nebst der Einstellung Ã¼ber das Edge-MenÃ¼ kann der Edge Crease auch Ã¼ber
die Sidebar eingestellt werden. Unterhalb des Einstellungsfeldes fÃ¼r die
Position eines Vertex oder den Median der Auswahl befinden sich zwei
Felder fÃ¼r die Eingabe von Â«\emph{Edge Data}Â». Dort ist ein Feld fÃ¼r den
Crease des ausgewÃ¤hlten Edges zu finden. Wenn mehrere Edges ausgewÃ¤hlt
sind, wird der Mittelwert der Crease-Werte berechnet und an dieser
Stelle angezeigt. Durch das Ersetzen des Mittelwerts durch eine Zahl
wird der Crease proportional Ã¼ber die ausgewÃ¤hlten Elemente verÃ¤ndert,
sodass der Mittelwert diesem Wert entspricht. Durch die Eingabe von 0
werden generell alle Edge Creases bei der Auswahl entfernt und durch die
Eingabe von 1 werden generell alle Edge Creases bei der Auswahl
maximiert.

\marginnote{Edge Crease deaktivieren}

Per Default ist beim Subdivision-Surface-Modifier eingestellt, dass er
Edge Creases im Mesh berÃ¼cksichtigt. Dies kann allerdings in den
Einstellungen zum Modifier unter dem MenÃ¼ Â«\emph{Advanced}Â» unter
Â«\emph{Use Creases}Â» deaktiviert werden.

\section{Bevel Weight}\label{bevel-weight}

\marginnote{Edge Bevel Weight}

Nebst den Edge Creases, welche den Subdivision-Surface-Modifier steuern,
kÃ¶nnen die sogenannten Edge Bevel Weights verwendet werden, um den
Bevel-Modifier zu steuern. Bevel Weights kÃ¶nnen ebenfalls einen Wert von
0 bis 1 annehmen. Ein Wert von 0 steht allerdings fÃ¼r keine Anwendung
des Bevel-Modifiers und ein Wert von 1 fÃ¼r eine maximale Anwendung des
Bevel-Modifiers. Auch Abstufungen dazwischen sind mÃ¶glich.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_15/15_2_Stair_Bevel_Modifier.png}

\caption{\label{fig-1_2}Eine Treppe mit einem Bevel-Modifier.}

\end{figure}%

\marginnote{Edge Bevel Weight hinzufÃ¼gen}

Um einem Edge einen Bevel Weight hinzuzufÃ¼gen, muss das jeweilige Edge
ausgewÃ¤hlt werden. Anschliessend kann mit der Tastenkombination
\kbd{Ctrl} + \kbd{E} das Â«\emph{Edge}Â»-MenÃ¼ beim Mauszeiger geÃ¶ffnet
werden und Â«\emph{Edge Bevel Weight}Â» ausgewÃ¤hlt werden. Anschliessend
kann entweder mit einer Bewegung der Maus oder durch die Eingabe einer
Zahl der Edge Bevel Weight der Auswahl verÃ¤ndert werden. Im Edit-Mode
sind Edge Bevel Weights durch eine blaue farbliche Markierung entlang
der Edges ersichtlich. Je stÃ¤rker die blaue EinfÃ¤rbung, desto mehr
nÃ¤hert sich der Edge Bevel Weight dem Faktor 1 an. Bei keiner farblichen
Markierung betrÃ¤gt der Bevel Weight 0.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_15/15_3_Stair_Edge_Bevel_Weights.png}

\caption{\label{fig-1_3}Eine Treppe mit Edge Bevel Weights auf und
zwischen den Stufen und einem Bevel-Modifier, der auf Â«WeightÂ» limitiert
ist.}

\end{figure}%

\marginnote{Edge Bevel Weight im Viewport}

Wie auch der Edge Crease kann der Edge Bevel Weight in der Sidebar
eingestellt werden. HierfÃ¼r wird die Zeile Â«\emph{Bevel Weight}Â»
verwendet. Wie auch beim Crease lÃ¤sst sich hier der Mittelwert der
Auswahl proportional anpassen, respektive der Wert 0 oder 1 fÃ¼r die
gesamte Auswahl fixieren.

\marginnote{Modifier auf Bevel Weights einstellen}

Der Bevel-Modifier berÃ¼cksichtig die Edge Bevel Weights nicht in seinen
Default-Einstellungen. In ihm muss deshalb die Option Â«\emph{Limit
Method}Â» auf Â«\emph{Weigh}tÂ» umgestellt werden. Dadurch wird der
Modifier nur auf Edges mit Bevel Weights angewendet.

\marginnote{Vertex Bevel Weight}

Bevel Weights kÃ¶nnen auch auf einzelne Vertices angewendet werden.
HierfÃ¼r kÃ¶nnen ausgewÃ¤hlten Vertices in der Sidebar unter Â«\emph{Vertex
Data}Â» ein Bevel Weight hinzugefÃ¼gt werden. Vertex und Edge Bevel
Weights werden unabhÃ¤ngig voneinander zugeteilt und berechnet. Ein
Vertex, das Teil eines Edges mit einem Edge Bevel Weight von 1 ist, kann
einen anderen Vertex Bevel Weight aufweisen.

\marginnote{Modifier auf Vertex Bevel Weight einstellen}

Der Bevel-Modifier berÃ¼cksichtigt die Vertex Bevel Weights lediglich,
wenn er auf Â«\emph{Vertices}Â» eingestellt wurde. Auch in diesem Fall
muss die Â«\emph{Limit Method}Â» auf Â«\emph{Weight}Â» eingestellt werden.
Wenn sowohl die Edge Bevel Weights als auch die Vertex Bevel Weights
berÃ¼cksichtigt werden sollen, werden zwei Bevel-Modifier benÃ¶tigt: ein
Modifier fÃ¼r die Vertex Bevel Weights und ein Modifier fÃ¼r die Edge
Bevel Weights.

\section{Vertex Groups}\label{vertex-groups}

\marginnote{Limitierung von Modifiern auf einzelne Vertices}

Durch den Edge Crease und den Bevel Weight stehen MÃ¶glichkeiten zur
VerfÃ¼gung, um Elemente des Meshes graduell durch die Modifier bearbeiten
zu lassen. FÃ¼r die meisten anderen Modifier steht eine solche graduelle
Anwendung nicht zur VerfÃ¼gung. Es ist jedoch fÃ¼r sehr viele Modifier
mÃ¶glich, dass die Anwendung lediglich auf einzelne Vertices angewendet
wird. Dadurch ist zwar keine graduelle Abstufung des Modifiers Ã¼ber das
Mesh mÃ¶glich, allerdings eine Limitierung auf einzelne Vertices.

\marginnote{Vertex-Gruppen}

Im Edit-Mode kÃ¶nnen einzelne Vertices zu Gruppen zusammengefasst werden.
Solche Gruppen werden als Vertex Groups bezeichnet. Die Vertex-Gruppen
kÃ¶nnen Ã¼ber den Properties-Editor unter dem Reiter Â«\emph{Object Data
Properties}Â» anvisiert werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_15/15_4_Icon_Vertex_Group.png}

\caption{\label{fig-1_4}Icon des Â«\emph{Object Data Properties}Â»-Reiters
im Properties-Editor.}

\end{figure}%

\marginnote{Vertex-Gruppe erstellen}

Durch einen Klick auf die Â«+Â»-SchaltflÃ¤che unter dem Reiter
Â«\emph{Vertex Groups}Â» in den Object Data Properties wird anschliessend
eine neue Vertex-Gruppe hinzugefÃ¼gt, welche den Namen Â«GroupÂ» trÃ¤gt.
Dieser Name kann beliebig angepasst werden und sollte -- gerade wenn
viele Vertex-Gruppen erstellt werden -- klar ausdrÃ¼cken, welche Inhalte
diese Gruppe abdeckt.

\marginnote{Vertices zu Gruppen hinzufÃ¼gen}

Wenn eine neue Vertex-Gruppe hinzugefÃ¼gt wird, beinhaltet diese zunÃ¤chst
keine Vertices. Diese mÃ¼ssen der neu erstellten Gruppe hinzugefÃ¼gt
werden. HierfÃ¼r werden im Edit-Mode die entsprechenden Vertices
ausgewÃ¤hlt und anschliessend die SchaltflÃ¤che Â«\emph{Assign}Â» unterhalb
der Auflistung der Vertex-Gruppen betÃ¤tigt. Dadurch werden der
Vertex-Gruppe die ausgewÃ¤hlten Vertices hinzugefÃ¼gt. Analog kÃ¶nnen
mittels der SchaltflÃ¤che Â«\emph{Remove}Â» Vertices von bestehenden
Vertex-Gruppen entfernt werden.

\marginnote{Vertices mittels Vertex-Gruppen an- und abwÃ¤hlen}

Vertex-Gruppen sind auch nÃ¼tzlich, um einzelne Vertices schnell
auswÃ¤hlen zu kÃ¶nnen. HierfÃ¼r mÃ¼ssen diese einer Vertex-Gruppe zugewiesen
werden. Anschliessend kann diese Vertex-Gruppe markiert werden und
mittels der SchaltflÃ¤che Â«\emph{Select}Â» werden die Vertices, welche zu
dieser Auswahl gehÃ¶ren, im Objekt ausgewÃ¤hlt. Analog kÃ¶nnen mittels der
SchaltflÃ¤che Â«\emph{Deselect}Â» die Vertices einer Vertex-Gruppe von der
aktuellen Auswahl abgewÃ¤hlt werden.

\marginnote{Vertex-Gruppen sperren}

Es ist ausserdem mÃ¶glich, bestehende Vertex-Gruppen zu sperren, sodass
keine weiteren Vertices der Vertex-Gruppe hinzugefÃ¼gt oder von ihr
entfernt werden kÃ¶nnen. In der Auflistung der Vertex-Gruppen ist auf der
rechten Seite jeweils ein Schloss zu finden. Durch das Aktivieren dieses
Schlosses wird diese Vertex-Gruppe gesperrt. Dadurch wird verhindert,
dass aus Versehen neue Vertices der Gruppe hinzugefÃ¼gt oder von ihr
entfernt werden.

\marginnote{Vertex-Gruppen zu Modifiern hinzufÃ¼gen}

Bei vielen Modifiern lassen sich innerhalb der Einstellungen
Vertex-Gruppen in einer Zeile mit der Beschriftung Â«\emph{Vertex Group}Â»
auswÃ¤hlen. Wenn eine Vertex-Gruppe fÃ¼r ein Objekt definiert wurde, wird
diese anschliessend auswÃ¤hlbar fÃ¼r dieses Feld. Dadurch kÃ¶nnen die
entsprechenden Modifier auf diese Vertex-Gruppen beschrÃ¤nkt werden.
Beispielsweise kann der Bevel-Modifier statt mit Bevel Weights auch mit
Vertex-Gruppen auf einzelne Edges oder Vertices reduziert werden.

Ãœbung 11: Objekterstellung mit Mesh-Daten

\textbf{Ãœbung 11.1}

VerÃ¤ndern Sie den StandardwÃ¼rfel mittels Modifiern und Mesh-Daten so,
dass das unten abgebildete Objekt dargestellt wird.

\hfill
\includegraphics{Chapters/Images/Chapter_15/Exercise_11_1.png}

\textbf{Ãœbung 11.2}

Erstellen Sie mittels Modifiern das unten abgebildete Objekt.

\hfill
\includegraphics{Chapters/Images/Chapter_15/Exercise_11_2.png}

\chapter{Materialien, Texturen und
Shader}\label{materialien-texturen-und-shader}

\marginnote{Fokus auf Materialien}

Bislang lag der Fokus dieses Kurses auf der Erstellung von Objekten. Die
Objekte haben sich lediglich in ihrer Form unterschieden, aber nicht
hinsichtlich des Materials, aus dem sie bestehen. Im nÃ¤chsten Schritt
wird die Bedeutung der Materialien behandelt, welche Mechanismen diesen
zugrunde liegen und wie diese auf Objekte angewendet werden.

\marginnote{Material}

\begin{itemize}
\tightlist
\item
  In den nÃ¤chsten Kapiteln werden daher drei Begriffe von grosser
  Bedeutung sein: Materialien, Texturen und Shader. Beim Material
  handelt es sich dabei um ein Merkmal, welches einem Objekt oder einem
  Teil des Objektes zugewiesen wird. Das Material beschreibt sowohl, was
  auf der OberflÃ¤che des Objektes (oder in dessen Volumen) abgebildet
  wird, als auch, wie dies dargestellt wird.
\end{itemize}

\marginnote{Parameter}

\begin{itemize}
\tightlist
\item
  Innerhalb des Materials wird eine Reihe verschiedener Parameter
  festgelegt, um eine Vielfalt an Materialien abdecken zu kÃ¶nnen. Diese
  Parameter kÃ¶nnen etwa die Farbe des Materials, aber auch Merkmale der
  Lichtreflexion beinhalten. Solche Parameter kÃ¶nnen einheitlich Ã¼ber
  das ganze Material angewendet werden (z.B. das ganze Material ist
  Ã¼berall rot und reflektiert Ã¼berall gleich stark), oder strukturell
  variieren (z.B. das Material stellt eine rote Mauer mit weissen Fugen
  dar -- dabei weisen die Fugen eine andere Farbe auf und haben
  allenfalls auch eine andere Reflexion).
\end{itemize}

\marginnote{Texturen}

\begin{itemize}
\tightlist
\item
  Um Parameter Ã¼ber FlÃ¤chen hinweg variieren zu kÃ¶nnen, werden Texturen
  benÃ¶tigt. Texturen sind Bilddokumente, welche dem Material zugwiesen
  werden und dadurch auch dem Objekt zugewiesen werden kÃ¶nnen. Eine
  Textur als solche wird jedoch nicht direkt auf ein Objekt angewendet,
  sondern als Material. Die wohl bekannteste Form der Texturen
  beschreibt, wie sich die Farbe des Materials Ã¼ber die FlÃ¤che des
  Objektes verÃ¤ndert. Allerdings kÃ¶nnen Texturen auch verwendet werden,
  um andere Parameter Ã¼ber die FlÃ¤che hinweg zu variieren.
\end{itemize}

\marginnote{Shader}

Shader stellen Verarbeitungseinheiten der Parameter/Texturen dar. Sie
bekommen Informationen aus den Parametern oder Texturen und verarbeiten
diese weiter. Ein Emission-Shader nimmt beispielsweise jeweils die
Parameter fÃ¼r die Farbe und strahlt diese um den Wert eines weiteren
Parameters aus. Andere Shader berÃ¼cksichtigen zusÃ¤tzlich das Licht aus
der Umgebung und verarbeiten die Parameter und Texturen in AbhÃ¤ngigkeit
dieser Lichtquellen oder unter BerÃ¼cksichtigung weiterer Parameter.

\marginnote{Materialien, Texturen und Shader}

Ein Material beinhaltet somit sowohl Parameter oder Texturen, welche
Informationen beinhalten, als auch die Shader, welche die Informationen
verarbeiten. Blender ist mit einer Reihe von eigenen Shadern
ausgestattet, mit denen man arbeiten kann. Es ist allerdings auch
mÃ¶glich, eigene Shader zu erstellen oder die Verarbeitung der
Informationen zu verÃ¤ndern.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_16/16_1_Materials_Textures_Shader.png}

\caption{\label{fig-1_1}Zusammenhang zwischen Materialien, Texturen und
Shadern.}

\end{figure}%

\chapter{Materialien}\label{materialien}

\section{Bedeutung von Materialien}\label{bedeutung-von-materialien}

\marginnote{Wozu werden Materialien benÃ¶tigt?}

In den bisherigen Ãœbungen und Aufgaben wurden jeweils Objekte erstellt
und es war klar, was diese Objekte darstellen. Ein Haus stellte anhand
seiner geometrischen Figur ein Haus dar, ebenso verhielt es sich bei
einem Koffer oder auch bei einem Glas. Doch gerade beim Glas kann die
Wahrnehmung des Objektes erheblich durch dessen Material beeinflusst
werden.

\marginnote{Was stellt das Objekt dar?}

Zur Veranschaulichung: Das Bild in Abbildung 1 stellt dar, wie Objekte
bislang in diesem Kurs betrachtet wurden. Die OberflÃ¤che war fÃ¼r alle
Objekte identisch, sodass zumindest erkennbar war, dass eine OberflÃ¤che
vorhanden ist. FÃ¼r eine aussenstehende Person muss nicht zwingen klar
sein, dass es sich bei diesem Objekt um ein Glas handelt. Es kÃ¶nnte sich
auch um einen Becher handeln, der aus Plastik besteht, oder allenfalls
um einen Pappbecher. Abbildung 2 zeigt mÃ¶gliche Interpretationsbeispiele
fÃ¼r dieses Objekt auf. Alle diese Beispiele zeigen dasselbe Mesh mit
denselben Vertices, Edges und Faces. Sie unterscheiden sich allerdings
hinsichtlich der ihnen hinzugefÃ¼gten Materialien.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_17/17_1_Glass_without_Materials.png}

\caption{\label{fig-1_1}Ein Objekt im Solid-Shading-Modus.}

\end{figure}%

\marginnote{Objekt-Benennung durch Materialien}

Durch die Anwendung von Materialien kann also die Wahrnehmung der
Objekte verÃ¤ndert werden. Ein Glas erscheint als Glas, weil es eine
gewisse Transparenz aufweist. Andere Materialien verfÃ¼gen Ã¼ber
unterschiedliche Farben und kÃ¶nnen so voneinander abgegrenzt werden.
HierfÃ¼r gibt es verschiedene Merkmale der Materialien, welche noch
ausfÃ¼hrlich beschrieben werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_17/17_2_Glass_or_Mug.png}

\caption{\label{fig-1_2}Ein Objekt mit unterschiedlichen Materialien.}

\end{figure}%

\section{Materialien betrachten}\label{materialien-betrachten}

\marginnote{Viewport-Shading-Modus wechseln}

Damit Materialien betrachtet werden kÃ¶nnen, ist ein Wechsel in der
BenutzeroberflÃ¤che in Blender nÃ¶tig. Bislang wurden Objekte im
Solid-Viewport-Shading-Modus betrachtet. In diesem Modus werden die
Materialien von Objekten nicht fÃ¼r die Darstellung berÃ¼cksichtigt. Um
die Materialien ebenfalls betrachten zu kÃ¶nnen, wird deshalb ein
Viewport-Shading-Modus benÃ¶tigt, der die Materialien ebenfalls
darstellt. HierfÃ¼r kann der Material-Preview-Modus oder der
Render-Preview-Modus verwendet werden. Beide Einstellungen sind in der
rechten oberen Ecke des Viewport-Displays anwÃ¤hlbar. Durch das DrÃ¼cken
der Taste \kbd{Z} erscheint zudem bei der Maus ein Kontext-MenÃ¼, welches
die verschiedenen Modi zur schnellen Auswahl anbietet.

\marginnote{Material-Preview-Modus verwenden}

Zum jetzigen Zeitpunkt des Kurses ist der Render-Preview-Modus noch
nicht zu empfehlen. Dieser Modus berÃ¼cksichtigt die Lichtquellen und
Lichtreflexionen, welche in der Welt dargestellt werden. Dadurch ist es
teils schwer abzuschÃ¤tzen, ob Probleme im Material auf dem Material oder
der umgebenden Beleuchtung beruhen. Deshalb wird an dieser Stelle der
Material-Preview-Modus verwendet. Dieser stellt die Materialien dar und
liefert vorgefertigte Beleuchtungsszenarien fÃ¼r die Welt.

\marginnote{Material-Preview-Modus}

Durch einen Klick auf die SchaltflÃ¤che fÃ¼r den Material-Preview-Modus
verÃ¤ndert sich die Darstellung der OberflÃ¤che der Meshes. Blender
generiert die Materialien, welche dem Mesh zugewiesen sind, und
prÃ¤sentiert diese basierend auf den Einstellungen der Welt -- in diesem
Fall basierend auf den Einstellungen der Vorschau-Welt.

\section{Materialien hinzufÃ¼gen}\label{materialien-hinzufuxfcgen}

\marginnote{Default-Material}

Jedes Objekt wird im Material-Preview-Modus und im Render-Modus mit
einem Material dargestellt. In einer neuen Szene verfÃ¼gt der
StandardwÃ¼rfel bereits Ã¼ber ein vorgegebenes Material, welches
abgeÃ¤ndert werden kann. Ein neu in die Szene hinzugefÃ¼gtes Objekt wird
ebenfalls mit einem Material dargestellt. Im Gegensatz zum
StandardwÃ¼rfel ist dieses Objekt aber eigentlich noch nicht mit einem
Material ausgestattet.

\marginnote{Material-Reiter}

Um das Material eines Objektes aufzurufen, kann der Material-Reiter im
Properties-Editor aufgerufen werden. Unter diesem Reiter werden die
Materialien des aktiven Objektes aufgelistet. Wenn mehrere Objekte
ausgewÃ¤hlt sind, werden nur die Materialien des aktiven Objekts
dargestellt. Die Materialien sind unabhÃ¤ngig davon ersichtlich, ob
aktuell der Object- oder der Edit-Mode ausgewÃ¤hlt ist.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_17/17_3_Material_Properties_Pannel.png}

\caption{\label{fig-1_3}Das Properties-Panel mit dem ausgewÃ¤hlten
Material-Reiter.}

\end{figure}%

\marginnote{Fehlendes Material}

Wenn ein Objekt noch Ã¼ber kein Material verfÃ¼gt, ist der Material-Reiter
noch leer. Es gibt lediglich folgende Bereiche:

\begin{itemize}
\tightlist
\item
  \textbf{Leeres Feld}: Darin werden alle Slots fÃ¼r die Materialien
  eines Objekts aufgelistet.
\item
  Â«\textbf{+}Â»: Dadurch lÃ¤sst sich ein neuer Slot fÃ¼r Materialien
  erstellen.
\item
  Â«\textbf{-}Â»: Dadurch lÃ¤sst sich ein ausgewÃ¤hlter Slot fÃ¼r Materialien
  entfernen.
\item
  Â«\textbf{\emph{New}}Â»: Dadurch lÃ¤sst sich ein neues Material
  erstellen.
\end{itemize}

\marginnote{Slots fÃ¼r Materialien}

Wenn nun die SchaltflÃ¤che Â«+Â» betÃ¤tigt wird, erscheint ein neuer
Material-Slot fÃ¼r ein Material in dem Feld, welches vorher leer war.
Wichtig ist dabei, dass dies lediglich einen Platzhalter fÃ¼r ein
Material darstellt -- es wurde noch kein Material hinzugefÃ¼gt. Durch das
erneute Klicken der Taste Â«+Â» erscheint ein weiterer Slot fÃ¼r
Materialien. Durch das BetÃ¤tigen der Taste Â«-Â» wird dieser Slot wieder
entfernt.

\marginnote{Neues Material erstellen}

Durch das DrÃ¼cken der SchaltflÃ¤che Â«\emph{New}Â» wird ein neues Material
erstellt. Dieses neue Material wird mit der Beschriftung
Â«\emph{Material}Â», und allenfalls gefolgt von einer Nummer hinter der
Bezeichnung, an der Stelle angezeigt, an der sich vorher die
SchaltflÃ¤che Â«\emph{New}Â» befunden hat. ZusÃ¤tzlich wird das Material nun
in der Auflistung der Materialien im darÃ¼berliegenden Feld angezeigt.
Durch das HinzufÃ¼gen eines Materials wird automatisch ein Slot erstellt,
selbst wenn die Auflistung der Slots noch leer war. Wenn ein Slot
vorhanden ist, dieser aber noch leer ist, wird das Material diesem Slot
hinzugefÃ¼gt.

\marginnote{Materialien ausdemselben Dokument wieder verwenden}

Statt ein neues Material zu erstellen, kÃ¶nnen auch Materialien, die
bereits in demselben Blender-Dokument erstellt wurden, dem Material-Slot
zugewiesen werden. HierfÃ¼r muss statt auf die SchaltflÃ¤che Â«\emph{New}Â»
auf das Dropdown-MenÃ¼ links dieser SchaltflÃ¤che geklickt werden. Darin
werden alle Materialien aufgefÃ¼hrt, die bereits in diesem Dokument
vorhanden sind. Durch die Auswahl eines dieser Materialien wird dieses
Material anschliessend auch auf das Objekt angewendet. Dabei ist
allerdings zu beachten, dass dadurch keine Kopie des Materials erstellt
wird. Wird das Material etwa auch von einem anderen Objekt verwendet, so
fÃ¼hrt eine VerÃ¤nderung des Materials auch bei diesem Objekt zu einer
VerÃ¤nderung.

\marginnote{Einstellungsoptionen der Materialien}

Durch die Auswahl oder die Erstellung eines Materials erscheint eine
Reihe von Einstellungsoptionen innerhalb des Material-Reiters. Diese
sind in folgende Bereiche gegliedert:

\begin{itemize}
\tightlist
\item
  Â«\textbf{\emph{Preview}}Â»: Darin wird eine Vorschau des Materials fÃ¼r
  verschiedene Objektarten angeboten.
\item
  Â«\textbf{\emph{Surface}}Â»: Darin werden die grundlegenden
  Einstellungen der OberflÃ¤chenbeschaffenheit des Materials vorgenommen.
\item
  Â«\textbf{\emph{Volume}}Â»: Darin kÃ¶nnen Eigenschaften fÃ¼r das Volumen
  des Materials definiert werden.
\item
  Â«\textbf{\emph{Settings}}Â»: Darin kÃ¶nnen weitere Einstellungen fÃ¼r die
  Darstellung des Materials vorgenommen werden.
\item
  Â«\textbf{\emph{Line Art}}Â»: Darin kÃ¶nnen Parameter fÃ¼r die Erstellung
  von Linien eingestellt werden, wenn die Erstellung von Linien
  aktiviert ist.
\item
  Â«\textbf{\emph{Viewport Display}}Â»: Darin kÃ¶nnen grundlegende
  Material-Eigenschaften fÃ¼r die Darstellung des Materials im
  Solid-Modus erstellt werden. Diese Eigenschaften dienen lediglich der
  Zurechtfindung im Solid-Modus und haben keinen Einfluss auf die
  Darstellung des Materials im finalen, gerenderten Produkt.
\item
  Â«\textbf{\emph{Custom Properties}}Â»: Darin kÃ¶nnen eigene Eigenschaften
  fÃ¼r ein Material definiert werden. Eine grosse Bedeutung kommt den
  Einstellungsoptionen im Reiter Â«\emph{Surface}Â» zu. Diese werden
  fortan benÃ¶tigt, um die Materialien zu bearbeiten, wÃ¤hrend die anderen
  Optionen noch nicht berÃ¼cksichtigt werden.
\end{itemize}

\marginnote{Use Nodes}

Im Reiter Â«\emph{Surface}Â» wird zuoberst die SchaltflÃ¤che Â«\emph{Use
Nodes}Â» blau eingefÃ¤rbt dargestellt. Dies bedeutet, dass die Einstellung
der OberflÃ¤che innerhalb des Shader-Editors bearbeitet werden kann. Die
meisten der Einstellungen im Material-Reiter kÃ¶nnen in diesem Editor
erfolgen. Zudem bietet dieser Editor eine Reihe MÃ¶glichkeiten, um die
Materialien noch genauer zu bearbeiten. Deshalb ist es empfehlenswert,
den Shader-Editor zu verwenden.

\chapter{Der Shader-Editor}\label{der-shader-editor}

\marginnote{Shader-Editor Ã¶ffnen}

Um den Shader-Editor zu Ã¶ffnen, sollte ein neues, zusÃ¤tzliches
Editor-Fenster geÃ¶ffnet werden. Dieses kann aus den Ecken des
3D-Viewport-Editors herausgezogen werden. In diesem neuen Fenster kann
anschliessend der 3D-Viewport-Editor zum Shader-Editor geÃ¤ndert werden.

\marginnote{Auswahl von Materialien im Shader-Editor}

Im Shader-Editor wird jeweils mittels einer grafischen
Programmiersprache durch die Verbindung von Nodes (Knotenpunkten)
definiert, wie die Materialien erstellt werden. In der Kopfleiste des
Editors wird zudem dasselbe Feld zum AuswÃ¤hlen respektive zum HinzufÃ¼gen
von Materialien angezeigt wie im Material-Reiter im Properties-Editor.
Die Auswahl eines anderen Materials im Shader-Editor fÃ¼hrt dazu, dass
auch das Material im Properties-Editor sowie im Material-Slot
automatisch angepasst wird. Umgekehrt fÃ¼hrt eine andere Auswahl eines
Materials im Properties-Editor dazu, dass im Shader-Editor automatisch
auch das entsprechende Material ausgewÃ¤hlt wird.

\marginnote{Darstellung eines Default-Materials im Shader-Editor}

Sofern ein Material ausgewÃ¤hlt ist, sollten sich innerhalb des
Shader-Editors zwei BlÃ¶cke befinden. Ein etwas grÃ¶sserer Block, welcher
mit Â«\emph{Principled BSDF}Â» beschrieben ist, und ein kleinerer Block,
der als Â«\emph{Material Output}Â» beschriftet ist, wie in Abbildung 1
dargestellt. Beide BlÃ¶cke sind zwischen zwei grÃ¼nen Punkten mittels
eines Fadens miteinander verbunden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_18/18_1_Default_Material.png}

\caption{\label{fig-1_1}Ein Principled-BSDF-Shader, der mit dem
Material-Output verbunden ist. Dies wird standardmÃ¤ssig bei einem neuen
Material erstellt.}

\end{figure}%

\marginnote{Nodes}

Bei dieser Darstellung handelt es sich um eine Anordnung im Rahmen einer
visuellen Programmiersprache, die mit Nodes arbeitet. Jeder der BlÃ¶cke
stellt einen Node dar. Auf der linken und der rechten Seite dieser Nodes
sind in der Regel Punkte abgebildet. Dabei handelt es sich um Inputs und
Outputs, welche die Nodes erhalten und versenden kÃ¶nnen. Auf der linken
Seite sind jeweils die Inputs aufgelistet und auf der rechten Seite die
Outputs.

\marginnote{Nodes verbinden}

Wenn mit der linken Maustaste auf einen Input oder Output gedrÃ¼ckt wird
und der Mauszeiger anschliessend bei gedrÃ¼ckt gehaltener linker
Maustaste wegbewegt wird, folgt ein Faden vom Input/Output zum
Mauszeiger. Wenn nun ein Input/Output eines anderen Nodes angesteuert
wird und die linke Maustaste Ã¼ber diesem Input/Output losgelassen wird,
kÃ¶nnen zwei Nodes verbunden werden. Dabei ist allerdings zu beachten,
dass Inputs den Output eines anderen Nodes erhalten mÃ¼ssen. Ein Output
kann nicht mit einem Output verbunden werden und ein Input nicht mit
einem Input.

\marginnote{Verbindung zwischen Principled-BSDF-Shader und Material-Output}

Zwischen dem Principled-BSDF-Node und dem Material-Output-Node sind
somit nur drei Verbindungen mÃ¶glich:

\begin{itemize}
\tightlist
\item
  Â«BSDFÂ»-Output zu Â«SurfaceÂ»
\item
  Â«BSDFÂ»-Output zu Â«VolumeÂ»
\item
  Â«BSDFÂ»-Output zu Â«DisplacementÂ»
\end{itemize}

Die Verbindung von Â«\emph{BSDF}Â»-Output zu Â«\emph{Displacement}Â» fÃ¼hrt
allerdings dazu, dass der Faden rot eingefÃ¤rbt ist. Damit signalisiert
Blender, dass es sich um eine unzulÃ¤ssige Verbindung zweier Punkte
handelt. In diesem Beispiel wurde ein Shader mit einem Vektor verbunden.

\marginnote{Informationsarten im Shader-Editor}

Die Farbe der Inputs/Outputs von Nodes beschreibt jeweils, welche Art
von Informationen an dieser Stelle Ã¼bermittelt wird. Die Farben sind
folgende:

\begin{itemize}
\tightlist
\item
  \textbf{GrÃ¼n}: Shader
\item
  \textbf{Gelb}: Farben
\item
  \textbf{Blau}: Vektoren/Normalen
\item
  \textbf{Grau}: Faktoren
\end{itemize}

\begin{figure}

\includegraphics{Chapters/Images/Chapter_18/18_2_Input_Output_Pointmap.png}

\caption{\label{fig-2_2}Darstellung der Inputs und Outputs sowie der
verschiedenen Informationsarten anhand des Principled-BSDF-Shaders.}

\end{figure}%

\marginnote{Shader kÃ¶nnen nur mit Shadern verbunden werden}

Die Verbindung zwischen Inputs und Outputs verschiedener Farben ist
mÃ¶glich und teilweise auch nÃ¶tig. Es gibt allerdings eine Ausnahme:
Shader-Outputs (grÃ¼ne Punkte rechts) kÃ¶nnen nur mit Shader-Inputs (grÃ¼ne
Punkte links) verbunden werden. Aus diesem Grund lehnt Blender die
Verbindung zwischen dem Â«BSDFÂ»-Output und dem Â«DisplacementÂ»-Input ab.

\marginnote{Principled-BSDF ist ein Shader}

Der Principled-BSDF verfÃ¼gt lediglich Ã¼ber den Shader-Output. Dies liegt
daran, dass es sich beim Principled-BSDF um einen Shader handelt. Dies
wird mit einer grÃ¼nen Markierung in der Kopfzeile des Nodes markiert.
Dieser sollte somit lediglich mit einem Shader-Input verbunden werden.
Wenn eine Verbindung mit einer anderen Art von Input vorgenommen wird,
so wird der Verbindungsfaden zwischen den Nodes in roter Farbe
dargestellt, um auf die fehlerhafte Verbindung hinzuweisen.

\chapter{Grundlegende Eigenschaften von
Materialen}\label{grundlegende-eigenschaften-von-materialen}

\marginnote{Grundlegende Eigenschaften von Materialien}

Viele Materialien bestehen in ihren wichtigsten Grundkomponenten aus
drei Merkmalen, welche teilweise auch in den verschiedenen Shadern
wiederzufinden sind. Bei diesen Eigenschaften handelt es sich um:

\begin{itemize}
\tightlist
\item
  \textbf{Farbe}: In welcher Farbe ist das Objekt eingefÃ¤rbt?
\item
  \textbf{Roughness}: Wie glatt/rau ist das Objekt?
\item
  \textbf{Dielektrisch vs.~metallisch}: Stellt das Objekt ein Metall
  dar, oder nicht?
\end{itemize}

\section{Farbe}\label{farbe}

\marginnote{MÃ¶glichkeiten zur Farbauswahl}

Im Principled-BSDF-Shader wird die Farbe mittels der Einstellung
Â«\emph{Base Color}Â» eingestellt. Durch einen Klick auf die FarbflÃ¤che
nebst der Anschrift Â«\emph{Base Color}Â» erscheint ein MenÃ¼, mit dem sich
die Farbe auswÃ¤hlen lÃ¤sst. Es gibt insgesamt sechs MÃ¶glichkeiten, um
eine Farbe auszuwÃ¤hlen:

\begin{itemize}
\tightlist
\item
  Von Hand
\item
  Ãœbertragen von Farben mittels Eyedropper (Pipette)
\item
  Mittels RGB-Werten
\item
  Mittels HSV-Werten
\item
  Mittels hexadezimaler Farbdefinition
\item
  Farbe einer anderen Farbbox hineinziehen
\end{itemize}

\subsection{Farbauswahl von Hand}\label{farbauswahl-von-hand}

\marginnote{Farbauswahl von Hand}

Die Farbauswahl von Hand erfolgt, indem eine Farbe innerhalb des
Farbkreises mittels eines Klicks ausgewÃ¤hlt wird. Dadurch kÃ¶nnen alle
FarbtÃ¶ne ausgewÃ¤hlt werden. Mittels des Schiebereglers auf der rechten
Seite lÃ¤sst sich zudem die Helligkeit der Farbe anpassen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_19/19_1_Color_Choice.png}

\caption{\label{fig-1_1}FarbauswahlmenÃ¼s in Blender. Hier am Beispiel
der Base-Color im Principled-BSDF-Shader.}

\end{figure}%

\subsection{Ãœbertragen von Farben mittels
Eyedropper}\label{uxfcbertragen-von-farben-mittels-eyedropper}

\marginnote{Eyedropper}

Im rechten unteren Bereich der Farbauswahl ist eine SchaltflÃ¤che fÃ¼r den
Eyedropper zu finden. Dadurch kÃ¶nnen Farben innerhalb der Blender-Szene
oder BenutzeroberflÃ¤che anvisiert werden und als Farbe fÃ¼r die
Base-Color verwendet werden. Durch einen Klick auf die SchaltflÃ¤che
nimmt der Mauszeiger die Form des Eyedropper-Icons an. Anschliessend
kann an eine beliebige Position innerhalb von Blender geklickt werden
und die an dieser Stelle angezeigte Farbe wird verwendet.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_19/19_2_Icon_Eyedropper.png}

\caption{\label{fig-1_2}Eyedropper-Icon.}

\end{figure}%

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Die Farben von Objektmaterialien im 3D-Viewport stimmen selten mit den eingestellten Farben im Shader-Editor Ã¼berein. Dies liegt daran, dass bei der Darstellung von Materialien weitere Aspekte wie beispielsweise die Reflexion der Umgebungsbeleuchtung berÃ¼cksichtigt werden. Dadurch durchlÃ¤uft die Base-Color einen Verarbeitungsprozess. Wenn der Eyedropper also auf ein im 3D-Viewport-Editor dargestelltes Objekt angewendet wird, entspricht die ausgewÃ¤hlte Farbe nicht zwingend derselben Base-Color des Objektes, welches diese Farbe aussendet.
\end{tipp}

\section{RGB-Werte}\label{rgb-werte}

\marginnote{RGB}

Unter dem Reiter Â«\emph{RGB}Â» werden die ausgewÃ¤hlten Farbwerte mittels
des RGB-Farbraums dargestellt. RGB steht fÃ¼r Rot, GrÃ¼n und Blau. Diese
drei Farben stellen die Grundfarben im RGB-Farbraum dar. Durch die
Vermischung der Farbanteile dieser drei Farben kÃ¶nnen alle Farben des
Farbspektrums abgebildet werden.

\marginnote{RGB-Werte}

Blender geht bei der Verwendung der RGB-Farbwerte einen speziellen Weg.
Normalerweise werden RGB-Farbwerte mit Zahlen von 0 bis 255 angegeben.
Eine komplett rote Farbe hÃ¤tte somit die Werte 255-0-0. Dabei ist der
Wert fÃ¼r die rote Grundfarbe maximiert und die Werte fÃ¼r die anderen
Farben minimiert. Analog dazu wÃ¼rden fÃ¼r eine komplett grÃ¼ne Farbe die
Werte 0-255-0 und fÃ¼r eine komplett blaue Farbe die Werte 0-0-255
verwendet. FÃ¼r Schwarz sind alle Werte minimiert (0-0-0) und fÃ¼r Weiss
sind alle Werte maximiert (255-255-255).

\marginnote{RGB-Werte in Blender}

In Blender wird der Anteil der Grundfarben allerdings nicht von 0 bis
255 angegeben, sondern Ã¼ber Dezimalstellen von 0 bis 1. Eine komplett
rote Farbe wÃ¼rde in diesem Fall den Code 1-0-0 darstellen. HierfÃ¼r
mÃ¼sste dementsprechend der Slider im Â«\emph{RGB}Â»-Reiter in der Zeile
Â«\emph{R}Â» auf 1 gestellt werden und die Slider fÃ¼r die Zeilen
Â«\emph{G}Â» und Â«\emph{B}Â» auf 0. Alternativ kann in den entsprechenden
Zeilen auch direkt die genaue Zahl mit der Tastatur eingegeben werden.

\marginnote{Helligkeit der Farben}

Der Farbanteil, welcher den hÃ¶chsten Anteil innehat, definiert durch die
HÃ¶he seines Anteils die Helligkeit der Farben. Bei einer roten Farbe mit
dem Code 1-0-0 wird die hellste Farbe verwendet. Wenn der Rot-Anteil
reduziert wird (z.B. 0.5-0-0) verdunkelt sich auch die Farbe. Wenn
hingegen eine gelbe Farbe mit dem Code 1-1-0 eingestellt ist und der
rote Farbanteil reduziert wird (z.B. 0.5-1-0) hat die Farbe immer noch
dieselbe Helligkeit inne, lediglich der Anteil Rot an dieser Farbe wird
reduziert. Um generell eine dunklere Farbe zu erhalten, mÃ¼sste auch der
GrÃ¼n-Anteil bei dieser Farbmischung reduziert werden (z.B. 0.5-0.5-0).

\marginnote{Alpha}

Unterhalb der drei Zeilen fÃ¼r die RGB-Werte befindet sich eine Zeile
Â«\emph{A}Â». Diese Zeile beschreibt den Alpha-Wert, welcher fÃ¼r die
Transparenz steht. Ein Alpha von 0 steht jeweils fÃ¼r Transparenz, ein
Alpha von 1 fÃ¼r keine Transparenz. Damit diese Einstellung allerdings
Ã¼berhaupt einen Einfluss auf die gerenderte Szene hat, werden noch
weitere Schritte vonnÃ¶ten sein, welche zu einem spÃ¤teren Zeitpunkt
beschrieben werden.

\subsection{HSV-Werte}\label{hsv-werte}

\marginnote{HSV}

Unter dem Reiter Â«\emph{HSV}Â» lassen sich Farben im HSV-Farbraum
ausgeben. Dabei werden die Farben hinsichtlich ihres Farbwertes (Hue),
ihrer FarbsÃ¤ttigung (Saturation) und ihres Helligkeitswertes (Value)
unterschieden. Auch durch diese Einstellung lassen sich alle Farben
darstellen.

\marginnote{Farbwert}

Ein HSV-Code von 0-1-1 entspricht der Farbe Rot. Mittels der VerÃ¤nderung
der ersten Zahl kÃ¶nnen andere Farbwerte anvisiert werden, welche
dieselbe Helligkeit und dieselbe FarbsÃ¤ttigung aufweisen. Diese
VerÃ¤nderung kann entweder mit der Eingabe einer Zahl oder mittels der
Navigation des Sliders erfolgen. Im Menu der Farbauswahl fÃ¼hrt eine
ErhÃ¶hung dieser Zahl dazu, dass sich die ausgewÃ¤hlte Farbe im Kreis
bewegt. Beim Wert 1 fÃ¼r den Farbwert hat die Farbauswahl eine ganze
Umdrehung im Farbspektrum des Kreises absolviert.

\marginnote{FarbsÃ¤ttigung}

Eine VerÃ¤nderung der FarbsÃ¤ttigung fÃ¼hrt dazu, dass der Weissanteil an
der ausgewÃ¤hlten Farbe erhÃ¶ht wird. In der kreisfÃ¶rmigen Darstellung der
Farben fÃ¼hrt eine VerÃ¤nderung dieses Wertes dazu, dass sich die Auswahl
nÃ¤her zum Mittelpunkt bewegt, je kleiner der Wert fÃ¼r die FarbsÃ¤ttigung
ist. In der RGB-Darstellung wÃ¼rde eine Reduzierung dieser Zahl bedeuten,
dass die anderen Werte des RGB-Spektrums sich dem dominanten Farbanteil
angleichen, sodass die Farbe weisslicher erscheint.

\marginnote{Farbhelligkeit}

Eine VerÃ¤nderung des Helligkeitswertes fÃ¼hrt dazu, dass die Farbe heller
oder dunkler erscheint. Bei einer VerÃ¤nderung kann dabei der
Schieberegler auf der Seite der Farbauswahl betrachtet werden. Dabei
gleicht sich die Helligkeit der Farbe entsprechend einer VerÃ¤nderung der
Â«\emph{V}Â»-Zeile an.

\subsection{Hexadezimale
Farbdefiniton}\label{hexadezimale-farbdefiniton}

\marginnote{Hexadezimale Farbdefinition}

Das Spektrum der mÃ¶glichen Farben als solches ist limitiert und es ist
nicht mÃ¶glich, eine neue Farbe zu erfinden. Dies hat allerdings den
Vorteil, dass jedem Farbwert ein individueller Code zugeordnet werden
kann. Die hexadezimale Farbdefinition stellt einen solchen Code dar.
Unter dem Reiter Â«\emph{Hex}Â» innerhalb der Farbauswahl kann jeweils
dieser Code fÃ¼r die ausgewÃ¤hlte Farbe betrachtet werden. Ebenso kann an
dieser Stelle auch ein hexadezimaler Code eingefÃ¼gt werden, um eine
entsprechende Farbe auszuwÃ¤hlen. Anders als bei den RGB- oder HSV-Werten
muss hier also lediglich ein Wert Ã¼bertragen werden und damit wird
anschliessend die Farbe ermittelt.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.1667}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.1667}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.1667}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.1667}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.1667}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.1667}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Farbe
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Farbe
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
RGB
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Blenders RGB
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
HSV
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Hexadezimal
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
{\_ \_ \_ \_ \_ \_ \_ \_} & Weiss & 255 - 255 -- 255 & 1- 1 -1 & 0 - 0 -
1 & FFFFFF \\
{\_ \_ \_ \_ \_ \_ \_ \_} & Schwarz & 0 - 0 - 0 & 0 - 0 - 0 & 0 - 0 - 0
& 000000 \\
{\_ \_ \_ \_ \_ \_ \_ \_} & Rot & 255 - 0 - 0 & 1 - 0- 0 & 0 - 1 - 1 &
FF0000 \\
{\_ \_ \_ \_ \_ \_ \_ \_} & GrÃ¼n & 0 - 255 - 0 & 0 - 1 - 0 & 0.333 - 1 -
1 & 00FF00 \\
{\_ \_ \_ \_ \_ \_ \_ \_} & Blau & 0 - 0 - 255 & 0 - 0 - 1 & 0.666 - 1 -
1 & 0000FF \\
{\_ \_ \_ \_ \_ \_ \_ \_} & Gelb & 255 - 255 - 0 & 1 - 1 - 0 & 0.167 - 1
- 1 & FFFF00 \\
{\_ \_ \_ \_ \_ \_ \_ \_} & Aquamarinblau & 0 - 255 - 255 & 0 - 1 - 1 &
0.5 - 1 - 1 & 00FFFF \\
{\_ \_ \_ \_ \_ \_ \_ \_} & Magenta & 255 - 0 - 255 & 1 - 0 - 1 & 0.833
- 1 - 1 & FF00FF \\
{\_ \_ \_ \_ \_ \_ \_ \_} & Orange & 255 - 165 - 0 & 1 - 0.376 - 0 &
0.063 - 1 - 1 & FFA500 \\
\end{longtable}

\subsection{Farben aus anderen Farbboxen
hineinziehen}\label{farben-aus-anderen-farbboxen-hineinziehen}

\marginnote{Farben aus Farbboxen Ã¼bertragen}

Wenn in einem Shader-Editor mehrere Farbboxen vorhanden sind, besteht
die MÃ¶glichkeit, eine Farbe aus einer Farbbox durch einfaches
HinÃ¼berziehen in eine andere Farbbox zu Ã¼bertragen. So kann etwa die
Farbe aus der Farbbox Â«\emph{Emission}Â» auf die Â«\emph{Base Color}Â»
Ã¼bertragen werden. HierfÃ¼r muss lediglich bei gedrÃ¼ckt gehaltener linker
Maustaste die Farbe aus der Emission-Farbbox auf die Base Color-Farbbox
gezogen und die linke Maustaste dann losgelassen werden.

\section{Roughness}\label{roughness}

\marginnote{Worin unterscheiden sich die Abbildungen?}

In Abbildung 3 wird dreimal dasselbe Objekt mit derselben Base-Color im
Material dargestellt. Worin unterscheiden sich die drei Objekte visuell?

\begin{figure}

\includegraphics{Chapters/Images/Chapter_19/19_3_Roughness_Comparison.png}

\caption{\label{fig-1_3}Dreimal dasselbe Objekt mit derselben Farbe,
allerdings unterschiedlichen Roughness-Werten: Links eine Roughness von
0, in der Mitte eine Roughness von 0.5, rechts eine Roughness von 1.}

\end{figure}%

Das erste Objekt auf der linken Seite scheint das Licht in der Umgebung
zu spiegeln und ebenso den Fussboden zu reflektieren. Bei den anderen
beiden Objekten ist dies nicht der Fall. Zwischen dem mittleren und dem
rechten Objekt lÃ¤sst sich kaum ein Unterschied erkennen.

\marginnote{Roughness beschreibt die OberflÃ¤chenstruktur}

Alle drei Objekte unterscheiden sich hinsichtlich der Roughness, welche
sie innehaben. Das erste Objekt weist eine Roughness von 0 auf, das
zweite Objekt eine Roughness von 0.5 und das rechte Objekt eine
Roughness von 1. Die Roughness beschreibt die Struktur der OberflÃ¤che.
Eine Roughness von 0 bezeichnet eine komplett glatte OberflÃ¤che, wÃ¤hrend
eine Roughness von 1 eine sehr raue OberflÃ¤che darstellt. Realistische
Werte fÃ¼r die Roughness liegen im Wert von 0 bis 1. Negative oder
grÃ¶ssere Werte sind auch mÃ¶glich, allerdings werden dabei keine
realgetreuen Abbildungen mehr erstellt.

\marginnote{Identisches Ausmass der Lichtreflexion bei Roughness}

Durch eine geringe Roughness -- also eine glatte OberflÃ¤che -- scheint
das Licht der Umgebung stÃ¤rker reflektiert zu werden und auch Strukturen
in der Umgebung scheinen gespiegelt zu werden. TatsÃ¤chlich wird
allerdings auch in den anderen Beispielen gleich viel Licht reflektiert.
Die Ursache fÃ¼r die unterschiedliche Darstellung liegt somit nicht in
den Unterschieden der Reflexion.

\marginnote{Einfluss der Roughness auf die Lichtreflexion}

Von grÃ¶sserer Bedeutung in diesem Beispiel ist die Frage, wie das Licht
reflektiert wird. Bei einer glatten OberflÃ¤che treffen die Lichtstrahlen
parallel zueinander auf eine OberflÃ¤che auf, die Ã¼ber die ganze FlÃ¤che
hinweg aufgrund der GlÃ¤tte keine KrÃ¼mmungen enthÃ¤lt. Dadurch werden alle
Lichtstrahlen in demselben Winkel reflektiert. Wenn die OberflÃ¤che
allerdings nicht glatt ist und dadurch minimale Buckel auf der
OberflÃ¤che entstehen, wie etwa auf der rechten Seite der Abbildung 4
dargestellt, wird das Licht jeweils in unterschiedlichen Winkeln
reflektiert. Dadurch scheint das Material durch eine erhÃ¶hte Roughness
die Umgebung weniger zu reflektieren.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_19/19_4_Roughness_Representation.png}

\caption{\label{fig-1_4}Schematische Darstellung der Lichtreflexion bei
unterschiedlicher Beschaffenheit der OberflÃ¤che. Links, bei fehlender
Roughness, reflektiert die OberflÃ¤che das Licht parallel weiter. Rechts,
bei einer variablen OberflÃ¤chenstruktur durch erhÃ¶hte Roughness,
entsteht eine diffuse Lichtreflexion.}

\end{figure}%

\marginnote{Roughness einstellen}

Die Roughness ist ein Wert, welcher bei vielen Shadern eingestellt
werden kann. HierfÃ¼r kann bei den entsprechenden Roughness-Zeilen der
Slider nach links oder rechts verschoben. Alternativ kann auch ein Wert
fÃ¼r die Roughness mittels einer Zahl definiert werden.

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Die Blender-Version 2.93 leidet unter einem Bug, sodass teilweise bei der Einstellung einer Roughness von 0 bis 0.003 das Objekt schwarz dargestellt wird. Dies sollte nicht so sein. Das Problem scheint computerabhÃ¤ngig zu sein. Bei einer Roughness von 0.004 sollte das Problem nicht auftreten.
\end{tipp}

\begin{figure}

\includegraphics{Chapters/Images/Chapter_19/19_5_Roughness_Spectrum_Comparison.png}

\caption{\label{fig-1_5}Dasselbe Objekt mit unterschiedlichen
Roughness-Werten. Die Werte betragen von links nach rechts: 0, 0.1, 0.2,
0.3 und 0.4.}

\end{figure}%

\section{Metallic}\label{metallic}

\marginnote{Worin unterscheiden sich die Abbildungen?}

In Abbildung 6 wird zweimal dasselbe Objekt mit derselben Grundfarbe und
derselben Roughness dargestellt. Worin unterscheiden sich die Objekte?

\begin{figure}

\includegraphics{Chapters/Images/Chapter_19/19_6_Metall_Comparison.png}

\caption{\label{fig-1_6}Dasselbe Objekt mit unterschiedlichen
Einstellungen fÃ¼r Metallic. Links ein dielektrisches Objekt (Metallic
von 0), rechts ein metallisches Objekt (Metallic von 1).}

\end{figure}%

Beide Objekte scheinen ihre Umgebung zu reflektieren. Das linke Objekt
scheint die Umgebung allerdings deutlich schwÃ¤cher zu reflektieren,
wÃ¤hrend beim rechten Objekt die Umgebung sehr klar ersichtlich ist. Beim
rechten Objekt scheint zudem kaum erkennbar, woraus die Grundfarbe des
Materials besteht.

\marginnote{Unterschiedliche Prozesse}

Um den Unterschied zwischen diesen beiden Objekten etwas genauer zu
verstehen, benÃ¶tigt es ein VerstÃ¤ndnis fÃ¼r die Prozesse, welche bei der
Lichtspiegelung vonstattengehen: Reflexion und Refraktion.

\marginnote{Reflexion}

Bei der ErklÃ¤rung der Roughness wurde bereits auf die Reflexion
verwiesen. Dabei prallen die Lichtstrahlen an der OberflÃ¤che eines
Objektes ab und entfernen sich wieder vom Objekt. Diese Lichtstrahlen
sind anschliessend mit dem menschlichen Auge sichtbar. Die Lichtstrahlen
dringen dabei nicht in das Objekt ein, sondern werden lediglich
reflektiert.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_19/19_7_Reflexion.png}

\caption{\label{fig-1_7}Schematische Darstellung der Lichtstrahlen bei
einer Reflexion.}

\end{figure}%

\marginnote{Refraktion}

Bei der Refraktion werden die Lichtstrahlen, so wie auch bei der
Reflexion, vom Objekt aus zurÃ¼ckgesendet. Im Unterschied zur Reflexion
dringen die Lichtstrahlen bei der Refraktion allerdings in das Objekt
ein, bevor sie sich wieder vom Objekt entfernen. Beim Eindringen in das
Objekt werden die Lichtstrahlen zudem gebrochen und verlassen das Objekt
dadurch in einem anderen Winkel.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_19/19_8_Refraction.png}

\caption{\label{fig-1_8}Schematische Darstellung der Lichtstrahlen bei
einer Refraktion.}

\end{figure}%

\marginnote{Dielektrische Materialien}

Diese beiden Prozesse -- Reflexion und Refraktion -- schliessen sich
nicht gegenseitig aus. Ein Material kann Lichtstrahlen sowohl
reflektieren als auch refraktieren. Solche Materialien werden als
dielektrische Materialien bezeichnet.

\marginnote{Metallische Materialien}

Eine bestimmte Gruppe von Materialien zeichnet sich allerdings dadurch
aus, dass sie keine Refraktion der Lichtstrahlen zulÃ¤sst. In diesem Fall
reflektiert das Material die Lichtstrahlen, aber keine Lichtstrahlen
dringen in das Objekt ein. Bei dieser Materialiengruppe handelt es sich
um Metalle. Dies macht auch den Unterschied zwischen den beiden Objekten
in Abbildung 6 aus. Das linke Objekt stellt ein dielektrisches Material
dar, wÃ¤hrend das rechte Objekt ein metallisches Objekt darstellt.

\marginnote{Metallic-Wert im Principled-BSDF-Shader}

Im Principled-BSDF-Shader kann der Metallgehalt eines Materials durch
die Zeile Â«\emph{Metallic}Â» variiert werden, entweder durch eine
Bewegung des Sliders oder durch eine Zahleneingabe. Ein Wert von 0
beschreibt dabei, dass es sich um ein dielektrisches Material handelt,
welches Licht sowohl reflektiert als auch refraktiert. Ein Wert von 1
hingegen beschreibt ein metallisches Material, bei dem Licht lediglich
reflektiert wird. Je grÃ¶sser der Metallic-Wert, desto weniger Licht wird
durch das Material refraktiert.

\section{Parameter richtig
einstellen}\label{parameter-richtig-einstellen}

\marginnote{Parameter kombinieren}

Durch die Kombination der bislang erlÃ¤uterten Parameter lassen sich
bereits viele Arten von Materialien erstellen. Ein metallisches Objekt
unterscheidet sich ebenfalls hinsichtlich der Roughness und kann auch
unterschiedliche Farbwerte annehmen. Dadurch lassen sich bereits viele
Materialien nachbilden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_19/19_9_Material_Comparison.png}

\caption{\label{fig-1_9}Darstellung desselben Objektes unter denselben
LichtverhÃ¤ltnissen bei unterschiedlichen Werten fÃ¼r Metallic und
Roughness.}

\end{figure}%

\marginnote{Verwendung von Bildvorlagen, um Materialien nachzubilden}

Um mÃ¶glichst realistische Abbildungen von Materialien zu erstellen,
empfiehlt es sich, jeweils mit einer Bildvorlage zu arbeiten. Diese
sollte mÃ¶glichst genau studiert werden und es sollte betrachtet werden,
wie die entsprechenden Materialien agieren. Wie stark reflektieren die
Materialien? Sind die Materialien glatt? Bestehen die Materialien aus
Metall? Welche Farbe liegt dem Material zugrunde? Dies stellt lediglich
eine Reihe von Fragen dar, welche bei der Anpassung von Materialien
berÃ¼cksichtig werden. Durch weitere Parameter der Materialen wird die
KomplexitÃ¤t, mit der Materialien abgebildet werden, zusÃ¤tzlich erhÃ¶ht.

Merke\ldots{}

Base-Color, Roughness und Metallic beschreiben grundlegende
Eigenschaften von Objekt-Materialien.

Die Base-Color beschreibt die Farbe des Materials.

Die Roughness beschreibt, wie stark die Reflexion des Materials
gebÃ¼ndelt wird.

Metallic beschreibt, ob ein Objekt aus Metall ist, und dadurch keine
Refraktion aufweist.

Ãœbung 12: Materialien nachbilden

\textbf{Ãœbung 12.1}

Ã–ffnen Sie die Datei Â«Uebung\_12\_1Â» und wechseln sie in den
Rendered-Viewport-Shading-Modus. Dieses File ist bereits mit einer
Hintergrundwelt und einer Beleuchtung ausgestattet, sodass Sie den
Rendered-Viewport-Shading-Modus verwenden kÃ¶nnen. VerÃ¤ndern Sie von den
fÃ¼nf abgebildeten Kugeln die Einstellungen fÃ¼r die Base-Color, Roughness
und Metallic so, dass die Kugeln mÃ¶glichst Ã¤hnlich den Ã¼ber ihnen
abgebildeten Kugeln erscheinen.

\section{Mehrere Materialien
verwenden}\label{mehrere-materialien-verwenden}

\marginnote{Mehrere Materialien in einem Objekt verwenden}

Wie bereits betrachtet kann ein Objekt mehrere Slots fÃ¼r Materialien
innehaben. Dadurch ist es auch mÃ¶glich, dass ein Objekt mehrere
unterschiedliche Materialien beinhaltet. Die Materialien werden dabei
den einzelnen Faces der Objekte zugewiesen. Dadurch kann ein Face einem
bestimmten Material zugewiesen werden und das danebenliegende Face einem
anderen Material.

\marginnote{Materialien Slots zuweisen}

Wenn sich in der Auflistung der Material-Slots mehrere Slots befinden,
werden standardmÃ¤ssig alle Faces des Objektes dem ersten Slot und somit
auch dem Material im ersten Slot zugewiesen. Wenn ein zweiter Slot mit
einem zweiten Material erstellt wurde, dann mÃ¼ssen im Edit-Mode die
entsprechenden Faces ausgewÃ¤hlt werden, welche diesem zweiten Slot
zugewiesen werden sollen. Mittels der SchaltflÃ¤che Â«\emph{Assign}Â»
kÃ¶nnen anschliessend die entsprechenden Faces diesem Slot zugewiesen
werden.

\marginnote{Zuweisung erfolgt zu Material-Slots und nicht zu Material}

Durch die Zuweisung mittels Â«\emph{Assign}Â» werden die ausgewÃ¤hlten
Faces nicht direkt einem Material zugewiesen, sondern zu einem
Material-Slot. Das Material kann nachtrÃ¤glich immer noch geÃ¤ndert
werden, indem Ã¼ber das Dropdown-MenÃ¼ ein anderes Material fÃ¼r diesen
Slot ausgewÃ¤hlt wird. Dies fÃ¼hrt dazu, dass auch die Faces, welche
diesem Slot zugewiesen wurden, nun mit dem neu ausgewÃ¤hlten Material
dargestellt werden.

\marginnote{Auswahl von Faces mittels Materialien}

Mittels der SchaltflÃ¤che Â«\emph{Select}Â» lassen sich im Edit-Mode die
Faces markieren, die zu dem Material-Slot gehÃ¶ren, der gerade in der
Auflistung ausgewÃ¤hlt wurde. Dadurch kann schnell ermittelt werden,
welche Faces zu einem Material-Slot gehÃ¶ren. Mittels der Taste
Â«\emph{Deselect}Â» kÃ¶nnen zudem die Faces, die zum aktuell angewÃ¤hlten
Material-Slot gehÃ¶ren, von der aktuellen Auswahl deaktiviert werden.
Durch diese Optionen stellen die Material-Slots eine zusÃ¤tzliche
Hilfestellung dar, um Elemente in komplexen Objekten schnell auswÃ¤hlen
zu kÃ¶nnen.

\chapter{Tutorial: Strandball}\label{tutorial-strandball}

\marginnote{Ziel dieses Tutorials}

Das Ziel dieses Tutorials ist es, einen Strandball Ã¤hnlich der Abbildung
1 zu erstellen. HierfÃ¼r werden verschiedene Materialien zu einem Objekt
hinzugefÃ¼gt und variiert. Der erste Schritt dazu besteht aus dem
Erstellen eines Objektes fÃ¼r den Strandball. HierfÃ¼r kann im
3D-Viewport-Editor mittels der Tastenkombination \kbd{Shift} + \kbd{A}
das Â«\emph{Add}Â»-MenÃ¼ geÃ¶ffnet werden und unter Â«\emph{Mesh \textbar{}
UV Sphere}Â» eine Kugel hinzugefÃ¼gt werden. Diese kann in ihren
Standardeinstellungen so belassen werden, wie sie ist. Damit ist bereits
die Grundstruktur des Strandballs vorhanden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_20/20_1_Beach_Ballon_Rendered.png}

\caption{\label{fig-1_1}In diesem Tutorial soll dieser Strandball
erstellt werden.}

\end{figure}%

\marginnote{Vorbereitung}

Im nÃ¤chsten Schritt geht es um die Erstellung von Materialien. HierfÃ¼r
sollte der 3D-Viewport-Editor zunÃ¤chst in zwei Editoren aufgeteilt
werden, indem ein zweiter Editor aus einer der Ecken des
3D-Viewport-Editors herausgezogen wird. Anschliessend kann einer der
beiden 3D-Viewport-Editoren zum Shader-Editor umgewandelt werden, indem
auf die SchaltflÃ¤che in der linken oberen Ecke des 3D-Viewport-Editors
geklickt wird und der Â«\emph{Shader Editor}Â» ausgewÃ¤hlt wird. Im anderen
3D-Viewport-Editor sollte das Viewport-Shading auf Â«\emph{Material
Preview Mode}Â» umgestellt werden, damit die Materialien sichtbar sind.
Zudem ist es sinnvoll, im Properties-Editor auf den Reiter fÃ¼r die
Materialien zu wechseln. Anschliessend sollte der Bildschirm etwa so wie
in Abbildung 2 angeordnet sein.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_20/20_2_Screen_Organisation.png}

\caption{\label{fig-1_2}Anordnung der Editoren fÃ¼r die Erstellung des
Strandballs.}

\end{figure}%

\marginnote{Neues Material erstellen}

Im Header des Shader-Editors kann nun durch das Klicken der SchaltflÃ¤che
Â«\emph{New}Â» ein neues Material erstellt werden -- hierfÃ¼r sollte die
UV-Sphere als aktives Objekt ausgewÃ¤hlt sein. Dadurch wird der Kugel ein
neues Material hinzugefÃ¼gt. Im Properties-Editor wird dafÃ¼r ein neuer
Slot fÃ¼r Materialien erstellt und gleich das erstellte Material diesem
Slot hinzugefÃ¼gt. Im Shader-Editor wird der Principled-BSDF-Shader
hinzugefÃ¼gt und mit dem Material-Output verbunden.

\marginnote{Blaue Farbe erstellen}

Nun wird zunÃ¤chst das erste Material des Strandballs erstellt. Dieses
Material soll die blauen Streifen des Balls abdecken. HierfÃ¼r wird
zunÃ¤chst im Principled-BSDF-Shader die Â«\emph{Base Color}Â» verÃ¤ndert,
indem auf die weisse FlÃ¤che in der entsprechenden Zeile geklickt wird.
Hierdurch Ã¶ffnet sich das Fenster zur Auswahl einer neuen Farbe. Die
Farbe soll blau werden. Dies lÃ¤sst sich am besten im Â«\emph{RGB}Â»-Reiter
einstellen, indem dort die RGB-Werte 0-0-1 eingegeben werden.

\marginnote{Shade Smooth}

Um den Grad der Reflexion besser nachvollziehen zu kÃ¶nnen, empfiehlt es
sich, das Objekt geglÃ¤ttet darstellen zu lassen. HierfÃ¼r wird im
3D-Viewport das MenÃ¼ Â«\emph{Object}Â» geÃ¶ffnet und die Option
Â«\emph{Shade Smooth}Â» ausgewÃ¤hlt. Dadurch werden die Kanten des Objektes
geglÃ¤ttet dargestellt.

\marginnote{Parameter einstellen}

Im nÃ¤chsten Schritt werden die Parameter fÃ¼r das Material eingestellt.
Der Strandball wird nicht metallisch sein, somit kann der Wert fÃ¼r
Â«\emph{Metallic}Â» auf dem Wert 0 belassen werden. Der Strandball sollte
allerdings glatter erscheinen. Deshalb wird der Wert fÃ¼r die
Â«\emph{Roughness}Â» etwas reduziert. Ein Wert von 0 fÃ¼hrt allerdings zu
einer zu starken Reflexion. Deshalb ist ein Roughness-Wert von etwa 0.2
eher zu bevorzugen.

\marginnote{Material benennen}

Das aktuell ausgewÃ¤hlte Material wird spÃ¤ter verwendet, um die
OberflÃ¤chen mit der blauen Farbe darzustellen. Um etwas Ordnung in die
Materialien zu bringen, wird dieses Material umbenannt. HierfÃ¼r kann
entweder im Header des Shader-Editors auf die Bezeichnung des Materials
geklickt werden, um diese umzubenennen, oder alternativ kann dies auch
im Properties-Editor erfolgen. Dort kann die Standardbezeichnung
Â«\emph{Material}Â» mit dessen Nummerierung beispielsweise zu Â«Ball\_BlauÂ»
geÃ¤ndert werden.

\marginnote{Neuen Material-Slot hinzufÃ¼gen}

Als NÃ¤chstes wird ein weiteres Material erstellt, welches eine andere
Farbe darstellen soll. HierfÃ¼r wird im Properties-Editor ein neuer Slot
fÃ¼r ein Material erstellt, indem auf die SchaltflÃ¤che Â«+Â» geklickt wird.
Die Auswahl des Material-Slots wird nun auf den neuen Slot umgestellt,
der allerdings noch kein Material innehat. Nun kÃ¶nnte an dieser Stelle
ein neues Material erstellt werden.

\marginnote{Kopie eines Materials erstellen}

Das zweite Material wird allerdings praktisch dieselben Eigenschaften
innehaben wie das Material Â«Ball\_BlauÂ». Aus diesem Grund ist es
sinnvoller, eine Kopie dieses Materials zu erstellen und darauf
basierend die Parameter abzuÃ¤ndern, die unterschiedlich sein sollen.
HierfÃ¼r kann im Dropdown MenÃ¼ neben der SchaltflÃ¤che Â«\emph{New}Â» erneut
das Material Â«Ball\_BlauÂ» ausgewÃ¤hlt werden. Nun befindet sich in beiden
Material-Slots dasselbe Material. Mittels eines Klicks auf das Icon fÃ¼r
Â«\emph{New Material}Â» wird eine Kopie des Materials erstellt, welche nun
als Â«Ball\_Blau.001Â» bezeichnet wird.

\marginnote{Gelbes Material erstellen}

Das kopierte Material wird als NÃ¤chstes mit einer gelben Grundfarbe
versehen. Damit dies auch in dessen Bezeichnung ersichtlich ist, wird es
vorher noch zu Â«Ball\_GelbÂ» umbenannt. Anschliessend wird im
Shader-Editor im Principled-BSDF-Shader die Â«\emph{Base Color}Â» auf
einen RGB-Wert von 1-1-0 gesetzt. Dadurch sollte nun das Material
Â«Ball\_GelbÂ» eine unterschiedliche Farbe als Â«Ball\_BlauÂ» aufweisen,
aber in allen anderen Parametern identisch sein.

\marginnote{Faces fÃ¼r zweiten Material-Slot auswÃ¤hlen}

Als NÃ¤chstes wird im Edit-Mode definiert, welche Faces zu welchem
Material gehÃ¶ren. HierfÃ¼r wird mittels der Taste \kbd{Tab} in den
Edit-Mode gewechselt. Alle Faces haben nun noch standardmÃ¤ssig das
Material des ersten Material-Slots inne. Deshalb werden nun alle Faces
ausgewÃ¤hlt, denen das Material aus dem zweiten Material-Slot zugewiesen
werden soll. Jeweils vier aufeinanderfolgende Streifen werden mit
demselben Material ausgestattet. Indem im Face-Select-Modus bei
gedrÃ¼ckter Tastenkombination \kbd{Shift} + \kbd{A} mit der linken
Maustaste auf die Streifen der UV-Sphere geklickt wird, kÃ¶nnen diese
gleich als Ganzes ausgewÃ¤hlt werden. Anschliessend mÃ¼ssen der Auswahl
noch von Hand die dazugehÃ¶rigen Tris an den beiden Polen der Kugel
hinzugefÃ¼gt werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_20/20_3_Material_Choice_2.png}

\caption{\label{fig-1_3}Auswahl der Faces zur Zuweisung des zweiten
Material-Slots.}

\end{figure}%

\marginnote{Zweites Material den Faces hinzufÃ¼gen}

Im Properties-Editor kann nun im Material-Reiter der zweite
Material-Slot ausgewÃ¤hlt werden. Wenn nun die SchaltflÃ¤che
Â«\emph{Assign}Â» gedrÃ¼ckt wird, sollte den ausgewÃ¤hlten Faces das
Material im zweiten Material-Slot zugewiesen werden.

\marginnote{Weisses Material erstellen}

Als NÃ¤chstes wird ein weiterer Material-Slot erstellt und diesem eine
weitere Kopie des ersten (oder alternativ des zweiten) Materials
zugewiesen. Dieses Material wird in diesem Beispiel den Polen des Balls
zugewiesen und kÃ¶nnte etwa als Â«Ball\_WeissÂ» bezeichnet werden. Auch bei
diesem Material wird anschliessend lediglich die Farbe verÃ¤ndert,
nÃ¤mlich auf weiss (RGB-Code 1-1-1).

\marginnote{Weisses Material hinzufÃ¼gen}

Im Edit-Mode werden anschliessend alle Faces an den Polen der Kugel
ausgewÃ¤hlt. Diesen Faces wird dann das neu erstellte Material
zugewiesen, indem das dritte Material ausgewÃ¤hlt wird und auf
Â«\emph{Assign}Â» geklickt wird.

\marginnote{Subdivision-Surface-Modifier hinzufÃ¼gen}

An dieser Stelle kÃ¶nnte der Ball bereits fertig sein. Bei genauerer
Betrachtung sind allerdings noch einige Kanten von Vertices zu erkennen.
Deshalb wird dem Ball noch ein Subdivision-Surface-Modifier hinzugefÃ¼gt,
um auch die Struktur des Objektes etwas abzuglÃ¤tten. HierfÃ¼r wird im
Properties-Editor auf den Reiter fÃ¼r die Modifiers geklickt und unter
Â«\emph{Add Modifier}Â» der Â«\emph{Subdivision Surface}Â»-Modifier
hinzugefÃ¼gt. Unter Â«\emph{Levels Viewport}Â» kann anschliessend noch die
Anzahl Subdivisions auf den Wert 2 erhÃ¶ht werden. Dadurch erscheint der
Ball weniger kantig.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_20/20_4_ Material_Choice_3.png}

\caption{\label{fig-1_4}Auswahl der Faces fÃ¼r den dritten
Material-Slot.}

\end{figure}%

\marginnote{Creases hinzufÃ¼gen}

Durch den Subdivision-Surface-Modifier ergibt sich nun jedoch ein neues
Problem. Die Faces an den Polen der Kugel stellen jeweils Tris dar,
welche unregelmÃ¤ssig geglÃ¤ttet werden. Um dieses Problem zu lÃ¶sen, wird
der jeweils erste Edge-Ring an den Polen ausgewÃ¤hlt, indem im
Edge-Select-Modus bei gedrÃ¼ckter \kbd{Alt}-Taste ein Edge dieses Rings
angeklickt wird. Anschliessend kann in der Sidebar (Ã¶ffnen mittels
\kbd{N}) der Edge-Crease fÃ¼r diese Edges auf 0.5 eingestellt werden,
wodurch diese Kante etwas weniger stark verzogen wird. Dadurch sollte
nun der Strandball fertiggestellt sein.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_20/20_5_Creases.png}

\caption{\label{fig-1_5}Creases an der Abgrenzung der Tris.}

\end{figure}%

Ãœbung 13: Materialien zuweisen und nachbilden

\textbf{Ãœbung 13.1}

Ã–ffnen Sie die Datei Â«\emph{Uebung\_13\_1}Â» und wechseln Sie in den
Material-Preview-Shading-Modus. Sie finden ein Feuerzeug vor, dem noch
keine Materialien zugewiesen wurden. Orientieren Sie sich hierfÃ¼r an
realen Beispielen oder Beispielbildern aus dem Internet.

\chapter{Texturen}\label{texturen}

\marginnote{Parameter}

Bislang wurden fÃ¼r die verschiedenen Einstellungsoptionen von
Materialien konstante Werte verwendet. Das heisst: Einem Material wurde
stets eine gewisse Farbe zugewiesen (z.B. Rot) und diese Farbe wurde auf
alle OberflÃ¤chen, die diesem Material zugewiesen wurden, aufgetragen --
so wie in Abbildung 1. Ebenso verhielt es sich mit der Roughness: FÃ¼r
diese wurde ein fixer Wert definiert, welcher fÃ¼r das ganze Material
angewendet wurde. Eine Variation innerhalb des Materials war dabei nicht
mÃ¶glich.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_21/21_1_Red_Cube.png}

\caption{\label{fig-1_1}Der StandardwÃ¼rfel mit einer roten Base-Color.}

\end{figure}%

\marginnote{Texturen}

Texturen stellen eine MÃ¶glichkeit dar, um verschiedene Werte fÃ¼r eine
Einstellung zu definieren und diese auf ein Objekt zu Ã¼bertragen.
Dadurch kÃ¶nnen komplexere FarbverlÃ¤ufe oder Variationen von Farben Ã¼ber
die Breite einer OberflÃ¤che erstreckt werden -- wie beispielsweise in
Abbildung 2.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_21/21_2_Cube_Textured.png}

\caption{\label{fig-1_2}Der StandardwÃ¼rfel mit einer Textur in der
Base-Color.}

\end{figure}%

\marginnote{Beispiel mit zwei verschiedenen Texturen}

Der Unterschied zwischen Abbildung 1 und Abbildung 2 ist in Abbildung 3
ersichtlich. Beide Bilder in der Abbildung 3 zeigen eine Textur. Die
linke Textur, welche komplett aus einer roten FlÃ¤che besteht, beschreibt
die Textur, welche auf den WÃ¼rfel in Abbildung 1 aufgetragen wird. Die
rechte Textur aus der Abbildung 3 zeigt eine Textur, welche auf den
WÃ¼rfel in der Abbildung 2 aufgetragen wird.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_21/21_3_Textures_Comparison.png}

\caption{\label{fig-1_3}Links eine einfarbige rote Textur und rechts
eine Textur mit einem Mauer-Muster.}

\end{figure}%

\marginnote{Texturen werden nicht fÃ¼r Parameter verwendet}

Die linke Textur mÃ¼sste allerdings nicht verwendet werden. Die gesamte
Textur beschreibt eine konstante Farbe, namentlich die Farbe Rot, und
weist keinerlei Variation im Bild auf. Deshalb kÃ¶nnte man stattdessen
die Grundfarbe im Principled-BSDF-Shader auf Rot stellen und brÃ¤uchte
keine Textur. Der Parameter fÃ¼r die Base-Color wÃ¤re dann auf die Farbe
Rot eingestellt. In solchen FÃ¤llen wÃ¼rde man meistens auf die Textur
verzichten, da diese als zusÃ¤tzliche Bilddatei mit dem 3D-Objekt
abgespeichert wird und mehr Speicherplatz benÃ¶tigt.

\marginnote{Textur fÃ¼r Variation}

Die rechte Textur, welche auf den WÃ¼rfel der Abbildung 2 Ã¼bertragen
wird, kÃ¶nnte nicht mittels einer einzelnen Farbe im
Principled-BSDF-Shader dargestellt werden. In der Base-Color des Shaders
kann leidglich eine Farbe ausgewÃ¤hlt werden, welche angezeigt wird --
also kann lediglich ein Parameter definiert werden. Um eine Variation an
Parametern zu erzielen, wie in Abbildung 2, wird eine Textur benÃ¶tigt,
welche anschliessend der Base-Color im Principled-BSDF-Shader zugewiesen
wird.

\chapter{UVs}\label{uvs}

\section{Wie kommen die Texturen auf ein
Objekt?}\label{wie-kommen-die-texturen-auf-ein-objekt}

\marginnote{Einen WÃ¼rfel aus Papier erstellen}

Stellen Sie sich vor, sie mÃ¶chten den StandardwÃ¼rfel aus Blender als
reales Objekt mit Papier oder Karton nachbauen. Wie wÃ¼rden Sie vorgehen?
Eine MÃ¶glichkeit wÃ¤re, dass eine Form, Ã¤hnlich derjenigen aus Abbildung
1, ausgeschnitten wird und anschliessend an den Kanten zusammengefaltet
und an den entsprechenden Stellen zusammengeklebt wird. Dadurch entsteht
ein WÃ¼rfel. Wenn dieser WÃ¼rfel aus einem normalen einfarbigen Papier
erstellt wird, besteht seine gesamte OberflÃ¤che aus einem einzelnen Wert
-- der Farbe des Papiers. Man kÃ¶nnte sich also vorstellen, dass das
Material dieses WÃ¼rfels in Blender die Farbe des Papiers als Parameter
in der Base-Color des Principled-BSDF-Shaders innehat.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_22/22_1_Texture_Presentation.png}

\caption{\label{fig-1_1}Form, aus der ein WÃ¼rfel gefaltet werden kann.}

\end{figure}%

\marginnote{WÃ¼rfel aus einer Fotografie abbilden}

Statt eines einfarbigen Papiers kÃ¶nnte auch eine Fotografie verwendet
werden -- wie in diesem Fall das Bild einer Steintextur in Abbildung 2
(Bildquelle: \url{https://ambientcg.com/view?id=Rocks024S}). Diese
Abbildung wÃ¼rde anschliessend mitsamt den farblichen Strukturen des
Bildes auch auf der OberflÃ¤che des WÃ¼rfels dargestellt. Der WÃ¼rfel aus
Abbildung 2 weist auf seiner Vorderseite dieselbe Struktur auf, wie sie
in dem Kasten der Vorlage auf der linken Seite zuoberst dargestellt ist.
Analog stellen die anderen Seiten des WÃ¼rfels ebenfalls einen Kasten aus
der Vorlage auf der linken Seite dar. In diesem Fall wird die Fotografie
als Textur verwendet, welche verschiedene Farbvariationen beinhaltet und
als Base-Color fungieren kann.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_22/22_2_Smallstones_Texture_Cube.png}

\caption{\label{fig-1_2}Eine Form auf einem Foto sowie ein WÃ¼rfel, der
aus dieser Form zusammengefaltet wurde.}

\end{figure}%

\marginnote{VerÃ¤nderung des Bildes}

WÃ¼rde man nun eine kleinere FlÃ¤che dieses Fotos verwenden, um die
Vorlage zu erstellen, oder das Foto vergrÃ¶ssern, kann dieselbe Vorlage
zum Zusammenfalten des WÃ¼rfels verwendet werden. Die einzelnen Seiten
entsprechen rÃ¤umlich immer noch denselben KÃ¤sten aus der linken
Abbildung -- allerdings weichen die gewÃ¤hlten Bildausschnitte ab, wie in
Abbildung 3 dargestellt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_22/22_3_Bigstones_Texture_Cube.png}

\caption{\label{fig-1_3}Dasselbe Foto aus Abbildung 2, allerdings mit
einer kleineren FlÃ¤che, aus welcher der WÃ¼rfel erstellt wird.}

\end{figure}%

\section{UV-Mapping}\label{uv-mapping}

\marginnote{UV-Mapping}

Der soeben dargestellte Prozess wird auch in der 3D-Modellierung bei der
Verwendung von Texturen durchgefÃ¼hrt und wird als UV-Mapping bezeichnet.
Hierbei wird fÃ¼r alle OberflÃ¤chen auf einem dreidimensionalen Objekt
eingestellt, wie diese ein zweidimensionales Bild abdecken sollen. Diese
rÃ¤umliche Zuordnung von OberflÃ¤chen in einem dreidimensionalen Objekt
auf ein zweidimensionales Bild wird als UV bezeichnet.

\marginnote{UV-Editor}

Um die UVs eines Objektes in Blender zu betrachten, wird ein neuer
Editor benÃ¶tigt, der neben dem 3D-Viewport-Editor geÃ¶ffnet wird -- der
UV-Editor. HierfÃ¼r muss ein neuer Editor aus den Ecken des
3D-Viewport-Editors herausgezogen werden und dieser neue Editor auf den
Â«\emph{UV Editor}Â» umgestellt werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_22/22_4_Icon_UV_Editor.png}

\caption{\label{fig-1_4}Icon fÃ¼r den UV-Editor.}

\end{figure}%

\marginnote{Alle UVs eines Objektes anzeigen lassen}

Auf den ersten Blick scheint der UV-Editor leer zu sein. Dies liegt
daran, dass in diesem Editor jeweils die UVs der gerade ausgewÃ¤hlten
Faces dargestellt werden. Um die UVs zu betrachten, muss deshalb im
3D-Viewport-Editor in den Edit-Mode gewechselt werden und alle Faces
ausgewÃ¤hlt werden. Anschliessend werden im UV-Editor die UVs dieser
Auswahl angezeigt, wie in Abbildung 5 dargestellt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_22/22_5_UV_Editor.png}

\caption{\label{fig-1_5}Der StandardwÃ¼rfel und seine UVs im UV-Editor.}

\end{figure}%

\marginnote{ZugehÃ¶rigkeit einer UV ermitteln}

Auf den ersten Blick ist dabei nicht ganz klar, welche UV zu welchem
Face gehÃ¶rt. Wenn man beispielsweise wissen mÃ¶chte, welche UV ein
bestimmtes Face darstellt, kÃ¶nnen alle Faces abgewÃ¤hlt werden und
lediglich dieses eine Face ausgewÃ¤hlt werden, wie in Abbildung 6.
Dadurch wird im UV-Editor lediglich die UV dieses einen Faces
dargestellt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_22/22_6_UV_with_Seam.png}

\caption{\label{fig-1_6}Auswahl eines Faces des StandardwÃ¼rfels, um
seine dazugehÃ¶rige UV zu ermitteln.}

\end{figure}%

\marginnote{UVs werden mit neuem Objekt erstellt}

Jedes neu hinzugefÃ¼gte Objekt in Blender wird bereits mit einem
UV-Mapping erstellt. Das heisst, ein neu hinzugefÃ¼gter WÃ¼rfel beinhaltet
bereits das standardmÃ¤ssige UV-Mapping, welches bislang dargestellt
wurde. Auch andere Mesh-Formen werden standardmÃ¤ssig mit ihren
UV-Mappings erstellt. Abbildung 7 zeigt die Mesh-Primitives in ihren
Default-Einstellungen inklusive einer auf sie angewendeten Textur und
darunter das entsprechende Mapping dieser Texturen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_22/22_7_UVs_per_Object.png}

\caption{\label{fig-1_7}Die Mesh-Primitives und die standardmÃ¤ssig dazu
erstellten UV-Mappings.}

\end{figure}%

\marginnote{UV-Unwrapping}

Wenn Objekte im Edit-Mode bearbeitet werden und komplexere Formen
annehmen, kann es vorkommen, dass die UVs nicht mehr passend erscheinen.
In solchen FÃ¤llen sollten die UVs jeweils angepasst werden. Statt einer
manuellen Anpassung besteht allerdings auch die MÃ¶glichkeit, dass
Blender die UVs neu fÃ¼r die verÃ¤nderte Form erstellt. Dieser Prozess
wird als UV-Unwrapping bezeichnet.

\marginnote{\kbd{U}, um Objekte zu unwrappen}

Das UV-Unwrapping erfolgt im Edit-Mode. Dabei werden die Faces, bei
denen das UV-Unwrapping erfolgen soll, ausgewÃ¤hlt und anschliessend die
Taste \kbd{U} gedrÃ¼ckt. Beim Mauszeiger erscheint anschliessend das
Â«\emph{UV Mapping}Â»-MenÃ¼, bei dem aus verschiedenen Optionen zum
Unwrapping ausgewÃ¤hlt werden kann. Diese Optionen sind:

\begin{itemize}
\tightlist
\item
  Â«\textbf{\emph{Unwrap}}Â»: Dabei wird das Mesh auf eine
  zweidimensionale FlÃ¤che projiziert. HierfÃ¼r werden auch manuell
  gesetzte Grenzen in Texturen berÃ¼cksichtigt.
\item
  Â«\textbf{\emph{Smart UV Project}}Â»: Die UVs werden basierend auf den
  Winkeln zwischen Faces erstellt und separiert.
\item
  Â«\textbf{\emph{Lightmap Pack}}Â»: Hierbei werden UVs erstellt, welche
  fÃ¼r Lightmaps besonders geeignet sind, weil die UVs so angeordnet
  werden, dass mÃ¶glichst die gesamte FlÃ¤che der Textur verwendet wird.
  Bei den Lightmaps handelt es sich dabei um Texturen, welche
  Informationen Ã¼ber die Beleuchtung beinhalten.
\item
  Â«\textbf{\emph{Follow Active Quads}}Â»: Die aktiven Quads werden als
  Grundlage fÃ¼r die UV-Erstellung verwendet und ausgehend von den Loops,
  welche diese Quads bilden, werden die UVs erstellt.
\item
  Â«\textbf{\emph{Cube Projection}}Â»: Das Unwrapping erfolgt ausgehend
  von der Grundform eines WÃ¼rfels.
\item
  Â«\textbf{\emph{Cylinder Projection}}Â»: Das Unwrapping erfolgt
  ausgehend von einem Zylinder.
\item
  Â«\textbf{\emph{Sphere Projection}}Â»: Das Unwrapping erfolgt ausgehend
  von einer Kugel.
\item
  Â«\textbf{\emph{Project from View}}Â»: Das Unwrapping erfolgt ausgehend
  von der aktuellen Ansicht im 3D Viewport-Editor.
\item
  Â«\textbf{\emph{Project from View (Bounds)}}Â»: Das Unwrapping erfolgt
  ausgehend von der aktuellen Ansicht im 3D-Viewport-Editor, wobei die
  Anordnung der UVs bis zu den Grenzen der Textur gestreckt werden.
\item
  Â«\textbf{\emph{Mark Seam}}Â»: Ein Seam wird hinzugefÃ¼gt. Dabei handelt
  es sich um manuell gesetzte Schnitte im UV-Mapping.
\item
  Â«\textbf{\emph{Clear Seam}}Â»: Ein Seam wird entfernt.
\item
  Â«\textbf{\emph{Reset}}Â»: Das UV-Mapping wird zurÃ¼ckgesetzt, sodass
  alle Faces den gesamten UV-Raum ausfÃ¼llen und somit dieselbe GrÃ¶sse
  innehaben.
\end{itemize}

\begin{figure}

\includegraphics{Chapters/Images/Chapter_22/22_8_UV_Unwrapping_Menu.png}

\caption{\label{fig-1_8}UV-Mapping-MenÃ¼.}

\end{figure}%

\marginnote{Texturen im UV-Editor anzeigen}

Damit im UV-Editor die jeweilige Textur angezeigt wird, auf welche die
UVs angepasst werden sollen, muss im UV-Editor diese Textur ausgewÃ¤hlt
werden. In der Mitte des Headers im UV-Editor befindet sich ein
AuswahlmenÃ¼, in dem die entsprechenden Texturen ausgewÃ¤hlt oder geladen
werden kÃ¶nnen. Nach der Auswahl der entsprechenden Textur wird diese im
Hintergrund des UV-Editors angezeigt, sodass die Anordnung der UVs
entsprechend der Textur verÃ¤ndert werden kann. Dadurch wird dem Objekt
selbst diese Textur allerdings noch nicht hinzugefÃ¼gt.

\marginnote{UVs mittels Seams trennen}

In manchen Situationen ist es erforderlich, dass eigenhÃ¤ndig definiert
wird, an welchen Stellen die UVs geschnitten werden sollen. MÃ¶chte man
beispielsweise, dass die UVs entlang einer Reihe von Edges nicht
miteinander verbunden werden oder dass separate Inseln von UVs zwischen
mehreren Bereichen entstehen, so kÃ¶nnen Seams auf die entsprechenden
Edges angewendet werden.

\marginnote{Seams hinzufÃ¼gen}

Beispielsweise kÃ¶nnten im StandardwÃ¼rfel alle Edges ausgewÃ¤hlt werden,
welche zu einer FlÃ¤che gehÃ¶ren, und diesen jeweils ein Seam hinzugefÃ¼gt
werden. Um einen Seam hinzuzufÃ¼gen, kann mittels der Tastenkombination
\kbd{Ctrl} + \kbd{E} das Edge-MenÃ¼ beim Mauszeiger geÃ¶ffnet werden.
Mittels der Option Â«\emph{Mark Seam}Â» kÃ¶nnen dann die Seams an den
ausgewÃ¤hlten Edges hinzugefÃ¼gt werden. Im Edit-Mode sind diese
anschliessend anhand einer roten Markierung entlang der entsprechenden
Edges ersichtlich. Mittels der Option Â«\emph{Clear Seam}Â» kÃ¶nnen Seams
bei ausgewÃ¤hlten Edges wieder entfernt werden.

\marginnote{Seams beim Unwrapping berÃ¼cksichtigen}

Damit die gesetzten Seams auch in den UVs des Objektes berÃ¼cksichtig
werden, muss erneut ein Unwrapping auf das Objekt erfolgen. Die Option
Â«\emph{Unwrap}Â» im MenÃ¼ Â«\emph{UV Mapping}Â» berÃ¼cksichtigt jeweils die
gesetzten Seams.

\marginnote{Auswahl von UVs im UV-Editor}

Im UV-Editor kÃ¶nnen die einzelnen UVs, aber auch die Vertices und Edges
ausgewÃ¤hlt werden. Wenn der Edit-Mode aktiviert ist, erscheinen in der
linken oberen Ecke des UV-Editors verschiedene SchaltflÃ¤chen, mit denen
die Auswahl bestimmt werden kann. Nebst der Auswahl von Vertices, Edges
und Faces kÃ¶nnen im UV-Editor zudem auch ganze Inseln ausgewÃ¤hlt werden.
Dabei werden alle UVs, die zusammen eine UV-Insel bilden, gemeinsam
ausgewÃ¤hlt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_22/22_9_Icons_UV_Editor_Selections.png}

\caption{\label{fig-1_9}Select-Modes fÃ¼r die Auwahl von UVs.}

\end{figure}%

\marginnote{UVs im UV-Editor anpassen}

Im UV-Editor ist es zudem mÃ¶glich, die Platzierung der UVs zu verÃ¤ndern.
HierfÃ¼r werden die entsprechenden UVs im UV-Editor ausgewÃ¤hlt.
Anschliessend kÃ¶nnen diese mittels der Taste \kbd{G} bewegt, mittels der
Taste \kbd{S} skaliert und mittels der Taste \kbd{R} rotiert werden.
Dadurch kÃ¶nnen die UVs auch entsprechend den BedÃ¼rfnissen in einem
Projekt angepasst werden.

\marginnote{GrÃ¶sse der UVs}

Gerade bei komplexen Objekten mit vielen Details sind die UVs von
grosser Bedeutung. Je grÃ¶sser die UV ist, desto detailliertere Inhalte
kÃ¶nnen innerhalb der dazugehÃ¶rigen Faces dargestellt werden.
Dementsprechend ist es sinnvoll, fÃ¼r Bereiche mit weniger benÃ¶tigten
Details kleinere UVs zu verwenden und fÃ¼r Bereiche, die mehr Details
benÃ¶tigen, grÃ¶ssere UVs zu verwenden. Gerade wenn mittels Blender eigene
Texturen erstellt werden, wird dieses Vorgehen relevant. FÃ¼r die
nÃ¤chsten Kapitel muss allerdings noch nicht zu stark auf die
GrÃ¶ssenverhÃ¤ltnisse der UVs geachtet werden.

\chapter{Texturen zu einem Material
hinzufÃ¼gen}\label{texturen-zu-einem-material-hinzufuxfcgen}

\section{Texture-Nodes hinzufÃ¼gen}\label{texture-nodes-hinzufuxfcgen}

\marginnote{Texturen als Teil eines Materials}

Bislang wurde betrachtet, wie die dreidimensionale Struktur mittels UVs
auf Texturen angewendet wird. Allerdings wurde noch nicht besprochen,
wie die Texturen auf dem Objekt erscheinen. Damit die Texturen auf ein
Objekt angewendet werden, mÃ¼ssen sie Teil eines Materials sein, welches
anschliessend auf das Objekt angewendet wird. Deshalb wird erneut der
Shader-Editor benÃ¶tigt, wenn die Texturen einem Objekt hinzugefÃ¼gt
werden sollen.

\marginnote{Textur muss mittels Nodes verbunden werden}

Wenn die Base-Color des Principled-BSDF-Shaders keine einheitliche Farbe
darstellen soll, muss der Base-Color eine Textur zugewiesen werden. In
der Farbbox der Base-Color besteht keine MÃ¶glichkeit, eine Textur
auszuwÃ¤hlen. Stattdessen muss eine Textur mit dem Base-Color-Input des
Principled-BSDF-Shaders verbunden werden. HierfÃ¼r wird ein neuer Node im
Shader-Editor benÃ¶tigt, welcher die Textur beinhaltet. Dieser wird
anschliessend mit der Base-Color verbunden.

\marginnote{Node hinzufÃ¼gen}

Um einen neuen Node hinzuzufÃ¼gen, wird die Tastenkombination \kbd{Shift}
+ \kbd{A} verwendet. Dadurch Ã¶ffnet sich beim Mauszeiger das
Â«\emph{Add}Â»-MenÃ¼ fÃ¼r den Shader-Editor. Anschliessend kann Ã¼ber das
MenÃ¼ der entsprechende Node gesucht werden. Die Nodes sind in
unterschiedliche Kategorien aufgeteilt, die zu einem spÃ¤teren Zeitpunkt
ausfÃ¼hrlich beschrieben werden. Statt den entsprechenden Node durch die
Kategorien auszuwÃ¤hlen, kann auch die Suchleiste zuoberst im MenÃ¼
ausgewÃ¤hlt werden und nach dem entsprechenden Node gesucht werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_23/23_1_Organisation_Texture_Node.png}

\caption{\label{fig-1_1}Image-Texture-Node, der neben dem
Principled-BSDF-Shader hinzugefÃ¼gt wurde.}

\end{figure}%

\marginnote{Texture-Node hinzufÃ¼gen}

Um eine Textur hinzuzufÃ¼gen, wird der Node Â«\emph{Image Texture}Â»
benÃ¶tigt. Dieser kann unter Â«\emph{Textures \textbar{} Image Texture}Â»
hinzufÃ¼gefÃ¼gt werden oder Ã¼ber die Suchleiste gesucht werden. Dadurch
erscheint der Image-Texture-Node, welcher mittels eines Mausklicks
platziert werden kann. Da der Output des Image-Texture-Nodes
anschliessend mit dem Input des Principled-BSDF-Shaders verbunden wird,
sollte der Image-Texture-Node links vom Principled-BSDF-Shader platziert
werden, wie in Abbildung 1 dargestellt.

\marginnote{Methoden, um dem Image-Texture-Node ein Bild zuzuweisen}

Der Image-Texture-Node verfÃ¼gt noch Ã¼ber keine Textur, sondern stellt
lediglich einen Platzhalter dar. Um ihm eine Textur hinzuzufÃ¼gen,
bestehen folgende MÃ¶glichkeiten im Image-Texture-Node:

\begin{itemize}
\tightlist
\item
  Â«\textbf{\emph{New}}Â»: Damit wird eine neue, einfarbige Textur
  erstellt, welche anschliessend in Blender bearbeitet und als Bilddatei
  auf dem Rechner abgespeichert werden kann.
\item
  Â«\textbf{\emph{Open}}Â»: Damit lÃ¤sst sich eine bestehende Bilddatei auf
  dem Rechner auswÃ¤hlen und dem Image-Texture-Node hinzufÃ¼gen. HierfÃ¼r
  Ã¶ffnet sich ein Browser-Fenster, in dem zum entsprechenden Speicherort
  der Textur navigiert und die entsprechende Bilddatei ausgewÃ¤hlt werden
  kann.
\item
  \textbf{Dropdown-MenÃ¼ auf der linken Seite}: Damit lassen sich bereits
  in Blender geladene Bilddateien auswÃ¤hlen und dem Image-Texture-Node
  zuweisen.
\end{itemize}

\marginnote{HinzugefÃ¼gte Textur im Image-Texture-Node}

Sobald dem Image-Texture-Node eine Textur zugewiesen wurde, wird der
Name dieser Textur anstelle der Auswahloptionen Â«\emph{New}Â» und
Â«\emph{Open}Â» angezeigt. Mittels des Ordner-Icons neben dem Namen kann
eine andere Textur geÃ¶ffnet und dem Image-Texture-Node hinzugefÃ¼gt
werden, und mittels des Kreuz-Icons kann die Textur aus dem
Image-Texture-Node entfernt werden.

\marginnote{Image-Texture-Node verbinden}

Der Image-Texture-Node beinhaltet nun die geladene Bilddatei als
Information, die er mittels des Outputs Â«\emph{Color}Â» weiterleiten
kann. Diese Farbe stellt nun keine einheitliche Farbe mehr dar, sondern
die Bilddatei. Der Color-Output des Image-Texture-Nodes kann nun mit dem
Base-Color-Input des Principled-BSDF-Shaders verbunden werden, wie in
Abbildung 2 dargestellt. Dadurch verschwindet das Auswahlfeld, mit der
eine Farbe fÃ¼r die Base-Color des Principled-BSDF-Shaders ausgewÃ¤hlt
werden kann. Dies liegt daran, dass dieser Informationsparameter fÃ¼r die
Farbe bereits belegt ist, nÃ¤mlich durch die Textur, welche mit dem Input
der Base-Color verbunden wurde. Wird das Objekt, zu dem das Material
gehÃ¶rt, nun im 3D-Viewport-Editor in der Material-Preview betrachtet,
sollte die Textur des Objektes nun zu erkennen sein.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_23/23_2_Texture_Node_Connected.png}

\caption{\label{fig-1_2}Verbindung zwischen einem Image-Texture-Node und
der Base-Color des Principled-BSDF-Shaders.}

\end{figure}%

Merke\ldots{}

Texturen werden jeweils auf Materialien angewendet.

Um eine Textur einem Material hinzuzufÃ¼gen, wird diese mit einem
Image-Texture-Node dem Material hinzugefÃ¼gt und Ã¼ber einen Faden mit dem
farbgebenden Input des Shaders verbunden.

\section{Texture-Mapping
hinzufÃ¼gen}\label{texture-mapping-hinzufuxfcgen}

\marginnote{Mapping-Node}

Die Texturen, welche Ã¼ber den Image-Texture-Node mit dem
Principled-BSDF-Shader verbunden werden, kÃ¶nnen auch variiert werden. So
lassen sich die Positionen verschieben, rotieren und skalieren. Damit
dies mÃ¶glich ist, wird ein Â«\emph{Mapping}Â»-Node benÃ¶tigt. Dieser ist im
Add-MenÃ¼ unter Â«\emph{Vector \textbar{} Mapping}Â» auffindbar. Der
Mapping-Node sollte dabei links vom Image-Texture-Node platziert werden,
da der Vector-Output des Mapping-Nodes mit dem Vector-Input des
Image-Texture-Nodes verbunden wird.

\marginnote{Texture-Coordinate-Node}

Durch die Verbindung des Mapping-Nodes mit dem Image-Texture-Node wird
die Textur nicht mehr auf dem Objekt angezeigt. Dies liegt daran, dass
der Mapping-Node keine Informationen darÃ¼ber verfÃ¼gt, wie die Texturen
jeweils auf ein Objekt angewendet werden. Deshalb wird ein Node
benÃ¶tigt, welcher dem Mapping-Node diese Informationen Ã¼bermittelt --
nÃ¤mlich der Â«\emph{Texture Coordinate}Â»-Node. Der
Texture-Coordinate-Node ist im Â«\emph{Add}Â»-MenÃ¼ jeweils unter
Â«\emph{Input \textbar{} Texture Coordinate}Â» zu finden. Dieser Node
sollte links vom Mapping-Node platziert werden, damit er anschliessend
mit dem Vector-Input des Mapping-Nodes verbunden werden kann.

\marginnote{Outputs des Texture-Coordinate-Nodes}

Im Texture-Coordinate-Node gibt es sechs verschiedene Outputs, die mit
dem Vector-Input des Mapping-Nodes verbunden werden kÃ¶nnen. Jeder dieser
Outputs beschreibt eine andere Methode, wie die Texturen auf ein Objekt
angewendet werden kÃ¶nnen. Wenn der entsprechende Output mit dem
Vector-Input verbunden wird, wird diese Methode angewendet.

\marginnote{Verbindung von Texture-Coordinate-und Mapping-Node}

HÃ¤ufig werden die UVs verwendet, um das Mapping der Texturen auf das
Objekt zu bestimmen. Dabei handelt es sich um die Standardoption, welche
der Image-Texture-Node ohne den Mapping-Node durchfÃ¼hren wÃ¼rde. Somit
wird in der Regel der UV-Output des Texture-Coordinate-Nodes mit dem
Vector-Input des Mapping-Nodes verbunden und der Vector-Output des
Mapping-Nodes mit dem Vector-Input des Image-Texture-Nodes, so wie in
Abbildung 3. Durch diese Anordnung wird die Textur wieder auf dem Objekt
sichtbar.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_23/23_3_Texture_Node_Mapping.png}

\caption{\label{fig-1_3}Ein Image-Texture-Node, der mit einem
Texture-Coordinate- und einem Mapping-Node verbunden ist.}

\end{figure}%

\marginnote{Zuordnungspunkte der Texturen bewegen}

Durch den Mapping-Node ist es nun mÃ¶glich, die Darstellung der Textur
auf dem Objekt anzupassen. Durch eine VerÃ¤nderung der Werte im Bereich
Â«\emph{Location}Â» kann die Textur etwa verschoben werden. Genau genommen
wird dabei nicht die Textur verschoben, sondern die Zuordnungspunkte
(z.B. UVs), auf denen die Textur dargestellt wird. Hinsichtlich der
Z-Achse zeigt sich dabei kein Unterschied, da diese auf dem
zweidimensionalen Zuordnungssystem nicht berÃ¼cksichtigt wird.

\marginnote{Skalierung und Rotation des Zuordnungsbereichs}

Mittels des Bereichs Â«\emph{Rotation}Â» werden die Zuordnungspunkte
rotiert und mittels des Bereichs Â«\emph{Scale}Â» werden die
Zuordnungsbereiche skaliert. Eine Skalierung um den Wert 2 fÃ¼hrt dazu,
dass die Zuordnungspunkte doppelt so gross Ã¼ber die Textur erstreckt
werden. Als Folge erscheinen die Objekte und Muster auf der Textur
kleiner auf dem Objekt. Wenn die Muster der Textur einen grÃ¶sseren
Bereich auf dem Objekt einnehmen sollen, muss ein Wert kleiner als 1
eingestellt werden. Dies fÃ¼hrt dazu, dass der Zuordnungsbereich
verkleinert wird und somit die Muster grÃ¶sser in diesem Bereich
erscheinen.

\section{Schnelleres HinzufÃ¼gen von
Image-Texture-Nodes}\label{schnelleres-hinzufuxfcgen-von-image-texture-nodes}

\marginnote{Node-Verbindungen erstellen als zentraler Bestandteil des Texturierens}

Die soeben aufgezeigte Verbindung von Nodes ist essenziell fÃ¼r das
HinzufÃ¼gen von Texturen. Deshalb besteht ein grÃ¶sserer Teil des
Texturierens aus dem HinzufÃ¼gen der Nodes, wie gerade dargestellt. WÃ¤re
es nicht praktisch, wenn mittels eines einzelnen Klicks diese Nodes
direkt hinzugefÃ¼gt werden kÃ¶nnten?

\marginnote{Node-Wrangler-Addon aktivieren}

Dank einem Add-on, welches direkt mit Blender mitgeliefert wird, ist
dies sehr leicht mÃ¶glich. Es handelt sich dabei um das
Node-Wrangler-Add-on. Um dieses zu aktivieren, mÃ¼ssen die Einstellungen
aufgerufen werden (\emph{Edit \textbar{} Preferences}) und darin auf der
linken Seite der Reiter Â«\emph{Add-ons}Â» ausgewÃ¤hlt werden. Im Suchfeld
kann anschliessend nach Â«\emph{Node Wrangler}Â» gesucht werden.
Anschliessend mÃ¼sste die Zeile Â«\emph{Node: Node Wrangler}Â» angezeigt
werden. Durch das Aktivieren des Kontrollkastens am Zeilenanfang wird
das Add-on aktiviert, sodass das Einstellungsfenster bereits wieder
geschlossen werden kann.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_23/23_4_Node_Wrangler_Activated.png}

\caption{\label{fig-1_4}Aktiviertes Node-Wrangler-Add-on.}

\end{figure}%

\marginnote{Vorlage fÃ¼r Image-Textures hinzufÃ¼gen}

Wenn nun ein Node ausgewÃ¤hlt wird, indem er angeklickt wird, kann die
Tastenkombination \kbd{Ctrl} + \kbd{T} gedrÃ¼ckt werden. Danach wird
automatisch ein Texture-Coordinate-Node, verbunden mit einem
Mapping-Node und dieser wiederum verbunden mit einem Image-Texture-Node,
hinzugefÃ¼gt und mit dem ersten freien Input des ausgewÃ¤hlten Nodes
verbunden. Dies erspart das Suchen und Anordnen der einzelnen
Komponenten.

\marginnote{Bilder direkt in den Shader-Editor hineinziehen}

Weiterhin ist es zudem mÃ¶glich, dass Bilddateien direkt vom Desktop oder
aus Ordnern in den Shader-Editor hineingezogen werden. Diese Bilddateien
werden anschliessend dem aktuell bearbeiteten Material als
Image-Texture-Node hinzugefÃ¼gt, mÃ¼ssen allerdings noch mit dem
entsprechenden Shader verbunden werden. Wenn das Node-Wrangler-Add-on
aktiviert ist, kÃ¶nnen diesem Image Texture-Node mit der
Tastenkombination \kbd{Ctrl} + \kbd{T} zudem ein Texture-Coordinate-Node
und ein Mapping-Node hinzugefÃ¼gt werden.

Merke\ldots{}

Texturen werden mit einem Mapping- und einem Texture-Coordinate-Node
versehen, damit die Texturen Ã¼ber den Mapping-Node angepasst werden
kÃ¶nnen.

Ãœbung 14: Textur zuweisen

\textbf{Ãœbung 14.1}

FÃ¼gen Sie die Textur Â«Rocks024S\_4K\_Color.jpgÂ» der Base-Color eines
Materials hinzu, welches Sie dem StandardwÃ¼rfel zugewiesen haben.

\chapter{Texturen fÃ¼r Parameter
verwenden}\label{texturen-fuxfcr-parameter-verwenden}

\marginnote{Checker-Textur innerhalb von Blender erstellen}

Es ist auch mÃ¶glich, innerhalb von Blender eigene Texturen zu emulieren.
Beispielsweise kann innerhalb des Shader-Editors eine Checker-Textur
hinzugefÃ¼gt werden. Diese ist im Add-MenÃ¼ unter Â«\emph{Texture
\textbar{} Checker Texture}Â» zu finden. Diese kann anschliessend mit der
Base-Color des Principled-BSDF-Shaders verbunden werden, wie in
Abbildung 1 abgebildet. Dadurch wird ein schachbrettartiges Muster aus
zwei Farben erstellt und als Grundfarbe verwendet. Die Farbe kann dabei
beliebig verÃ¤ndert werden, beispielsweise in Schwarz und Weiss, sodass
eine Textur entsteht, wie sie in Abbildung 2 auf den StandardwÃ¼rfel
angewendet wurde. Ãœber die beiden Farbboxen zu den Parametern
Â«\emph{Color1}Â» und Â«\emph{Color2}Â» kÃ¶nnen die Farben verÃ¤ndert werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_24/24_1_Checker_Texture_Base_Color_Connected.png}

\caption{\label{fig-1_1}Eine Checker-Textur, die mit der Base-Color des
Principled-BSDF-Shaders verbunden ist.}

\end{figure}%

\marginnote{Checker-Textur mit Roughness verbinden}

Bislang wurden Texturen lediglich verwendet, um die Farbe der
OberflÃ¤chen zu variieren. Es ist allerdings auch mÃ¶glich, dass andere
Parameter eines Shaders mittels Texturen variiert werden kÃ¶nnen.
Beispielsweise kÃ¶nnte die Checker-Textur statt mit der Base-Color mit
der Roughness verbunden werden. Abbildung 3 stellt denselben
StandardwÃ¼rfel wie in Abbildung 2 dar, jedoch wurde bei ihm die
Checker-Textur mit dem Roughness-Input des Principled-BSDF-Shaders
verbunden statt mit der Base-Color. ZusÃ¤tzlich wurde die Base-Color auf
blau gestellt, um die VerÃ¤nderungen besser sichtbar zu machen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_24/25_2_Checker_Texture.png}

\caption{\label{fig-1_2}Der StandardwÃ¼rfel mit einer schwarz-weissen
Checker-Textur als Input fÃ¼r die Base-Color.}

\end{figure}%

\marginnote{VerÃ¤nderung der Roughness Ã¼ber die OberflÃ¤che hinweg}

Was ist in Abbildung 3 mit dem Material geschehen? Die Farbe ist Ã¼ber
die gesamte OberflÃ¤che identisch -- und trotzdem scheint die Textur
einen Einfluss zu haben. In diesem Fall wurden die Farbwerte der Textur
Ã¼bernommen und mit diesen die Roughness angepasst. Bereiche, welche in
der Abbildung 2 eine schwarze Farbe aufwiesen, sind in der Abbildung 3
nun deutlich glatter und reflektieren das Licht dadurch gebÃ¼ndelter.
Bereiche, welche in der Abbildung 2 hingegen eine weisse Farbe
aufwiesen, sind in der Abbildung 3 nun deutlich rauer und reflektieren
das Licht gestreuter. Somit variiert die Roughness nun basierend auf der
Textur.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_24/25_3_Roughness_Checker-Texture.png}

\caption{\label{fig-1_3}Der StandardwÃ¼rfel mit einer schwarz-weissen
Checker-Textur als Input fÃ¼r die Roughness.}

\end{figure}%

\marginnote{Farbwerte kÃ¶nnen auch als Faktoren verwendet werden}

In diesem Beispiel wurden die Farben Schwarz und Weiss in der
Checker-Textur verwendet. Schwarz weist einen RGB-Wert von 0-0-0 auf und
einen HSV-Wert von 0-0-0. Weiss weist hingegen einen RGB-Wert von 1-1-1
auf und einen HSV-Wert von 0-0-1. Der Principled-BSDF-Shader hat diese
Werte von der Checker-Textur Ã¼bernommen und diese als Parameter fÃ¼r die
Roughness eingestellt.

\marginnote{Schwarz fÃ¼r den Wert 0, weiss fÃ¼r den Wert 1 und grau fÃ¼r die Abstufungen dazwischen}

An den Stellen mit einer schwarzen Farbe wird eine Roughness von 0
eingesetzt und an den Stellen mit einer weissen Farbe eine Roughness von
1. Durch eine Verdunkelung oder eine Erhellung der Farben innerhalb des
Checker-Texture-Nodes -- dies kann im Reiter Â«\emph{HSV}Â» unter der
Zeile Â«\emph{V}Â» erzielt werden -- variiert auch die Roughness
dementsprechend fÃ¼r die Bereiche, welche diese Farbe innehaben. Dieses
Prinzip kann auch fÃ¼r andere Werte Ã¼bernommen werden. Auch der Wert fÃ¼r
Metallic kann mit dieser Vorgehensweise Ã¼ber Texturen variiert werden.

\chapter{Welche Bilder eignen sich als
Texturen?}\label{welche-bilder-eignen-sich-als-texturen}

\marginnote{Jedes Bild kann eine Textur sein}

Damit einem Objekt Texturen hinzugefÃ¼gt werden kÃ¶nnen, werden zunÃ¤chst
einmal Texturen benÃ¶tigt. Rein theoretisch lÃ¤sst sich jedes Bild als
Textur verwenden. Es gibt dabei allerdings, gerade wenn eine Textur Ã¼ber
grÃ¶ssere Bereiche erstreckt wird, ein hÃ¤ufig auftauchendes Problem,
welches in Abbildung 1 dargestellt wird.

\marginnote{Schnitte durch Wiederholungsmuster}

Auf der linken Seite der Abbildung 1 ist ein Bild dargestellt, welches
als Textur verwendet wird. Gerade bei grÃ¶sseren FlÃ¤chen wird die
Skalierung der Textur so angepasst, dass die Textur jeweils wiederholt
wird. Dadurch kÃ¶nnte ein Muster, wie es auf der rechten Seite der
Abbildung 1 abgebildet ist, entstehen. Hierbei wurde die Textur entlang
beider Achsen einmal wiederholt. Die Strukturen am oberen Ende des
Bildes passen nicht zu den Strukturen am unteren Ende des Bildes. Ebenso
verhÃ¤lt es sich mit den Strukturen am linken und am rechten Rand des
Bildes. Dies fÃ¼hrt dazu, dass ein Schnitt an der Wiederholungsstelle der
Textur ersichtlich wird.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_25/25_1_Non_Seamless_Texture.png}

\caption{\label{fig-1_1}Links eine Textur und rechts eine 2x2-Anordnung
dieser Textur.}

\end{figure}%

\marginnote{Nahtlose Texturen}

Bilder, die besonders gut als Textur geeignet sind, weisen am linken und
am rechten Rand sowie am oberen und am unteren Rand des Bildes
identische Strukturen auf, sodass bei einer Wiederholung ein fliessender
Ãœbergang entsteht. Abbildung 2 zeigt ein Beispiel einer solchen Textur
(\url{https://ambientcg.com/view?id=Rocks005}). Solche Texturen werden
als nahtlose Texturen (seamless textures) bezeichnet. Gerade bei
namhaften Datenbanken mit hochwertigen Texturen sind die Texturen in der
Regel so bearbeitet, dass sie nahtlos sind.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_25/25_2_Seamless_Texture.png}

\caption{\label{fig-1_2}Links eine nahtlose Textur und rechts eine
2x2-Anordnung dieser Textur.}

\end{figure}%

\marginnote{Texturen-Datenbanken}

Es gibt eine Reihe verschiedener Datenbanken im Internet, die
verschiedene Texturen anbieten. Zu diesen gehÃ¶ren beispielsweise:

\begin{itemize}
\tightlist
\item
  \url{https://polyhaven.com/}: Poly Haven verfÃ¼gt sowohl Ã¼ber Texturen
  als auch Ã¼ber 3D-Modelle und HDRIs, welche von anderen Nutzern gratis
  zur VerfÃ¼gung gestellt werden. Alle Inhalte auf dieser Plattform
  fallen unter die CC0-Lizenz und kÃ¶nnen problemlos fÃ¼r alle Projekte
  verwendet werden.
\item
  \url{https://ambientcg.com/} : AmbientCG beinhaltet wie Poly Haven
  eine Reihe von Texturen, 3D-Modellen und HDRIs, welche problemlos fÃ¼r
  alle Projekte verwendet werden kÃ¶nnen.
\item
  \url{https://3dtextures.me/} : Auf dieser Website sind eine Reihe
  verschiedener Texturen zu finden, welche alle unter der CC0-Lizenz
  stehen und somit fÃ¼r alle Projekte verwendet werden kÃ¶nnen. Nebst
  realistischen Texturen werden auch stilisierte Texturen angeboten.
\item
  \url{https://www.textures.com} : Auf dieser Website werden
  verschiedene Texturen, Bilder, HDRIs und 3D Objekte angeboten. Eine
  Registrierung ist erforderlich und der Nutzer erhÃ¤lt ein tÃ¤gliches
  Kontingent an kostenlosen Credits, um Texturen zu beziehen. Die
  Texturen kÃ¶nnen fÃ¼r verschiedene Projekte verwendet werden, aber mit
  EinschrÃ¤nkungen. So dÃ¼rfen diese Texturen etwa nicht fÃ¼r ein
  Open-Source-Videogame verwendet werden. Es empfiehlt sich deshalb,
  einen Blick in die Lizenzbedingungen der Website zu werfen.
\end{itemize}

\chapter{Arten von Texturen}\label{arten-von-texturen}

\marginnote{Verschiedene Arten von Texturen}

Beim Herunterladen der Texturen von Datenbanken fÃ¤llt auf, dass eine
Reihe verschiedener Texturen angeboten wird. Beim Download wird oftmals
nicht nur eine Textur mit Farbe heruntergeladen, sondern auch andere
Texturarten. Diese werden in diesem Kapitel ausfÃ¼hrlich beschrieben.

\section{Color-Textur}\label{color-textur}

\marginnote{Color-Textur fÃ¼r Materialfarben}

Bislang wurden Texturen verwendet, um mittels Bildern Farbvariationen
innerhalb eines Objektes zu erstellen. Diese Textur wird als
Color-Textur bezeichnet. Sie beinhaltet die Farben, welche auf dem
Objekt zu sehen sind. In Online-Datenbanken werden diese Texturen
teilweise mit der Endung Â«colorÂ» oder Â«colÂ» versehen.

\section{Albedo-Textur}\label{albedo-textur}

\marginnote{Albedo-Textur beinhalten keine Schatten}

Die Albedo-Textur stellt einen Spezialfall der Color-Textur dar. Dabei
handelt es sich ebenfalls um die Farben, welche auf das jeweilige
Material Ã¼bertragen werden. Im Unterschied zur Color-Textur beinhaltet
die Albedo-Textur allerdings keine Schatten oder Lichtpunkte. In
Online-Datenbanken werden diese Texturen teilweise mit der Endung
Â«albedoÂ» oder Â«albÂ» versehen. In der Regel wird die Albedo-Textur statt
der Color-Textur angeboten. Sie kann also wie die Farb-Textur verwendet
werden.

\section{Metallic-Textur}\label{metallic-textur}

\marginnote{Metallic-Textur, um Metallic-Parameter variieren zu lassen}

Die Metallic-Textur stellt eine schwarz-weisse Textur dar. Mit ihr wird
angegeben, an welchen Teilen der OberflÃ¤che welcher Metallic-Wert
verwendet wird. Je heller ein Punkt auf der Textur, desto hÃ¶her ist der
Metallic-Wert an dieser Stelle. In Online-Datenbanken werden diese
Texturen teilweise mit der Endung Â«metallicÂ» oder Â«metalÂ» versehen.

\marginnote{Metallic-Textur verfeinert die Color-Textur}

Die Metallic-Textur wird jeweils zusÃ¤tzlich zur Color-Textur verwendet
und mit dem Metallic-Input verbunden. Eine Textur, die sowohl aus Metall
als auch aus Rost besteht, wÃ¼rde etwa an den Stellen, an denen Rost
dargestellt wird, einen geringeren Metallic-Wert aufweisen. Abbildung 1
zeigt links ein Beispiel einer solchen Color-Textur und rechts die
dazugehÃ¶rige Metallic-Textur, bei der rostige Anteile durch schwarze
Anteile dargestellt werden (Bildquelle:
\url{https://ambientcg.com/view?id=Metal022})

\begin{figure}

\includegraphics{Chapters/Images/Chapter_26/26_1_Color_Metall_Comparison.png}

\caption{\label{fig-1_1}Links die Color-Textur eines verrosteten
Metalls, rechts die dazugehÃ¶rige Metallic-Textur.}

\end{figure}%

\marginnote{Fehlende Metallic-Textur}

Bei Texturen, die dielektrische Materialien abbilden, werden selten
Metallic-Texturen mitgeliefert. Dies liegt daran, dass bei diesen
Texturen Ã¼ber die gesamte Textur hinweg kein Metall auftritt. In diesem
Fall wÃ¼rde die Metallic-Textur lediglich ein schwarzes Bild darstellen.
Statt also ein Bild zu verwenden, kann direkt der Metallic-Parameter auf
0 gesetzt werden.

\section{Roughness-Textur}\label{roughness-textur}

\marginnote{Roughness-Textur, um Roughness-Parameter variieren zu lassen}

Die Roughness-Textur funktioniert Ã¤hnlich wie die Metallic-Textur. Sie
ist ebenfalls schwarz-weiss aufgebaut und gibt mit ihren
Helligkeitswerten an, wie hoch die Roughness an der entsprechenden
Stelle der Textur sein sollte. Die Roughness-Textur wird zusÃ¤tzlich zur
Color-Textur verwendet und mit dem Roughness-Input des Shaders
verbunden. In Online-Datenbanken werden diese Texturen teilweise mit der
Endung Â«roughnessÂ» oder Â«roughÂ» versehen.

\section{Glossy-Textur}\label{glossy-textur}

\marginnote{Glossy-Textur als Gegenteil der Roughness-Textur}

Die Glossy-Textur beschreibt das Gegenteil der Roughness-Textur. Sie ist
ebenfalls schwarz-weiss aufgebaut, allerdings stehen bei ihr hellere
Stellen fÃ¼r Bereiche, die eine geringere Roughness aufweisen und dadurch
gebÃ¼ndelter zu reflektieren scheinen. Dies stellt somit gerade die
invertierte Einstellung der Roughness dar. Eine Glossy-Textur kann mit
dem Roughness-Input eines Shaders verbunden werden. Dazwischen sollte
allerdings ein Â«\emph{Invert}Â»-Node eingefÃ¼gt werden. Dadurch werden die
Werte invertiert, sodass sie einer Roughness-Textur entsprechen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_26/26_2_Gloosy_Nodes.png}

\caption{\label{fig-1_2}Node-Anordnung, um mit einer Glossy-Textur
umzugehen.}

\end{figure}%

\section{Normal-Textur}\label{normal-textur}

\marginnote{Normal-Textur, um Unebenheiten im Objekt zu simulieren}

Die Normal-Texturen fallen visuell auf, da sie eine bizarrerscheinende
blaue VerfÃ¤rbung aufweisen, wie die Normal-Textur auf der rechten Seite
der Abbildung 3 (Bildquelle:
\url{https://ambientcg.com/view?id=Rocks005}). Mittels dieser Textur
kÃ¶nnen minimale Unebenheiten in einem Objekt simuliert werden. Dabei
stellt jede Farbe, die in diesem Bild auftritt, eine Achse dar, anhand
derer die simulierten Unebenheiten berechnet werden. In
Online-Datenbanken werden diese Texturen teilweise mit der Endung
Â«normalÂ» oder Â«normÂ» versehen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_26/26_3_Color_Normal_Comparison.png}

\caption{\label{fig-1_3}Links eine Color-Textur, rechts die dazugehÃ¶rige
Normal-Textur.}

\end{figure}%

\marginnote{Zwei Arten von Normal-Texturen}

Bei einigen Datenbanken werden zwei verschiedene Arten von
Normal-Texturen geliefert. Eine, welche jeweils die Endung Â«GLÂ» innehat,
und eine, welche jeweils die Endung Â«DXÂ» innehat. Beide Arten stellen
Normal-Texturen dar, jedoch agieren sie unterschiedlich, je nachdem,
welche Programmierschnittstelle ihnen zugrunde liegt. Normal-Texturen
mit der Endung Â«GLÂ» kÃ¶nnen fÃ¼r Applikationen verwendet werden, welche
auf Â«OpenGLÂ» basieren -- hierzu gehÃ¶rt Blender. Deshalb werden jeweils
diese Normal-Texturen benÃ¶tigt. Die Normal-Texturen mit der Endung Â«DXÂ»
beziehen sich auf Applikationen, die Â«DirectXÂ» verwenden.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.1909}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.1727}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.6273}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{OpenGL-Style}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{DirectX-Style}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Dateiendung} & GL & DX \\
\textbf{Software} & Blender

Maya

Unity & 3ds Max

Substance

Unreal Engine \\
\textbf{Render-Engines} & Cycles

Eevee

Redshift

Arnold

Octane & V-Ray

Corona (bei diesen kann allerdings auch OpenGL eingestellt werden) \\
\end{longtable}

\marginnote{Verwendung der Normal-Texturen}

Um die Normal-Texturen einem Material beizufÃ¼gen, wird ein Node
benÃ¶tigt, welcher die Daten der Normal-Texturen extrahiert und daraus
die Unebenheiten berechnet. HierfÃ¼r wird der Bump-Node verwendet. Dieser
ist im Â«\emph{Add}Â»-MenÃ¼ des Shader-Editors unter Â«\emph{Vector
\textbar{} Bump}Â» zu finden. Anschliessend wird der Color-Output der
Normal-Textur mit dem Â«\emph{Height}Â»-Input des Bump-Nodes verbunden.
Dadurch erhÃ¤lt der Bump-Node als Input die HÃ¶he fÃ¼r die Unebenheiten
basierend auf der Textur. Wie stark diese Unebenheiten anschliessend
emuliert werden sollen, kann mittels des Reglers Â«\emph{Strength}Â» im
Bump-Node eingestellt werden. Der Normal-Output des Bump-Nodes wird
anschliessend mit dem Normal-Input des Principled-BSDF-Shaders
verbunden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_26/26_4_Normal_Texture.png}

\caption{\label{fig-1_4}Anordnung der Normal-Textur mit einem Bump-Node
zwischen dem Image-Texture-Node und dem Principled-BSDF-Node.}

\end{figure}%

\section{Displacement-Textur}\label{displacement-textur}

\marginnote{Displacement-Textur, um grÃ¶ssere Unebenheiten zu emulieren oder zu erstellen}

Die Displacement-Textur funktioniert Ã¤hnlich wie die Normal-Textur. Sie
wird ebenfalls fÃ¼r Unebenheiten im Material verwendet, allerdings fÃ¼r
deutlich grÃ¶ssere Unebenheiten. Sie funktioniert wie die Roughness- und
die Metallic-Textur auf einer Schwarz-Weiss-Basis. Das heisst: Je heller
ein Wert an einer Stelle ist, desto hÃ¶her sollte die Unebenheit an
dieser Stelle sein. In Online-Datenbanken werden diese Texturen
teilweise mit der Endung Â«displacementÂ» oder Â«dispÂ» versehen. Manchmal
wird die Textur aber auch als Height-Textur bezeichnet und entsprechend
mit der Endung Â«heightÂ» versehen.

\marginnote{Displacement-Textur wird Ã¼ber Displacement-Node mit dem Material-Output verbunden}

Anders als die anderen Texturen, hat die Displacement-Textur keinen
Shader als Ziel, sondern den Material-Output-Node. Dazwischen wird ein
Displacement-Node eingefÃ¼gt. Dieser kann im Â«\emph{Add}Â» MenÃ¼ unter
Â«\emph{Vector \textbar{} Displacement}Â» hinzugefÃ¼gt werden. Der
Color-Output der Displacement-Textur wird anschliessend mit dem
Height-Input des Displacement-Nodes verbunden. Dadurch erhÃ¤lt der
Displacement-Node die Information, an welchen Stellen der Textur eine
hÃ¶here Abweichung und an welchen eine geringere Abweichung vom Mesh
emuliert werden soll. Ãœber den Reiter Â«\emph{Scale}Â» kann zudem die
StÃ¤rke dieser Abweichung skaliert werden. In der Regel reichen bereits
sehr kleine Werte (z.B. 0.001) aus, wÃ¤hrend grÃ¶ssere Werte verzerrend
wirken. Der Displacement-Output des Displacement-Nodes kann
anschliessend mit dem Displacement-Input des Material-Output-Nodes
verbunden werden.

\marginnote{Mesh mittels Displacement-Textur verformen}

Die Displacement-Textur kann auch verwendet werden, um das Mesh
tatsÃ¤chlich anhand der Textur zu verformen. Dies ist zum einen mit dem
Displacement-Modifier mÃ¶glich. Dabei werden die einzelnen Vertices des
Meshes basierend auf der Textur deformiert. Dies bedeutet allerdings
auch, dass sehr viele Vertices benÃ¶tigt werden, damit mÃ¶glichst viele
Details erfasst werden. In der Render-Engine Cycles kann zum anderen
eingestellt werden, dass basierend auf dem Displacement-Material-Output
das Mesh verformt wird. Allerdings wird auch dabei eine Vielzahl von
Vertices benÃ¶tigt. In der bislang verwendeten Render-Engine Eevee ist
dies jedoch nicht mÃ¶glich.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_26/26_5_Displacement_Nodes.png}

\caption{\label{fig-1_5}Anordnung der Displacement-Textur mit einem
Displacement-Node zwischen dem Image-Texture-Node und dem
Material-Output-Node.}

\end{figure}%

\section{Ambient-Occlusion-Textur}\label{ambient-occlusion-textur}

\marginnote{Ambient-Occlusion-Textur fÃ¼r Schatten}

Die Ambient-Occlusion-Textur stellt gewissermassen das Gegenteil der
Albedo-Textur dar. WÃ¤hrend die Albedo-Textur die Grundfarben einer
Textur ohne Schattenanteile beinhaltet, besteht die
Ambient-Occlusion-Textur lediglich aus Schattenanteilen. In
Online-Datenbanken werden diese Texturen teilweise mit der Endung
Â«ambientocclusionÂ», Â«aoÂ», Â«occlusionÂ» oder Â«occÂ» versehen.

\marginnote{Ambient-Occlusion-Textur verwenden}

Die Ambient-Occlusion-Textur wird selten bei der Texturierung verwendet.
Wenn sie allerdings berÃ¼cksichtigt werden soll, empfiehlt es sich, diese
mit der Color-Textur zu kombinieren. HierfÃ¼r wird ein
Â«\emph{MixRGB}Â»-Node verwendet, welcher zwei Farben miteinander mischen
kann. Dieser ist im Â«\emph{Add}Â»-MenÃ¼ unter Â«\emph{Color \textbar{}
MixRGB}Â» zu finden. Anschliessend kann der Color-Output der Color-Textur
mit dem ersten Color-Input (Â«\emph{Color1}Â») verbunden werden und der
Color-Output der Ambient-Occlusion-Textur mit dem zweiten Color-Output
(Â«\emph{Color2}Â»). Im Dropdown-MenÃ¼ auf der SchaltflÃ¤che Â«\emph{Mix}Â»
sollte zudem die Option Â«\emph{Multiply}Â» ausgewÃ¤hlt werden. Dadurch
werden die Schattenanteile mit den Farbwerten multipliziert (unter der
Einstellung Â«\emph{Mix}Â» wÃ¼rden sich lediglich graduelle Abstufungen
zwischen den beiden Texturen ergeben). Mithilfe des Reiters Â«\emph{Fac}Â»
kann anschliessend der Faktor definiert werden, mit dem die
Schattenanteile auf die Grundfarbe multipliziert werden sollen. Der
Color-Output des Mix-RGB-Nodes kann anschliessend mit dem
Base-Color-Input des Principled-BSDF-Shaders verbunden werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_26/26_6_AOC_Nodes.png}

\caption{\label{fig-1_6}Node-Anordnung, um die Ambient-Occlusion-Textur
mit der Color-Textur zu multiplizieren.}

\end{figure}%

\section{Alpha-Textur}\label{alpha-textur}

\marginnote{Alpha-Textur, um Transparenz zu definieren}

Die Alpha-Textur basiert ebenfalls auf Schwarz-Weiss-Werten und
definiert, an welchen Stellen eine OberflÃ¤che transparent sein soll. Der
Color-Output der Alpha-Textur wird jeweils mit dem Alpha-Input des
Principled-BSDF-Shaders verbunden. Die weissen Anteile der Textur
beschreiben jeweils Bereiche, die sichtbar bleiben sollen, wÃ¤hrend
schwarze Anteile der Textur jeweils die Bereiche beschreiben, welche
durch die Transparenz nicht sichtbar werden. Damit die Transparenz auch
beim Rendern sichtbar wird, werden noch weitere Einstellungen benÃ¶tigt,
welche zu einem spÃ¤teren Zeitpunkt ausfÃ¼hrlich beschrieben werden. In
Online-Datenbanken werden diese Texturen teilweise mit der Endung
Â«alphaÂ» oder Â«opacityÂ» versehen.

\section{Reflection-Textur}\label{reflection-textur}

\marginnote{Reflection-Textur}

Die Reflection-Textur -- teils auch als Specularity-Textur bezeichnet --
beschreibt, an welchen Stellen der Textur das Licht reflektiert werden
soll und an welchen nicht. Diese Einstellung wird allerdings bereits
durch die Roughness- und den Metallic-Wert ermittelt. Daher wird die
Reflection-Textur selten im Principled-BSDF-Shader verwendet. In
Online-Datenbanken werden diese Texturen teilweise mit der Endung
Â«specularityÂ», Â«specÂ», Â«reflectionÂ» oder Â«reflÂ» versehen.

\section{Und nun alle zusammen!}\label{und-nun-alle-zusammen}

\marginnote{FÃ¼r jede Texturart ein Node}

Die verschiedenen Texturarten beziehen sich grÃ¶sstenteils auf
unterschiedliche Inputs des Principled-BSDF-Shaders. Das heisst, dass
fÃ¼r jede Textur ein eigener Image-Texture-Node benÃ¶tigt wird, welcher
die entsprechende Textur beinhaltet und anschliessend mit den Inputs der
nÃ¤chsten Andockstellen verbunden wird.

\marginnote{Lediglich ein Mapping-Node fÃ¼r mehrere Texturen mit identischem Mapping}

ZusÃ¤tzlich benÃ¶tigt jeder Image-Texture-Node einen Mapping-Node, der
wiederum auf einen Texture-Coordinate-Node folgt. Dies ist allerdings
sehr unÃ¼bersichtlich und komplex. Da in der Regel alle Texturarten
innerhalb eines Materials in gleicher Weise auf das Objekt Ã¼bertragen
werden, kann deshalb fÃ¼r alle Image-Texture-Nodes derselbe Mapping-Node
verwendet werden. Dieser sendet anschliessend seine
Mapping-Informationen an alle nach ihm folgenden Nodes aus. Dadurch muss
lediglich dieser eine Node bearbeitet werden und das Mapping fÃ¼r alle
Texturarten wird gleichzeitig bearbeitet, statt dass eine Bearbeitung
fÃ¼r mehrere Mapping-Nodes erfolgen muss.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_26/26_7_Texture_Mapping_Presentation.png}

\caption{\label{fig-1_7}Anordnung von verschiedenen Texturarten zu einem
Material.}

\end{figure}%

\section{Texturen auf Material betrachten mithilfe des
Node-Wrangler-Add-ons}\label{texturen-auf-material-betrachten-mithilfe-des-node-wrangler-add-ons}

\marginnote{Bild eines Nodes direkt auf dem Objekt betrachten}

Bei der Arbeit mit vielen verschiedenen Texturen ist es manchmal
nÃ¼tzlich, wenn man direkt sehen kann, wie eine Textur aussieht.
Normalerweise wird im 3D-Viewport-Editor das finale Material, welches
durch den Material-Output-Node generiert wird, dargestellt. Mittels des
Node-Wrangler-Add-ons ist es allerdings mÃ¶glich, direkt den Einfluss
eines Nodes auf ein Material zu sehen.

\marginnote{Viewer-Node aktivieren}

Sobald das Node-Wrangler-Add-on aktiviert ist, kann im Shader-Editor
jeweils bei gedrÃ¼ckter \kbd{Ctrl}- + \kbd{Shift}-Taste auf einen
beliebigen Node innerhalb eines Materials geklickt werden. Daraufhin
wird der Output des ausgewÃ¤hlten Materials mit einem neu erstellten
Â«\emph{Viewer}Â»-Node verbunden, welcher mit dem Material-Output
verbunden ist. Im 3D-Viewport-Editor wird nun bildlich die Information
dargestellt, welche Ã¼ber diesen Output gerade an den nÃ¤chsten Node
Ã¼bergeben wird. Dadurch kÃ¶nnen die Texturen isoliert betrachtet werden,
ohne dass sie bereits innerhalb eines Shaders verarbeitet werden.

\marginnote{Viewer-Node deaktivieren}

Um wieder das richtige Material zu sehen, kann bei gedrÃ¼ckter
\kbd{Ctrl}- + \kbd{Shift}-Taste auf den Shader-Node geklickt werden.
Dieser wird anschliessend ohne den Viewer-Node dazwischen mit dem
Material-Output verbunden.

\chapter{Tutorial: Einen Hammer
texturieren}\label{tutorial-einen-hammer-texturieren}

\marginnote{Ziel dieser Aufgabe}

Als NÃ¤chstes wird anhand eines Modelles aufgezeigt, wie das Texturieren
erfolgt. Im Zip-Ordner Â«\emph{Hammer}Â» ist ein .blend-File aufzufinden,
in dem sich ein Mesh in der Form eines Hammers befindet. Nebst diesem
File sind im Ordner Â«\emph{Metal022\_4K-JPG}Â» verschiedene Texturarten
fÃ¼r ein metallisches Material aufzufinden. Dieses Material wird anhand
der Texturen in diesem Ordner erstellt und dem Hammerkopf zugewiesen.
Anschliessend wird eine weitere Textur gesucht und dem Holzstiel des
Hammers zugewiesen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_27/27_1_Final_Hammer.png}

\caption{\label{fig-1_1}Der texturierte Hammer als Ziel dieses
Tutorials.}

\end{figure}%

\section{UV-Mapping}\label{uv-mapping-1}

\marginnote{UV-Editor Ã¶ffnen}

Nach dem Ã–ffnen des .blend-Files wird der Hammer in Blender angezeigt.
In diesem Beispiel sollten zunÃ¤chst die UVs betrachtet werden. HierfÃ¼r
wird der UV-Editor benÃ¶tigt. Um diesen zu Ã¶ffnen, wird aus den Ecken des
3D-Viewport-Editors ein zweiter Editor herausgezogen. Dieser Editor wird
anschliessend als UV-Editor verwendet.

\marginnote{Faces auswÃ¤hlen, um UVs zu betrachten}

Um im UV-Editor die UVs des Hammers betrachten zu kÃ¶nnen, mÃ¼ssen die
jeweils anzuzeigenden Faces ausgewÃ¤hlt werden. HierfÃ¼r muss zunÃ¤chst der
Edit-Mode mit dem ausgewÃ¤hlten Hammer aktiviert werden. Damit alle UVs
betrachtet werden kÃ¶nnen, mÃ¼ssen alle Faces des Hammers mittels der
Taste \kbd{A} ausgewÃ¤hlt werden. Danach werden im UV-Editor die UVs
angezeigt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_27/27_2_Original_UVs.png}

\caption{\label{fig-1_2}UVs des Hammers.}

\end{figure}%

\marginnote{UVs mit Cube Projection neu berechnen}

Die angezeigten UVs mÃ¼ssen noch angepasst werden, da diese durch die
Erstellung des Hammers aus einem 3D-WÃ¼rfel entstanden sind. Deshalb wird
Blender der Befehl gegeben, dass das Programm selbststÃ¤ndig neue UVs
berechnen soll. HierfÃ¼r wird im Editor-Mode des 3D-Viewports-Editors die
Taste \kbd{U} gedrÃ¼ckt. Dadurch erscheint beim Mauszeiger das Menu
Â«\emph{UV Mapping}Â» in diesem MenÃ¼ wird die Option Â«\emph{Cube
Projection}Â» ausgewÃ¤hlt. Im UV-Editor werden nun die neu berechneten UVs
angezeigt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_27/27_3_UVS_Cube_Projection.png}

\caption{\label{fig-1_3}UVs nach der Bearbeitung mittels Cube
Projection.}

\end{figure}%

\section{Materialen erstellen}\label{materialen-erstellen}

\marginnote{Material-Slots hinzufÃ¼gen}

Im nÃ¤chsten Schritt geht es darum, dem Objekt die Materialien
zuzuweisen. HierfÃ¼r werden zwei Material-Slots benÃ¶tigt. Um diese zu
erstellen, wird im Properties-Editor der Material-Reiter geÃ¶ffnet und
darin zwei neue Slots fÃ¼r Materialien hinzugefÃ¼gt. HierfÃ¼r kann zweimal
auf die SchaltflÃ¤che Â«+Â» geklickt werden.

\marginnote{Reihenfolge der Materialien}

Manchmal ist es sinnvoll, sich Ã¼ber die Reihenfolge der zu erstellenden
Materialien Gedanken zu machen. Per Default werden alle Faces eines
Objekts dem ersten Material zugewiesen. Somit wÃ¤re es sinnvoll, als
zweites Material dasjenige zu verwenden, fÃ¼r welches die entsprechenden
Faces einfacher auszuwÃ¤hlen sind. In diesem Falle wÃ¤re dies das Holz,
welches lediglich die Faces des Stiels abdeckt. Deshalb ist es
sinnvoller dem zweiten Material das Holz zuzuweisen.

\marginnote{Materialien hinzufÃ¼gen}

ZunÃ¤chst wird auf den ersten Material-Slot geklickt, um diesen
auszuwÃ¤hlen und mit der SchaltflÃ¤che Â«\emph{New}Â» ein neues Material
hinzugefÃ¼gt. Dieses Material kann zu Â«MetallÂ» umbenannt werden. Danach
wird der zweite Material-Slot ausgewÃ¤hlt und diesem ebenfalls ein neues
Material hinzugefÃ¼gt, welches als Â«HolzÂ» benannt werden kann.

\marginnote{Faces fÃ¼r Holz-Material auswÃ¤hlen}

Im Edit-Mode kÃ¶nnen anschliessend alle Faces, welche zum Holzstiel
gehÃ¶ren, ausgewÃ¤hlt werden. Dazu kann ein Loop-Select verwendet werden.
HierfÃ¼r wird der Face-Selection-Modus verwendet und bei gedrÃ¼ckter
\kbd{Ctrl}-Taste auf ein Edge geklickt, welches entlang dem Stiel des
Hammers verlÃ¤uft. Dadurch sollten alle Faces des Stiels, ausser
dasjenige am Boden des Hammerstiels, ausgewÃ¤hlt worden sein. Das noch
nicht ausgewÃ¤hlte Face des Hammerstiels kann bei gedrÃ¼ckter
\kbd{Shift}-Taste durch einen Mausklick zur Auswahl hinzugefÃ¼gt werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_27/27_4_Faces_Wood.png}

\caption{\label{fig-1_4}Faces fÃ¼r das Holz-Material.}

\end{figure}%

\marginnote{Materialien anwenden}

Die ausgewÃ¤hlten Faces kÃ¶nnen als NÃ¤chstes dem Holz-Material hinzugefÃ¼gt
werden. HierfÃ¼r wird im Properties-Editor der zweite Material-Slot mit
dem Holz-Material ausgewÃ¤hlt und auf die SchaltflÃ¤che Â«\emph{Assign}Â»
geklickt. Wenn nun die Auswahl von Faces aufgelÃ¶st wird, indem in den
leeren Raum im 3D-Viewport-Editor geklickt wird, kann die Taste
Â«\emph{Select}Â» im Properties-Editor verwendet werden, um die zum
Holz-Material hinzugefÃ¼gten Faces auszuwÃ¤hlen. Dadurch kann Ã¼berprÃ¼ft
werden, ob die Faces korrekt zugewiesen wurden.

\section{Metall texturieren}\label{metall-texturieren}

\marginnote{Shader-Editor Ã¶ffnen}

Im Properties-Editor kann nun das Metall-Material ausgewÃ¤hlt werden.
Dieses Material wird nun als NÃ¤chstes bearbeitet. HierfÃ¼r muss der
Shader-Editor verwendet werden. Deshalb wird der UV-Editor, welcher
fortan nicht mehr benÃ¶tigt wird, zum Shader-Editor umgewandelt.
ZusÃ¤tzlich sollte im 3D-Viewport-Editor der
Material-Preview-Shading-Mode ausgewÃ¤hlt werden, damit Ã„nderungen am
Material auch dargestellt werden.

\marginnote{Image-Texture-Node hinzufÃ¼gen}

Als erstes wird dem Principled-BSDF-Shader im Shader-Editor eine
Image-Textur hinzugefÃ¼gt. HierfÃ¼r kann der Principled-BSDF-Shader
ausgewÃ¤hlt und die Tastenkombination \kbd{Ctrl} + \kbd{T} gedrÃ¼ckt
werden. Durch das Node-Wrangler-Add-on entsteht links vom
Principled-BSDF-Shader eine Image-Textur, welche durch einen
Mapping-Node und einen Textur-Coordinate-Node ihre Inputs bekommt. Der
Image-Textur-Node sollte automatisch mit der Base-Color des
Principled-BSDF-Shaders verbunden worden sein. FÃ¼r den Fall, dass diese
Tastenkombination nicht funktionieren, sollte Ã¼berprÃ¼ft werden, ob das
Node-Wrangler-Add-on aktiviert ist.

\marginnote{Color-Textur Ã¶ffnen}

Anschliessend kann im Image-Texture-Node auf die SchaltflÃ¤che
Â«\emph{Open}Â» geklickt werden. Im anschliessend geÃ¶ffneten Browser kann
zum Speicherort des Hammers navigiert werden und dort im Ordner
Â«\emph{Metal022\_4K-JPG}Â» die Datei Â«\emph{Metal022\_4K\_Color.jpg}Â»
ausgewÃ¤hlt werden. Dabei handelt es sich um die Color-Textur, welche
jeweils mit der Base-Color des Principled-BSDF-Shaders verbunden wird.

\marginnote{Image-Texture-Node fÃ¼r Metallic hinzufÃ¼gen}

Als NÃ¤chstes wird die Metallic-Textur zum Material hinzugefÃ¼gt. HierfÃ¼r
kann der Image-Textur-Node ausgewÃ¤hlt und mit der Tastenkombination
\kbd{Shift} + \kbd{D} dupliziert werden. Das Duplikat kann unterhalb des
originalen Image-Textur-Nodes platziert werden. Anschliessend sollte der
Vector-Output des Mapping-Nodes mit dem Vector-Input des duplizierten
Image-Textur-Nodes verbunden werden. Der Color-Output des
Image-Textur-Nodes kann mit dem Metallic-Input des
Principled-BSDF-Shaders verbunden werden.

\marginnote{Bilddatei auswechseln}

Der Image-Textur-Node beinhaltet als Bild immer noch die Datei
Â«\emph{Metal022\_4K\_Color.jpg}Â». Mittels des Ordner-Icons kann nach
einer anderen Textur gesucht werden, welche diesem Node hinzugefÃ¼gt
wird. HierfÃ¼r wird die Datei Â«\emph{Metal022\_4K\_Metalness.jpg}Â»
verwendet.

\marginnote{Roughness-Textur hinzufÃ¼gen}

Die Schritte zum EinfÃ¼gen der Metallic-Textur kÃ¶nnen nun wiederholt
werden, um die Roughness-Textur einzufÃ¼gen. Das heisst, der
Image-Texture-Node kann dupliziert werden, mit dem Mapping-Node und mit
dem Roughness-Input des Principled-BSDF-Shaders verbunden werden.
Anschliessend muss die Textur mit der Datei
Â«\emph{Metal022\_4K\_Roughness.jpg}Â» ausgewechselt werden.

\marginnote{Normal-Textur hinzufÃ¼gen}

FÃ¼r die Normal-Textur wird ebenfalls ein Duplikat des
Image-Texture-Nodes erstellt, dessen Input mit dem Vector-Output des
Mapping Nodes verbunden und die Datei
Â«\emph{Metal022\_4K\_NormalGL.jpg}Â» geÃ¶ffnet. ZusÃ¤tzlich wird nun ein
neuer Node benÃ¶tigt, welcher minimale visuelle Unebenheiten basierend
auf der Normal-Textur simuliert. HierfÃ¼r wird mittels der
Tastenkombination \kbd{Shift} + \kbd{A} das Â«\emph{Add}Â»-MenÃ¼ geÃ¶ffnet
und unter Â«\emph{Vector \textbar{} Bump}Â» ein Bump-Node hinzugefÃ¼gt.
Dieser wird zwischen dem Image-Textur-Node und dem
Principled-BSDF-Shader platziert. Der Normal-Output des Bump-Nodes wird
anschliessend mit dem Normal-Input des Principled-BSDF-Shaders
verbunden.

\marginnote{Bump einstellen}

Der Bump-Node nimmt die Informationen aus der Normal-Textur auf und
simuliert drauf basierend kleine Unebenheiten im Material. Die
Normal-Textur beschreibt jeweils die HÃ¶he dieser Unebenheiten. Aus
diesem Grund kann der Color-output der Normal-Textur mit dem
Height-Input des Bump-Nodes verbunden werden. Mittels des Reiters
Â«\emph{Strength}Â» kann zudem eingestellt werden, wie stark diese
Unebenheiten dargestellt werden sollen. Beispielsweise kann der Wert
0.45 verwendet werden.

\marginnote{Displacement-Textur hinzufÃ¼gen}

Zu guter Letzt wird erneut eine Kopie des Image-Texture-Nodes erstellt,
mit dem Mapping Node verbunden und die Datei
Â«\emph{Metal022\_4K\_Displacement.jpg}Â» geÃ¶ffnet. Die
Displacement-Textur bietet ebenfalls die MÃ¶glichkeit, um Unebenheiten im
Material zu simulieren. Im Vergleich zur Normal-Textur handelt es sich
hierbei um grÃ¶ssere Unebenheiten.

\marginnote{Displacement verbinden}

Zur Verwendung der Displacement-Textur wird ein weiterer Node benÃ¶tigt,
welcher im Â«\emph{Add}Â»-MenÃ¼ unter Â«\emph{Vector \textbar{}
Displacement}Â» zu finden ist. Dieser wird anschliessend neben dem
Image-Texture-Node verbunden. Der Displacement-Output des
Displacement-Nodes wird, anders als bei den anderen Texturen, nicht mit
einem Shader verbunden, sondern direkt mit dem Displacement-Output des
Material-Output-Nodes.

\marginnote{Displacement einstellen}

Der Color-Output der Displacement-Textur kann wie auch bei der
Normal-Textur und dem Bump-Node mit dem Height-Input verbunden werden.
Mittels des Reiters Â«\emph{Scale}Â» kann zudem eingestellt werden, wie
stark diese Unebenheiten erstellt werden. In der Regel reichen bereits
sehr kleine Werte aus, wie beispielsweise 0.025.

\marginnote{GrÃ¶sse der Textur einstellen}

Nachdem alle Texturen eingefÃ¼gt wurden, kann im Mapping Node die GrÃ¶sse
der Textur angepasst werden. HierfÃ¼r kann der Wert bei der Skalierung
entlang der drei Achsen vergrÃ¶ssert oder verkleinert werden.
Beispielsweise kÃ¶nnte die Textur dreimal so klein dargestellt werden,
indem die Skalierung fÃ¼r alle drei Achsen auf den Wert 3 gesetzt wird.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_27/27_5_Nodes_Metal.png}

\caption{\label{fig-1_5}Node-Struktur fÃ¼r das Metall-Material.}

\end{figure}%

\section{Holz texturieren}\label{holz-texturieren}

\marginnote{Quelle der Metall-Textur}

Die Metall-Texturen stammen von der Website
\url{https://ambientcg.com/view?id=Metal022}. Diese Website bietet
weitere Texturen an, die etwa fÃ¼r die Texturierung des Holz-Stiels
verwendet werden kÃ¶nnen. So kÃ¶nnte fÃ¼r das Holzmaterial die Textur Â«Wood
057Â» verwendet werden. HierfÃ¼r muss die entsprechende Textur
heruntergeladen werden (Bildquelle:
\url{https://ambientcg.com/view?id=Wood057}).

\marginnote{Node-System kopieren}

Nun mÃ¼sste fÃ¼r das Holz-Material dieselbe Node-Struktur erneut aufgebaut
werden. Dies kann etwas Ã¼bersprungen werden, indem alle Nodes aus dem
Metall-Material mittels der Taste \kbd{A} ausgewÃ¤hlt und mit der
Tastenkombination \kbd{Ctrl} + \kbd{C} kopiert werden. Anschliessend
kann im Properties-Editor der Slot fÃ¼r das zweite Material --das Holz --
ausgewÃ¤hlt werden. Dadurch erscheint im Shader-Editor nun die
Node-Struktur des Holz-Materials. Hier kann mit der Taste \kbd{A} alles
ausgewÃ¤hlt und die bestehenden Nodes mit der Taste \kbd{X} gelÃ¶scht
werden. Anschliessend kann mit der Tastenkombination \kbd{Ctrl} +
\kbd{V}die Node-Struktur aus dem Metall-Material eingefÃ¼gt werden.

\marginnote{Node-System kopieren}

Das neu eingefÃ¼gt Node-System beinhaltet noch die Texturen, welche im
Metall-Material verwendet wurden. Deshalb mÃ¼ssen bei allen
Image-Texture-Nodes die entsprechenden Texturen mit der Ã¤quivalenten
Texturart der Holztexturen ersetz werden. Bei dieser Textur wurde
allerdings keine Metall-Textur angeboten, weshalb der
Image-Texture-Node, welcher mit dem Metallic-Input des
Principled-BSDF-Shaders verbunden ist, entfernt werden kann. Zudem
kÃ¶nnen bei Bedarf die Einstellungen im Bump-Node fÃ¼r die Normal-Textur
und die Einstellungen im Displacement-Node fÃ¼r die Displacement-Textur
angepasst werden. Im Mapping-Node kÃ¶nnte zudem noch die Einstellung fÃ¼r
die Skalierung der Textur angepasst werden, beispielsweise auf einen
Wert von 1.5 pro Achse. Anschliessend ist der Hammer fertig texturiert.

Ãœbung 15: Texturieren

\textbf{Ãœbung 15.1}

Suchen Sie nach einer anderen Holz-Textur und fÃ¼gen Sie diese dem
Material Â«HolzÂ» des Hammers zu. Suchen Sie hierfÃ¼r nach Texturen, die
verschiedene Texturarten beinhalten.

\chapter{Displacement mit dem Displacement-Modifier
erstellen}\label{displacement-mit-dem-displacement-modifier-erstellen}

\marginnote{Was macht die Displacement-Textur genau?}

Bislang wurden Texturen innerhalb von Objekten als Bestandteil von
Materialien verwendet. So wurde etwa mittels der Color-Textur die Farbe
fÃ¼r ein Material Ã¼ber eine FlÃ¤che hinweg festgelegt oder mittels der
Roughness-Textur bestimmt, welchen Wert die Roughness an einer
bestimmten Stelle hat. Im nÃ¤chsten Schritt wird aufgezeigt, welche
Mechanismen hinter der Displacement-Textur stecken. Abbildung 1 zeigt
eine Displacement Textur. Was kÃ¶nnte sich hinter dieser Textur
verbergen?

\begin{figure}

\includegraphics{Chapters/Images/Chapter_28/28_1_Displacement_Map.png}

\caption{\label{fig-1_1}Eine Displacement-Textur. Was kÃ¶nnte sich
dahinter verbergen?}

\end{figure}%

\marginnote{Plane hinzufÃ¼gen}

Um zu erkennen, was die Displacement-Textur in diesem Beispiel
darstellt, wird sie fÃ¼r einmal nicht als Material verwendet, sondern
innerhalb eines Modifiers. HierfÃ¼r wird eine flache OberflÃ¤che benÃ¶tigt,
auf welche der Modifier angewendet wird. Deshalb wird im
3D-Viewport-Display eine Plane hinzugefÃ¼gt. Diese wird Ã¼ber das
Â«\emph{Add}Â»-MenÃ¼ (\kbd{Shift} + \kbd{A}) unter Â«\emph{Mesh \textbar{}
Plane}Â» erstellt.

\marginnote{Subdivision-Surface-Modifier hinzufÃ¼gen}

Der Plane werden zwei Modifier hinzugefÃ¼gt. ZunÃ¤chst wird ein
Subdivision-Surface-Modifier hinzugefÃ¼gt. Damit soll die FlÃ¤che in
kleinere, gleich grosse Quads unterteilt werden. Allerdings wird dadurch
auch die Form der FlÃ¤che verÃ¤ndert, da Ã¼ber die Option
Â«\emph{Catmull-Clark}Â» die Kanten geglÃ¤ttet werden. Deshalb ist es
nÃ¶tig, im Subdivision-Surface-Modifier den Reiter Â«\emph{Simple}Â»
auszuwÃ¤hlen. Dadurch sollte die FlÃ¤che ihre originale Form beibehalten.

\marginnote{Displace-Modifier hinzufÃ¼gen}

Als NÃ¤chstes wird ein neuer Modifier hinzugefÃ¼gt. Hierbei handelt es
sich um einen Modifier, der bislang noch nicht eingefÃ¼hrt wurde --
nÃ¤mlich um den Â«\emph{Displace}Â»-Modifier. Dieser ist in der dritten
Spalte der Modifier-Auswahl unter Â«\emph{Deform}Â» aufzufinden. Sobald
dieser hinzugefÃ¼gt wurde, empfiehlt es sich, die Einstellung
Â«\emph{Coordinates}Â» auf Â«\emph{UV}Â» umzuschalten.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_28/28_2_Icon_Texture_Tab.png}

\caption{\label{fig-1_2}Icon fÃ¼r den Textur-Reiter im
Properties-Editor.}

\end{figure}%

\marginnote{Textur zum Displace-Modifier hinzufÃ¼gen}

Dem Displace-Modifier kann eine Textur hinzugefÃ¼gt werden. HierfÃ¼r muss
auf die SchaltflÃ¤che Â«\emph{New}Â» geklickt werden. Anschliessend wird
von Blender ein Slot fÃ¼r eine neue Textur erstellt, welche nun im
Displace-Modifier verwendet wird. Um diese Textur bearbeiten zu kÃ¶nnen,
muss der Textur-Reiter, welcher sich zuunterst im Properties-Editor
befindet, geÃ¶ffnet werden. Alternativ kann auch innerhalb des
Displace-Modifiers auf die SchaltflÃ¤che Â«\emph{Show texture in texture
tab}Â» geklickt werden, welche sich ganz rechts innerhalb des neu
erstellten Textur-Slots befindet.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_28/28_3_Icon_Show_texture_in_Texture_Tab.png}

\caption{\label{fig-1_3}Icon zur Einstellung der Texturen im
Textur-Reiter.}

\end{figure}%

\marginnote{Einstellungen im Textur-Reiter}

Im Textur-Reiter des Properties-Editors wird nun angegeben, welche
Textur fÃ¼r den Displace-Modifier verwendet wird. Dies ist anhand des
ersten Dropdown-MenÃ¼s ersichtlich, in welchem Â«\emph{Displace}Â»
ausgewÃ¤hlt ist. Mithilfe dieses Dropdown-MenÃ¼s kÃ¶nnten Texturen auch fÃ¼r
andere Funktionen (z.B. Brushes) verwendet werden. Im zweiten
Dropdown-MenÃ¼ kÃ¶nnen Texturen, welche bereits in Blender geladen wurden,
als Textur ausgewÃ¤hlt werden. Mithilfe der Einstellung Â«\emph{Type}Â»
kÃ¶nnen verschiedene Arten von Texturen anvisiert werden. Dadurch kÃ¶nnen
prozedurale Texturen innerhalb von Blender anhand von Parametern
erstellt werden, oder es wird die Einstellung Â«\emph{Image or Movie}Â»
verwendet, um ein Bild oder einen Film als Textur zu verwenden. In
diesem Fall wird ein Bild verwendet, weshalb die Einstellung
Â«\emph{Image or Movie}Â» als Type korrekt ist.

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Blender unterscheidet intern zwischen Bilddateien und Texturen. Dadurch sind teilweise Bilddateien in Blender geladen, allerdings nicht als Textur verwendbar. HierfÃ¼r muss im Textur-Reiter des Properties-Editors das in Blender geladene Bild noch einer Textur hinzufÃ¼gt werden. Um nachzuvollziehen, ob man in Blender gerade Bilddateien oder Texturen auswÃ¤hlt, kann man sich jeweils am Icon des Dropdown-MenÃ¼s orientieren.
\end{tipp}

\marginnote{Bild zur Textur hinzufÃ¼gen}

Sobald die Einstellung Â«\emph{Image or Movie}Â» ausgewÃ¤hlt ist, wird der
Reiter Â«\emph{Image}Â» sichtbar. Darin kann auf dieselben Arten wie
innerhalb eines Image-Texture-Nodes ein Bild geladen werden. In diesem
Fall wird Ã¼ber die SchaltflÃ¤che Â«\emph{Open}Â» die Bilddatei
Â«\emph{displacement\_map.png}Â» geÃ¶ffnet. Anschliessend sollte die
entsprechende Bilddatei der Textur hinzugefÃ¼gt worden sein und die
Textur sollte Ã¼ber den Displacement-Modifier eine VerÃ¤nderung im Mesh
bewirken.

\marginnote{Effekte der Displacement-Textur}

Was ist dabei passiert? Jeder Vertex des Meshes wurde entlang der
Normalen verschoben. Der Grad dieser Verschiebung ergibt sich anhand der
soeben eingefÃ¼gten Displacement-Textur. Ãœber die UVs ermittelt Blender
fÃ¼r jeden Vertex, wo sich dieser auf der Displacement-Textur befindet,
und extrahiert aus den Schwarz-weiss-Werten der Textur an dieser Stelle,
wie stark die Verschiebung entlang der Normalen vollzogen werden soll.
Hellere Werte in der Textur stehen fÃ¼r hÃ¶here Bereiche (grÃ¶sseres
Displacement), wÃ¤hrend dunklere Werte in der Textur fÃ¼r tiefere Bereiche
stehen (geringeres Displacement). Dadurch kÃ¶nnen anhand von
Displacement-Texturen Abweichungen im Objekt vollzogen werden.

\marginnote{Displacement benÃ¶tigt viele Vertices}

Bislang ist noch nicht zu erkennen, was die Displacement-Textur
eigentlich abbilden soll. Dies liegt daran, dass das Mesh zu wenige
Vertices beinhaltet, um mÃ¶glichst die gesamte Form der Textur
abzudecken. Zudem befinden sich die Vertices auch nicht zwingend an den
hÃ¶chsten oder tiefsten Punkten der Textur, wodurch das Maximum und das
Minimum der Abweichungen innerhalb der Displacement-Textur
mÃ¶glicherweise nicht abgebildet werden. HierfÃ¼r werden demnach weitere
Vertices benÃ¶tigt.

\marginnote{Weitere Vertices hinzufÃ¼gen}

Durch den Subdivision-Surface-Modifier kÃ¶nnen weitere Vertices
hinzugefÃ¼gt werden, indem die Anzahl Subdivisions im Reiter
Â«\emph{Levels Viewport}Â» erhÃ¶ht wird. Diese Option reicht maximal fÃ¼r
sechs Subdivisions. Dadurch wird bereits ersichtlich, was sich hinter
der Displacement-Textur befindet. Sollten noch mehr Subdivisions
benÃ¶tigt oder gewÃ¼nscht werden, kann der Subdivision-Surface-Modifier
dupliziert werden.

\marginnote{Vorsicht beim Duplizieren des Subdivision-Surface-Modifiers}

Beim Duplizieren des Subdivision-Surface-Modifiers ist dringend zu
empfehlen, dass die Anzahl Subdivisions vor dem Duplizieren
zurÃ¼ckgesetzt wird. Wird ein Subdivision-Surface-Modifier mit sechs
Subdivisions dupliziert, fÃ¼hrt dies dazu, dass durch das resultierende
Duplikat insgesamt zwÃ¶lf Subdivisions durchgefÃ¼hrt werden. Dies kann je
nach Computer einen Grossteil der verfÃ¼gbaren Leistung benÃ¶tigen. Durch
das ZurÃ¼cksetzen der Anzahl Subdivisions auf beispielsweise zwei
Subdivisions werden mit dem Duplikat zusammen lediglich vier Subdivision
durchgefÃ¼hrt.

\marginnote{Reihenfolge der Modifier beachten}

Weiterhin ist wichtig, dass die Subdivision-Surface-Modifier in der
Platzierung der Modifier vor dem Displace-Modifier platziert werden. Nur
Vertices, welche vor dem Displace-Modifier erstellt werden, kÃ¶nnen von
diesem Modifier berÃ¼cksichtigt werden. Modifier, welche nach dem
Displace-Modifier platziert werden, kann der Displace-Modifier nicht
berÃ¼cksichtigen.

\marginnote{Tangram Heightmapper}

Die Bilddatei Â«\emph{displacement\_map.png}Â» wurde mithilfe des Â«Tangram
HeightmappersÂ» (\url{http://www.tangrams.github.io/heightmapper})
erstellt. Dadurch kÃ¶nnen Areale der Erde ausgewÃ¤hlt und eine HÃ¶hentextur
des entsprechenden Gebiets erstellt werden. Diese HÃ¶hentexturen kÃ¶nnen
anschliessend als Displacement-/Height-Textur verwendet werden.

\begin{tipp}{WeiterfÃ¼hrende Informationen}
In diesem Beispiel wurde das Material des Objektes nicht bearbeitet. Die Displacement-Textur wurde lediglich verwendet, um damit die OberflÃ¤che des Objektes zu verformen.
\end{tipp}

NA ::::::

\chapter{Erstellen von Landschaften}\label{erstellen-von-landschaften}

\marginnote{Landschaften erstellen}

Um geografische Landschaften zu erstellen, mÃ¼ssen nicht zwingend
Displacement-Texturen verwendet werden. Es ist auch mÃ¶glich, von Hand
Landschaften zu erstellen, was etwa durch die proportionale Bearbeitung
etwas vereinfacht wird. Allerdings handelt es sich dabei trotzdem um
einen aufwendigen Prozess. Blender beinhaltet jedoch ein integriertes
Add-on, welches die schnelle Erstellung von Landschaften ermÃ¶glicht.
Dieses Add-on heisst Â«\emph{A.N.T.Landscape}Â» und muss zunÃ¤chst in den
Einstellungen von Blender aktiviert werden (unter Â«\emph{Edit \textbar{}
Preferences}Â» und anschliessend unter dem Reiter Â«\emph{Add-ons}Â»).

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Die AbkÃ¼rzung A.N.T. des Add-ons Â«*A.N.T.Landscape*Â» steht fÃ¼r Â«*another noise tool*Â». Dies bezieht sich auf die Erstellung der Landschaften. Es wird jeweils eine Plane gebildet und anhand von zufÃ¤lligem Noise die Landschaft daraus erstellt.
\end{tipp}

\marginnote{HinzufÃ¼gen von neuen Landschaften}

Durch das Aktivieren dieses Add-ons wird im Â«\emph{Add}Â»-MenÃ¼ unter dem
MenÃ¼ punkt Â«\emph{Mesh}Â» die Option Â«\emph{Landscape}Â» verfÃ¼gbar. Wird
eine solche Landschaft hinzugefÃ¼gt, erstellt Blender eine FlÃ¤che in der
Welt und bearbeitet diese zu einer Landschaft um. Die Einstellungen
dieser Landschaft sind im Kontext-MenÃ¼ zum HinzufÃ¼gen von Objekten in
der unteren linken Ecke aufzufinden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_29/29_1_Activating_Landscape.png}

\caption{\label{fig-1_1}Aktivieren des Add-ons
Â«\emph{A.N.T.Landscape}Â».}

\end{figure}%

\marginnote{Problem der Bearbeitung im Kontext-MenÃ¼}

Die Einstellung der Landschaft im Kontext-MenÃ¼ birgt das Problem, dass
das Kontext-MenÃ¼ jeweils wieder verschwindet, sobald ein Klick in den
dreidimensionalen Raum des 3D-Viewport-Editors erfolgt. Auch das
DurchfÃ¼hren anderer Operationen ausserhalb dieses Kontext-MenÃ¼s fÃ¼hrt
zum Verschwinden des MenÃ¼s. Die Bearbeitung der Landschaften erfolgt
allerdings innerhalb des Kontext-MenÃ¼s. Durch einen Klick ausserhalb des
Kontext-MenÃ¼s werden alle Einstellungen in diesem MenÃ¼ unwiderruflich
auf das Objekt angewendet. Sollte dies aus Versehen geschehen, obwohl
man noch nicht mit der Einstellung der Landschaft fertig ist, muss man
das Landschaftsobjekt lÃ¶schen und erneut eine Landschaft hinzufÃ¼gen.
GlÃ¼cklicherweise erinnert sich Blender an die zuletzt verwendeten
Einstellungen, sodass die Einstellungen an derselben Stelle
weitergefÃ¼hrt werden kÃ¶nnen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_29/29_2_Landscape_Example.png}

\caption{\label{fig-1_2}Eine Landschaft, erstellt mit
Â«\emph{A.N.T.Landscape}Â».}

\end{figure}%

\section{Die Optionen im A.N.T.
Landscape-Add-on}\label{die-optionen-im-a.n.t.-landscape-add-on}

\subsection{Presets}\label{presets}

\marginnote{Voreingestellte Landschaften}

Zuoberst im Kontext-MenÃ¼ befindet sich ein Dropdown-MenÃ¼, welches eine
Reihe verschiedener Voreinstellungen fÃ¼r Landschaften liefert. Soll die
Landschaft etwa einen Canyon abbilden, so kann die Voreinstellung
Â«\emph{Canyon}Â» ausgewÃ¤hlt werden. Soll ein See abgebildet werden, so
kann die Voreinstellung Â«\emph{Lake}Â» gewÃ¤hlt werden.

\marginnote{Voreinstellungen verwerfen vorherige Ã„nderungen}

Werden nach der Auswahl einer Voreinstellung weitere Ã„nderungen
vorgenommen, werden diese nicht in den Voreinstellungen abgespeichert.
Durch das AuswÃ¤hlen einer anderen Voreinstellung werden alle vorher
gemachten Anpassungen zurÃ¼ckgesetzt und kÃ¶nnen nicht wieder rÃ¼ckgÃ¤ngig
gemacht werden.

\marginnote{HinzufÃ¼gen und LÃ¶schen von eigenen Voreinstellungen}

Mittels der SchaltflÃ¤che Â«+Â» kÃ¶nnen jedoch eigene Voreinstellungen
abgespeichert werden. Dadurch erscheint ein Dialogfeld, bei dem ein Name
fÃ¼r die Voreinstellung eingegeben werden kann. Anschliessend kann diese
Voreinstellung im Dropdown-MenÃ¼ ausgewÃ¤hlt werden. Durch das Klicken der
SchaltflÃ¤che Â«-Â» wird die aktuelle Voreinstellung gelÃ¶scht.

\subsection{Refresh}\label{refresh}

\marginnote{Automatic refresh}

Unterhalb des Dropdown-MenÃ¼s befinden sich zwei SchaltflÃ¤chen. Die erste
SchaltflÃ¤che, welche ein Auto abbildet, steht fÃ¼r Â«\emph{automatic
refresh}Â». Wenn diese SchaltflÃ¤che aktiviert ist, werden alle Ã„nderungen
in den Landscape-Einstellungen automatisch im Mesh dargestellt.

\marginnote{Refresh}

Die zweite SchalflÃ¤che Â«\emph{refresh}Â» wird verwendet, wenn Ã„nderungen
in den Landscape-Einstellungen Ã¼bernommen und im Mesh dargestellt werden
sollen. Wenn allerdings die Option Â«\emph{automatic refresh}Â» aktiviert
ist, wird diese SchaltflÃ¤che obsolet, weshalb sie automatisch mit dieser
Option mit ausgewÃ¤hlt wird.

\subsection{Main Settings}\label{main-settings}

\marginnote{Grundlegende Einstellungen}

Innerhalb der Main-Settings sind grundlegende Eigenschaften des Meshes
zusammengefasst. ZunÃ¤chst kÃ¶nnen mittels drei SchaltflÃ¤chen folgende
Optionen durchgefÃ¼hrt werden:

\begin{itemize}
\tightlist
\item
  Â«\textbf{\emph{Cursor}}Â»: Ist diese Option aktiviert, wird die
  Landschaft an der Position des 3D-Cursors hinzu gefÃ¼gt. Wenn diese
  Option deaktiviert ist, wird die Landschaft im Zentrum der Welt
  hinzugefÃ¼gt.
\item
  Â«\textbf{\emph{Smooth}}Â»: Durch diese Option kann direkt bei der
  Landschaftserstellung Â«Shade SmoothÂ» aktiviert werden, um das Objekt
  mÃ¶glichst geglÃ¤ttet darzustellen. Ansonsten wird das Objekt anhand von
  Â«Shade FlatÂ» erstellt.
\item
  Â«\textbf{\emph{Triangulate}}Â»: Wenn dies Option aktiviert ist, werden
  die Faces als Tris statt als Quads im Mesh gebildet.
\end{itemize}

\marginnote{Planeten statt Landschaften bilden}

Unterhalb dieser drei Optionen befindet sich zudem die SchaltflÃ¤che
Â«\emph{Sphere}Â». Wird diese aktiviert, wird statt einer flachen
Landschaft eine Kugel erstellt, welche anhand der Einstellungen
bearbeitet wird. Dies ermÃ¶glicht es, dass dieses Add-on auch zur
Erstellung von Planeten verwendet werden kann. Wenn die Option
Â«\emph{Sphere}Â» aktiviert ist, kann zudem die Option Â«\emph{Remove
Doubles}Â» aktiviert werden, um mÃ¶gliche doppelte Vertices an derselben
Position direkt miteinander zu verbinden.

\marginnote{Weitere Einstellungen}

Ãœber die Zeile Â«\emph{Name}Â» kann ein Name fÃ¼r das erstellte Mesh
definiert werden und mittels der Zeile Â«\emph{Material}Â» kann ein
bereits erstelltes Material ausgewÃ¤hlt werden, welches dem Objekt
hinzugefÃ¼gt werden soll. Die beiden Zeilen Â«\emph{Subdivisions}Â» geben
jeweils an, wie viele Subdivisions entlang der jeweiligen Achse im Mesh
erstellt werden. Je hÃ¶her die Anzahl dieser Subdivisions, desto
detailliertere Landschaften kÃ¶nnen erstellt werden, aber desto mehr
Leistung wird vom Rechner benÃ¶tigt. Mittels der Zeile Â«\emph{Mesh Size}Â»
kann zudem eingestellt werden, wie gross das zu erstellende Mesh sein
soll.

\subsection{Noise Settings}\label{noise-settings}

\marginnote{Noises generieren die Grundlage des Displacements}

Die erstellten Landschaften werden im Hintergrund basierend auf einer
zufÃ¤llig generierten Displacement-Textur erstellt. Mittels verschiedener
Einstellungsparameter berechnet Blender dabei eine Textur aus Noise,
welche anschliessend die Displacement-Textur darstellt. Diese
Einstellungen werden im Bereich Â«\emph{Noise Settings}Â» vollzogen.
HierfÃ¼r kÃ¶nnen unter dem Dropdown-MenÃ¼ Â«\emph{Noise Type}Â» verschiedene
Arten von zufÃ¤llig generierten Noises ausgewÃ¤hlt werden. Im
Dropdown-MenÃ¼ Â«\emph{Noise Basis}Â» kann zwischen verschiedenen
Algorithmen zur Berechnung des Noises ausgewÃ¤hlt werden. Mittels der
Einstellung Â«\emph{Random Seed}Â» kann zudem eine Option der
Zufallsauswahl im Computer ausgewÃ¤hlt werden. Dadurch kÃ¶nnen die
zufÃ¤llig erstellten Noises reproduziert werden.

\marginnote{Noise ausrichten und skalieren}

Ãœber die Optionen Â«\emph{Offset}Â» und Â«\emph{Size}Â» kann der
resultierende Noise vergrÃ¶ssert oder verkleinert werden. Im Grunde
genommen wird Ã¼ber die Einstellung Â«\emph{Offset}Â» entlang einer
unendlich grossen, automatisch generierten Displacement-Textur gescrollt
und mittels der Einstellung Â«\emph{Size}Â» diese Textur vergrÃ¶ssert oder
verkleinert. Mittels der Option Â«\emph{Noise Size}Â» lÃ¤sst sich diese
Option fÃ¼r den Noise ebenfalls vergrÃ¶ssern oder verkleinern.

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Wenn ein Computer auf Befehl Dinge Â«zufÃ¤lligÂ» verÃ¤ndern oder generieren soll, erfolgt dies gar nicht zufÃ¤llig. Bei solchen Zufallsoperationen gibt es jeweils eine Reihe von Â«vorgefertigten ZufÃ¤llenÂ», welche jeweils eintreten. Dies ermÃ¶glicht es, dass scheinbar zufÃ¤llige Einstellungen ausgewÃ¤hlt werden kÃ¶nnen. Die Seeds beschreiben jeweils einen Startpunkt, von dem aus der Computer den Â«ZufallÂ» generiert. Wenn mehrere Computer fÃ¼r dieselbe zufallsbasierte Anwendung denselben Seed verwenden, resultiert dasselbe Ergebnis, da alle auf derselben ausgewÃ¤hlten Zufallsreihenfolge basieren.
\end{tipp}

\marginnote{Weitere Einstellungen zu Noise sind verfÃ¼gbar}

Unterhalb dieser Optionen gibt es einige weitere Parameter, mit denen
der Noise weiterbearbeitet werden kann. Zudem kann mittels des
Dropdown-MenÃ¼s Â«\emph{Effect Type}Â» ein zusÃ¤tzlicher Effekt mit dem
Noise kombiniert werden. FÃ¼r diesen Effekttyp stehen nochmals eine Reihe
weiterer Einstellungsoptionen zur VerfÃ¼gung.

\subsection{Displace Settings}\label{displace-settings}

\marginnote{Displacement wendet Noise an}

WÃ¤hrend die Einstellungen in den Noise-Settings fÃ¼r die VerÃ¤nderung des
Noises innerhalb einer generierten Displacement-Textur verwendet werden,
kann mittels der Displace-Settings deren Anwendung auf das Mesh
verfeinert werden.

\marginnote{HÃ¶he des Displacements anpassen}

Mittels der Zeile Â«\emph{Height}Â» kann eingestellt werden, zu welcher
HÃ¶he das Displacement jeweils fÃ¼hren soll. Mit der Zeile Â«\emph{Offset}Â»
kann zudem eine gewisse Abweichung von dieser HÃ¶he eingestellt werden.
Mittels der Zeilen Â«\emph{Maximum}Â» und Â«\emph{Minimum}Â» kann zudem
definiert werden, in welchen Bereichen der HÃ¶he das Displacement
lediglich berÃ¼cksichtigt wird. Ist beispielsweise als Maximum der Wert
0.5 und als Minimum der Wert 0.1 eingestellt, werden alle Vertices,
welche durch das Displacement unter der lokalen HÃ¶he von 0.1 liegen, auf
die HÃ¶he 0.1 hochgesetzt. Analog dazu werden alle Vertices, welche in
der HÃ¶he Ã¼ber dem Wert 0.5 liegen, auf den Wert 0.5 heruntergesetzt.

\marginnote{Falloff}

Am Rand der Landschaft wird in der Regel der Effekt des Displacements
entfernt. Dies beschreibt der Falloff. Ãœber das Dropdown-MenÃ¼
Â«\emph{Falloff}Â» kann definiert werden, auf welche Achsen des Meshes
dieser Effekt angewendet werden soll. Zudem kann mit der Zeile
Â«\emph{Edge Level}Â» definiert werden, auf welcher HÃ¶he sich der Rand des
Objektes befinden soll. Mittels der beiden Zeilen Â«\emph{Falloff X}Â» und
Â«\emph{Falloff Y}Â» kann angegeben werden, wie gross der Bereich des
Falloffs sein soll.

\subsection{Water Plane}\label{water-plane}

\marginnote{Water Plane}

Mittels der Option Â«\emph{Water Plane}Â» wird eine weitere FlÃ¤che
hinzugefÃ¼gt, die als WasserflÃ¤che dienen kann. Es handelt sich dabei um
eine Plane, welche als separates Objekt hinzugefÃ¼gt wird. Dieser FlÃ¤che
kann ebenfalls bereits ein Material zugewiesen werden. Mittels der Zeile
Â«\emph{Level}Â» wird bestimmt, wie hoch der Wasserspiegel sein soll.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_29/29_3_Landscape_Comparison.png}

\caption{\label{fig-1_3}Links ein mit A.N.T.Landscape erstellter Berg.
Daneben ein Berg, dessen Displacement als Minimum 0.1 und als Maximum
0.5 hat. Durch die Anhebung des Wertes Â«\emph{Minimum}Â» auf 0.1 werden
alle Vertices im Objekt auf diese HÃ¶he hinaufgesetzt. Danaben zwei
Versionen desselben Berges mit unterschiedlichen Falloff-Werten.}

\end{figure}%

\chapter{Tutorial: Erstellen einer
DÃ¼ne}\label{tutorial-erstellen-einer-duxfcne}

\marginnote{Ziel dieses Tutorials}

Ziel dieses Tutorials ist die Erstellung einer SanddÃ¼ne. HierfÃ¼r wird
zunÃ¤chst mittels des A.N.T.Land-scape-Add-ons eine Landschaft erstellt
und diese anschliessend im Shader-Editor mit einem Material versehen.
Diesmal wird allerdings auf die Verwendung von Bilddateien zur
Texturierung verzichtet.

\section{Landschaft erstellen}\label{landschaft-erstellen}

\marginnote{Mesh hinzufÃ¼gen}

Als Erstes wird eine neue Landschaft hinzugefÃ¼gt. HierfÃ¼r wird mit der
Tastenkombination \kbd{Shift} + \kbd{A} das Â«\emph{Add}Â»-MenÃ¼ geÃ¶ffnet
und Â«\emph{Mesh \textbar{} Landscape}Â» ausgewÃ¤hlt. Dadurch erscheint ein
neues Landschaftsobjekt in der Szene.

\marginnote{DÃ¼ne erstellen}

Bei dem Objekt soll es sich um eine DÃ¼ne handeln. Praktischerweise gibt
es hierfÃ¼r bereits eine Voreinstellung. Im Dropdown-MenÃ¼ Â«\emph{Operator
Presets}Â» kann die Option Â«\emph{Dunes}Â» ausgewÃ¤hlt werden. Dadurch wird
das Mesh zu einer DÃ¼ne angepasst. FÃ¼r dieses Tutorial wird zudem der
Â«\emph{Random Seed}Â» 64 ausgewÃ¤hlt und der Wert fÃ¼r den Â«\emph{Falloff
X}Â» und den Â«\emph{Falloff Y}Â» auf 5 gesetzt. Die restlichen
Einstellungen kÃ¶nnen in den Standardeinstellungen belassen werden. Damit
ist das Mesh der Landschaft bereits erstellt.

\marginnote{Material hinzufÃ¼gen}

Als NÃ¤chstes geht es darum, dem Mesh ein Material zuzuweisen. HierfÃ¼r
wird im Properties-Editor unter dem Material-Reiter auf die SchaltflÃ¤che
Â«\emph{New}Â» geklickt. Dies fÃ¼gt ein neues Material hinzu und erstellt
ebenso den benÃ¶tigten Material-Slot fÃ¼r das Material. Damit die
Ã„nderungen am Material sichtbar sind, wird im 3D-Viewport-Editor auf den
Material-Preview-Shading-Modus gewechselt.

\marginnote{Shader-Editor Ã¶ffnen}

Der nÃ¤chste Schritt benÃ¶tigt den Shader-Editor. HierfÃ¼r muss aus den
Ecken des 3D-Viewport-Editors ein neuer Editor herausgezogen werden und
der neue Editor zum Shader-Editor umgewandelt werden. Nun kÃ¶nnte im
Internet nach Sand-Texturen gesucht werden und diese anhand der bereits
bekannten Methoden dem Material hinzugefÃ¼gt werden. Dieses Tutorial
verzichtet allerdings auf die Verwendung von Bildmaterialen zur
Erstellung von Texturen. Stattdessen werden sÃ¤mtliche Texturen in
Blender selbst generiert.

\section{Prozedurales Texturieren}\label{prozedurales-texturieren}

\marginnote{Noise als Grundlage}

Eine DÃ¼ne besteht aus einer immensen Anzahl kleiner Sandpartikel. Diese
wÃ¤ren in einer Textur als Ansammlung minimaler Punkte sichtbar --
Ã¤hnlich einem rauschenden Bild. Innerhalb von Blender gibt es zwei
MÃ¶glichkeiten, um einen solchen Effekt zu erzielen.

\marginnote{Noise-Textur}

Die erste MÃ¶glichkeit besteht darin, dass eine Noise-Textur hinzugefÃ¼gt
wird. Diese erstellt prozedural eine verrauschte Textur, die skaliert
und verzogen werden kann. Sie hat allerdings den Nachteil, dass sie bei
besonders kleinem Noise sehr viel Rechenleistung benÃ¶tigt. Deshalb wird
in diesem Tutorial auf diese Option verzichtet.

\marginnote{White-Noise-Textur}

Die zweite MÃ¶glichkeit besteht aus der Verwendung einer
White-Noise-Textur. Diese kann nicht verzogen oder skaliert werden,
sondern bildet automatisch mÃ¶glichst kleine Rauschpunkte. Diese Art der
Textur kann besser fÃ¼r besonders kleine Rausch-Elemente verwendet
werden, weshalb in diesem Tutorial diese Textur verwendet wird.

\marginnote{White-Noise-Textur hinzufÃ¼gen}

Mittels der Tastenkombination \kbd{Shift} + \kbd{A} wird innerhalb des
Shader-Editors das Â«\emph{Add}Â»-MenÃ¼ geÃ¶ffnet und unter Â«\emph{Texture
\textbar{} White Noise}Â» eine White-Noise-Textur hinzugefÃ¼gt. Diese wird
anschliessend links vom Principled-BSDF-Shader platziert. Wird der neu
hinzugefÃ¼gte White-Noise-Texture-Node bei gedrÃ¼ckter \kbd{Ctrl}- +
\kbd{Shift}-Taste angeklickt, wird Ã¼ber den Viewer-Node eine Vorschau
des White-Noise-Texture-Nodes ermÃ¶glicht. Sollte dieser Node im
Shader-Editor nicht erscheinen, sollte Ã¼berprÃ¼ft werden, ob das
Node-Wrangler-Add-on aktiviert wurde.

\marginnote{Texture-Coordinate-und Mapping-Node hinzufÃ¼gen}

Im 3D-Viewport-Editor wird allerdings keine VerÃ¤nderung durch die
Vorschau des White-Noise-Texture-Nodes sichtbar. Dies liegt daran, dass
der White-Noise-Texture-Node noch einen Bezugspunkt zum Mesh benÃ¶tigt.
Deshalb wird der White-Noise-Texture-Node ausgewÃ¤hlt und die
Tastenkombination \kbd{Ctrl} + \kbd{T} gedrÃ¼ckt. Dadurch werden ein
Texture-Coordinate-Node und ein Mapping-Node dem
White-Noise-Texture-Node vorangestellt. Somit kann der
White-Noise-Texture-Node nun einen Bezugspunkt zum Mesh generieren und
eine Vorschau auf das Mesh sollte mÃ¶glich sein.

\marginnote{Farbvariation fehlt in White-Noise-Textur}

WÃ¼rde nun der Color-Output des White-Noise-Texture-Nodes mit dem
Base-Color-Input des Principled-BSFD-Shaders verbunden werden, wÃ¼rde
lediglich schwarz-weisser Noise resultieren. Sand besteht jedoch aus
einer Farbe und nicht nur aus Schwarz-Weiss-Abstufungen. Deshalb muss
diese Schwarz-Weiss-Abstufung in eine farbige Abstufung umgewandelt
werden. Dies kann mittels eines Color-Ramp-Nodes erzielt werden.

\section{Arbeiten mit der Color-Ramp}\label{arbeiten-mit-der-color-ramp}

\marginnote{Color-Ramp hinzufÃ¼gen und verbinden}

Mittels der Tastenkombination \kbd{Shift} + \kbd{A} kann das
Â«\emph{Add}Â»-MenÃ¼ aufgerufen und unter Â«\emph{Converter \textbar{}
ColorRamp}Â» eine Color-Ramp hinzugefÃ¼gt werden. Diese wird anschliessend
zwischen dem White-Noise-Texture-Node und dem Principled-BSDF-Shader
platziert. ZusÃ¤tzlich wird der Color-Output des
White-Noise-Texture-Nodes mit dem Faktor-Input des Color-Ramp-Nodes
verbunden. Der Color-Output des Color-Ramp-Nodes wird anschliessend mit
dem Base-Color-Input des Principled-BSDF-Shaders verbunden.

\marginnote{Was macht die Color-Ramp genau?}

Die Color-Ramp nimmt die jeweiligen Inputs, seien es nun Faktoren oder
Farben, auf und erstreckt sie entlang einer Farbachse. Diese wird in der
Mitte des Color-Ramp-Nodes ersichtlich. Anhand dieser Achse werden
anschliessend neue Farbmarker definiert, welche an den jeweiligen
Punkten der Input-Achse stehen. Per Default befindet sich ganz links am
Ende dieser Achse ein Farbmarker mit der Farbe Schwarz (RGB 0-0-0) und
rechts ein Farbmarker mit der Farbe Weiss (RGB 1-1-1). Alle Faktorwerte
oder Farbwerte, welche die Color-Ramp als Input bekommt, werden somit
entlang dieser Achse ausgestreckt und graduell zwischen den beiden
Farbwerten abgestuft.

\marginnote{Was bewirkt eine Verschiebung der Farbmarker in der Color-Ramp?}

Wenn nun einer der beiden Farbmarker verschoben wird, beispielsweise der
linke Farbmarker, so vergrÃ¶ssert sich sein Anteil am Spektrum der
Color-Ramp. Die gesamte FlÃ¤che, welche sich links von diesem Farbmarker
befindet, wird zu einer schwarzen Farbe umgewandelt. Gleichzeitig wird
der Bereich, in dem eine graduelle Abstufung von Schwarz auf Weiss
geschieht, zunehmend kleiner. Dieser Effekt lÃ¤sst sich am besten
betrachten, indem die Color-Ramp ausgewÃ¤hlt und mittels der
Tastenkombination \kbd{Ctrl} + \kbd{Shift} Ã¼ber den Viewer-Node
betrachtet wird. Je weiter der schwarze Farbmarker nach rechts gezogen
wird, desto mehr Anteile an der White-Noise-Textur, welche den Input der
Color-Ramp darstellt, werden schwarz. Analog dazu werden mehr Anteile
der White-Noise-Textur weiss, wenn der weisse Farbmarker nach links
verschoben wird.

\marginnote{Rangfolge der Farbmarker}

Jeder Farbmarker innerhalb der Color-Ramp hat dabei eine Rangliste von
links nach rechts inne. Der schwarze Farbmarker auf der linken Seite ist
der erste Marker und wird deshalb mit der Nummer Â«0Â» beschrieben. Dies
liegt daran, dass Blender auf Python beruht und Python seine
Nummerierungen jeweils bei 0 beginnt. Der zweite Farbmarker hat deshalb
die Nummer 1 und ein dritter Farbmarker hÃ¤tte die Nummer 2, und so
weiter. Diese Nummerierung ist jeweils links neben dem Eingabefeld
Â«\emph{Pos}Â» ersichtlich. Dadurch kÃ¶nnen die jeweiligen Marker
alternativ zu einer Auswahl mittels eines Mausklicks angesteuert werden.
Mittels der SchaltflÃ¤che Â«+Â» kann jeweils ein zusÃ¤tzlicher Farbmarker
hinzugefÃ¼gt und mittels der SchaltflÃ¤che Â«-Â» der ausgewÃ¤hlte Farbmarker
entfernt werden.

\marginnote{Position des Markers entlang der Color-Ramp}

Die Position des aktuell ausgewÃ¤hlten Markers wird zudem Anhand des
Eingabefeldes Â«\emph{Pos}Â» dargestellt. Dieses Feld kann Werte von 0 bis
1 annehmen. Der Wert 0 befindet sich dabei am linken Ende und der Wert 1
am rechten Ende der Color-Ramp.

\marginnote{Farben von Farbmarkern einstellen}

Unterhalb der Rangfolge und der Position des ausgewÃ¤hlten Farbmarkers
befindet sich eine Farbbox, welche die Farbe des ausgewÃ¤hlten
Farbmarkers darstellt. So kann fÃ¼r jeden Farbmarker eine eigene Farbe
ausgewÃ¤hlt werden.

\marginnote{Color-Ramp fÃ¼r DÃ¼ne anpassen}

Um nun die White-Noise-Textur etwas mehr nach Sand aussehen zu lassen,
sollten zunÃ¤chst die Farben der beiden Farbmarker ausgewechselt werden.
Der schwarze Farbmarker wird deshalb auf den RGB-Wert von 0.2-0.1-0
gesetzt und der weisse Farbmarker auf den RGB-Wert 0.5-0.45-0.35
gestellt. Dadurch werden die schwarz-weissen Abstufungen der
White-Noise-Textur nun in Abstufungen dieser beiden Farbmarker
umgewandelt. Der Color-Output des Color-Ramp-Nodes kann deshalb nun mit
dem Base-Color-Input des Principled-BSDF-Shaders verbunden werden. Zudem
sollte bei gedrÃ¼ckter Tastenkombination \kbd{Ctrl} + \kbd{Shift} auf den
Principled-BSDF-Shader geklickt werden, um den Viewer-Node wieder zu
deaktivieren.

\marginnote{Roughness variieren lassen}

Als NÃ¤chstes benÃ¶tigt der Principled-BSDF-Shader Informationen fÃ¼r den
Roughness-Input. Diese Information sollte idealerweise auch gerade auf
dem White-Noise-Texture-Node beruhen. Mittels dessen Value-Outputs
kÃ¶nnte etwa diese Information Ã¼bertragen werden. Dies wÃ¼rde allerdings
dazu fÃ¼hren, dass das Material ziemlich glatt erscheint und Licht
gebÃ¼ndelt reflektiert, was bei einer DÃ¼ne nicht erwartet wird. Deshalb
mÃ¼sste der Anteil der geringen Roughness-Werte reduziert werden. Um dies
zu erreichen, kann erneut eine Color-Ramp hinzugefÃ¼gt werden, welche
Ebenfalls den Color-Output des White-Noise-Texture-Nodes erhÃ¤lt, deren
Color-Output allerdings mit dem Roughness-Input des
Principled-BSDF-Shaders verbunden wird.

\marginnote{Roughness mit Farbmarkern variieren}

Der linke, schwarze Farbmarker deckt nun die tiefstmÃ¶glichen Bereiche
der Roughness ab, nÃ¤mlich den Wert 0. Dieser Wert ist allerdings nicht
im Sand zu erwarten. Deshalb kann seine Farbbox geÃ¶ffnet und ihm eine
hellere Farbe zugeordnet werden (z.B. RGB = 0.6-0.6-0.6). Dadurch gibt
es immer noch eine graduelle Variation der Roughness, allerding in einem
geringeren Ausmass.

\marginnote{Bright/Contrast-Node fÃ¼r alternative Vorgehensweise}

Es gibt noch eine weitere Option, welche verwendet werden kÃ¶nnte, um die
Roughness zu erhÃ¶hen. So kÃ¶nnte statt eines Color-Ramp-Nodes ein
Bright/Contrast-Node verwendet werden. Dieser ist im Â«\emph{Add}Â»-MenÃ¼
unter Â«\emph{Color \textbar{} Bright Contrast}Â» zu finden. Hierbei wÃ¼rde
anschliessend der Color-Output des White-Noise-Texture-Nodes mit dem
Color-Input des Bright/Contrast-Nodes verbunden werden und dessen
Color-Output mit dem Roughness-Input des Principled-BSDF-Shaders.

\marginnote{White-Noise aufhellen mittels Bright/Contrast-Node}

Durch eine ErhÃ¶hung der Zeile Â«\emph{Bright}Â» wird anschliessend die
Noise-Textur farblich erhellt. Dies fÃ¼hrt dazu, dass die dunkleren
Anteile, welche zu einer tieferen Roughness fÃ¼hren, aufgehellt werden
und dadurch eine hÃ¶here Roughness aufweisen. Hier kÃ¶nnte beispielweise
ein Wert von 0.3 verwendet werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_30/30_1_Nodes_System.png}

\caption{\label{fig-1_1}Nodes-System fÃ¼r prozedurale Sand-Texturen.}

\end{figure}%

\marginnote{White-Noise-Textur als Normal-Textur verwenden}

ZusÃ¤tzlich kann der White-Noise-Texture-Node auch verwendet werden, um
die Normal-Textur zu ersetzen. HierfÃ¼r wird ein Bump-Node im
Â«\emph{Add}Â»-MenÃ¼ unter Â«\emph{Vector \textbar{} Bump}Â» hinzugefÃ¼gt und
links vom Principled-BSDF-Shader platziert. Der Normal-Output des
Bump-Nodes kann anschliessend mit dem Normal-Input des
Principled-BSDF-Shaders verbunden werden. Dadurch generiert der
Bump-Node nun minimale Abweichungen, welche das Material jeweils
simuliert. Um die HÃ¶he dieser Abweichungen einstellen zu kÃ¶nnen, wird
der Color-Output des White-Noise-Texture-Nodes mit dem Height-Input des
Bump-Nodes verbunden.

\section{Wave-Texture}\label{wave-texture}

\marginnote{Abstufungen in den DÃ¼nen hinzufÃ¼gen}

Teilweise beinhalten DÃ¼nen auch leichte Abstufungen, welche der Wind
durch seine Verwehungen mit sich bringt. Diese kÃ¶nnen mittels einer
zusÃ¤tzlichen Textur ebenfalls simuliert werden. Das Ziel hierfÃ¼r besteht
darin, dass sich kreisfÃ¶rmig um alle HÃ¼gel innerhalb der Landschaft
Abstufungen ergeben.

\marginnote{Wave-Textur hinzufÃ¼gen}

Eine ideale Grundlage fÃ¼r dieses Unterfangen bildet die Wave-Textur.
Diese ist im Â«\emph{Add}Â»-MenÃ¼ unter Â«\emph{Texture \textbar{} Wave
Texture}Â» zu finden. Der Vector-Input kann dabei mit dem Vector-Output
des bereits erstellten Mapping-Nodes verbunden werden. Die Wave-Textur
erstellt nun wellenartige Muster Ã¼ber das Mesh hinweg. Dabei orientiert
sich die Wave-Textur entlang der X-Achse. Dies ist im zweiten
Dropdown-MenÃ¼ des Wave-Texture-Nodes definiert. Indem in diesem MenÃ¼
stattdessen die Z-Achse ausgewÃ¤hlt wird, werden die Wellen entlang der
Z-Achse gebildet. Dies fÃ¼hrt dazu, dass sie sich kreisfÃ¶rmig entlang der
HÃ¼gel des Meshes erstrecken. Mittels der Zeile Â«\emph{Scale}Â» kann zudem
die Skalierung dieser Wellen erhÃ¶ht werden, sodass mehr Wellen
ersichtlich sind. HierfÃ¼r kann beispielsweise der Wert 10 verwendet
werden.

\marginnote{Anpassungen der Wave-Textur}

Mittels der Zeile Â«\emph{Distortion}Â» kann ein Wert festgelegt werden,
welcher zu einer Verzerrung der Wellentextur fÃ¼hrt. Je grÃ¶sser dieser
Wert, desto mehr wird die originale Wellentextur zufÃ¤llig verzerrt. Hier
kÃ¶nnte beispielsweise der Wert 9 verwendet werden, um auf die
ZufÃ¤lligkeit von natÃ¼rlichen Verwehungen RÃ¼cksicht zu nehmen. ZusÃ¤tzlich
kÃ¶nnte das Ausmass an ersichtlichen Details in den Wellen mittels der
Reiter Â«\emph{Detail}Â», Â«\emph{Detail Scale}Â» und Â«\emph{Detail
Roughness}Â» bei Bedarf noch variiert werden.

\marginnote{Displacement hinzufÃ¼gen}

Nun kann ein Displacement-Node Ã¼ber das Â«\emph{Add}Â»-MenÃ¼ unter
Â«\emph{Vector \textbar{} Displacement}Â» hinzugefÃ¼gt und unterhalb des
Bump-Nodes eingefÃ¼gt werden. Der Displacement-Node soll nun grÃ¶ssere
OberflÃ¤chenverÃ¤nderungen im Mesh simulieren und die Werte fÃ¼r die HÃ¶he
anhand des Wave-Texture-Nodes Ã¼bernehmen. Deshalb wird der Color-Output
des Wave-Texture-Nodes mit dem Height-Input des Displacement-Nodes
verbunden. Der Wert fÃ¼r die Skalierung sollte innerhalb des
Displacement-Nodes zudem noch minimiert werden, da der Effekt sonst zu
stark ausfÃ¤llt. Ein Wert von 0.01 fÃ¼r die Zeile Â«\emph{Scale}Â» sollte
daher ausreichen. Zu guter Letzt kann der Displacement-Output des
Displacement-Nodes mit dem Displacement-Input des Material-Output-Nodes
verbunden werden. Dadurch sollte das Displacement auf dem Mesh
ersichtlich werden.

\section{Mix RGB}\label{mix-rgb}

\marginnote{Mix-RGB-Node hinzufÃ¼gen}

Die Abstufungen, welche der Wave-Texture-Node erzielt, sind nun
lediglich als Displacement ersichtlich, haben allerdings keinen Einfluss
auf die Farbe, die Roughness oder die Normalen des Materials. Wenn diese
Abstufungen hierfÃ¼r auch berÃ¼cksichtigt werden sollen, mÃ¼ssten die
Farbwerte der Wave-Textur mit den Farbwerten der White-Noise-Textur
kombiniert werden. FÃ¼r die Kombination von verschiedenen Farben oder
Texturen kann der Mix-RGB-Node verwendet werden. Dieser kann unter dem
Â«\emph{Add}Â»-MenÃ¼ unter Â«\emph{Color \textbar{} MixRGB}Â» hinzugefÃ¼gt und
neben dem White-Noise-Texture-Node platziert werden.

\marginnote{Graduelle Abstufung von Farbinputs}

Der Color1-Input des Mix-RGB-Nodes sollte seine Informationen aus dem
Color-Output des White-Noise-Texture-Nodes beziehen. Der Color2-Input
sollte seine Informationen aus dem Color-Output des Wave-Texture-Nodes
beziehen. Dadurch wird anschliessend mittels des Reiters Â«\emph{Fac}Â»
eine graduelle Abstufung zwischen den beiden Texturen mÃ¶glich.

\marginnote{Multiplizieren von Farben}

Das Ziel ist allerdings keine graduelle Abstufung zwischen den beiden
Texture-Nodes. Stattdessen sollten die Wellen der Wave-Textur Ã¼ber die
White-Noise-Textur gelegt werden. Um dies zu erzielen, kann im
Dropdown-MenÃ¼, welches mit Â«\emph{Mix}Â» angeschrieben ist, die Option
Â«\emph{Multiply}Â» ausgewÃ¤hlt werden. Dadurch werden die beiden Texturen
nun nicht mehr miteinander gemischt, sondern multipliziert. Mittel des
Reiters Â«\emph{Fac}Â» kann nun ein Grad fÃ¼r diese Multiplikation
ausgewÃ¤hlt werden, beispielsweise 0.675. Anschliessend kann der
Color-Output des Mix-RGB-Nodes verwendet werden, um die Inputs, welche
bisher vom White-Noise-Texture-Node anvisiert wurden, zu ersetzen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_30/30_2_Final_Dunes_Node_System.png}

\caption{\label{fig-1_2}Kombination der Wave-Textur mit der
White-Noise-Textur.}

\end{figure}%

\section{Prozedurales Texturieren}\label{prozedurales-texturieren-1}

\marginnote{Prozedurales Texturieren}

In diesem Tutorial wurde nun auf Bilddateien zum Texturieren verzichtet.
Stattdessen wurden Blenders interne, vorberechnete Texturen verwendet,
um eine Texturierung der OberflÃ¤che zu erstellen. Eine solche
Herangehensweise wird als prozedurales Texturieren bezeichnet. Dies hat
den Vorteil, dass man sich keine Gedanken machen muss, wie hochauflÃ¶send
die Texturen sein sollten. Durch die Berechnung kÃ¶nnen jeweils hÃ¶here
AuflÃ¶sungen erzielt werden.

\marginnote{Nachteile des prozeduralen Texturierens}

Ein Nachteil des prozeduralen Texturierens besteht allerdings darin,
dass die Texturen eben gerade nicht als Bild vorhanden sind. Dies fÃ¼hrt
etwa dazu, dass die erstellten prozeduralen Texturen nicht in anderen
Programmen (z.B. Unity oder Unreal Engine) dargestellt werden kÃ¶nnen. Es
ist zwar mÃ¶glich, die prozeduralen Texturen zu extrahieren, indem man
sie sozusagen in eine Bilddatei hineinspeichert (ein Prozess, der als
Baking bezeichnet wird), allerdings gehen dabei oft Details der
prozeduralen Texturen verloren.

\chapter{Parameter im
Principled-BSDF-Shader}\label{parameter-im-principled-bsdf-shader}

\marginnote{Parameter im Principled-BSDF-Shader}

Mittlerweile wurde bereits sehr viel mit dem Principled-BSDF-Shader
gearbeitet. Dadurch sollten die wichtigsten Parameter, welche bei dessen
Verwendung berÃ¼cksichtigt werden, bekannt geworden sein. So wurden die
Base-Color, die Roughness und der Metallic-Wert bereits erlÃ¤utert und
durch die Verwendung von Texturen wurden auch bereits die Normal-Werte
verwendet. Es gibt allerdings noch eine Vielzahl weiterer Parameter im
Principled-BSDF-Shader, welche variiert werden kÃ¶nnen. Einige davon
werden, allerdings sehr selten verwendet.

\section{Subsurface-Scattering}\label{subsurface-scattering}

\marginnote{Was ist Subsurface-Scattering?}

Bei der Refraktion von Lichtstrahlen dringen diese Lichtstrahlen in ein
Objekt ein. Anschliessend werden sie in der OberflÃ¤che des Objektes
gestreut und dringen anschliessend wieder aus dem Objekt aus. Diese
Lichtstrahlen kÃ¶nnen dabei unterschiedlich weit innerhalb des Objektes
eindringen. Dadurch kann es in manchen Situationen vorkommen, dass die
Lichtstrahlen auch aus der anderen Seite des Objektes wieder austreten.
Dieser Effekt wird als Subsurface-Scattering bezeichnet. Dabei dringen
Lichtstrahlen durch das Objekt hindurch und scheinen auch das Innere des
Objektes zu beleuchten.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_31/31_1_Subsurface_Scattering.png}

\caption{\label{fig-1_1}Lichtstrahlen beim Subsurface-Scattering. Die
Strahlen dringen deutlich weiter in das Objekt ein und erhellen dessen
Inneres. Bei dÃ¼nnen Objekten dringen die Strahlen durch das Objekt
hindurch.}

\end{figure}%

\marginnote{Beispiel Subsurface-Scattering}

Abbildung 2 zeigt ein Beispiel fÃ¼r Subsurface-Scattering. Die Katze wird
von hinten beleuchtet und die Lichtstrahlen berÃ¼hren die RÃ¼ckseite ihrer
Ohren. Aus der Perspektive der Fotografie werden anschliessend die
Strahlen, die durch das Objekt hindurchdringen, ersichtlich, und fÃ¼hren
dadurch zum Effekt des Subsurface-Scattering.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_31/31_2__Cat_Example_Subsurface_Scattering.jpg}

\caption{\label{fig-1_2}Ein Beispiel fÃ¼r Subsurface-Scattering.}

\end{figure}%

\marginnote{Subsurface-Scattering tritt hÃ¤ufig bei Haut auf}

Abbildung 2 zeigt bereits einen der wichtigsten Anwendungspunkte fÃ¼r
Subsurface-Scattering, nÃ¤mlich die Haut von Lebewesen. Sie kÃ¶nnen auch
bei sich selbst einen Subsurface-Scattering-Effekt induzieren. Schalten
Sie eine kleine Taschenlampe (z.B. diejenige Ihres Smartphones) ein und
legen Sie einen Finger mit dessen Fingerkuppel direkt auf die
Lichtquelle. Wenn Sie dadurch den gesamten Bereich der Lichtquelle
abdecken, sollten eigentlich alle Lichtstrahlen abgefangen werden. Sie
werden allerdings feststellen, dass ein Teil der Lichtstrahlen durch
ihre Haut hindurchdringt.

\marginnote{Subsurface-Scattering muss nicht zwingen durch Objekt hindurchdringen}

Es gibt allerdings auch viele Situationen, in denen das Licht nicht ganz
durch das Objekt hindurchdringt, allerdings trotzdem besonders tief in
das Material einzudringen scheint. Dies wird ebenfalls als
Subsurface-Scattering bezeichnet. Dieser Terminus beinhaltet sowohl
Licht, welches durch die Refraktion durch das Objekt hindurchdringt, als
auch solches, welches so tief in das Objekt hinein dringt, dass dessen
Beleuchtung im Inneren sichtbar wird. Ein weiteres Beispiel fÃ¼r
Subsurface-Scattering sind etwa Wachsobjekte oder Kerzen. Bei diesen
reicht das Subsurface-Scattering oftmals nicht durch das Objekt
hindurch, aber eine Beleuchtung im Inneren des Objektes wird erkennbar.

\marginnote{Parameter fÃ¼r das Subsurface-Scattering im Principled-BSDF-Shader}

FÃ¼r das Subsurface-Scattering gibt es vier Parameter im
Principled-BSDF-Shader:

\begin{itemize}
\tightlist
\item
  Subsurface
\item
  Subsurface Radius
\item
  Subsurface Color
\item
  Subsurface Method
\end{itemize}

\marginnote{Subsurface-Parameter}

In der Zeile Â«\emph{Subsurface}Â» des Principled-BSDF-Shaders kann
definiert werden, wie stark der Subsurface-Scattering-Effekt bei einem
Material eintreten soll. Per Default ist Subsurface-Scattering
deaktiviert, indem dessen Subsurface-Wert auf 0 gesetzt ist. Wenn man
diesen Wert allerdings erhÃ¶ht, wird auch der
Subsurface-Scattering-Effekt erhÃ¶ht.

\marginnote{Subsurface-Radius}

Mittels des Dropdown-MenÃ¼s Â«\emph{Subsurface Radius}Â» lÃ¤sst sich
einstellen, wie hoch der Radius der eindringenden Lichtstrahlen ist.
Dabei stehen drei Eingabewerte zur VerfÃ¼gung. Normalerweise wÃ¼rde man
bei der Kombination von Radius und drei Eingabewerten denken, dass es
sich um die drei Achsen (X, Y und Z) handeln mÃ¼sste. Dies ist beim
Subsurface-Radius allerdings nicht der Fall. Der Radius ist entlang
aller Achsen gleich gross, er unterscheidet sich allerdings hinsichtlich
verschiedener Lichtstrahlen. Die drei Achsen stehen fÃ¼r die Farbwerte
innerhalb des RGB-Spektrums und beschreiben den Radius von Lichtstrahlen
der entsprechenden Farbe.

\marginnote{Rote Lichtstrahlen sind oft am wichtigsten fÃ¼r Subsurface-Scattering}

Per Default ist der Subsurface-Radius der ersten Zeile, welche fÃ¼r rote
Lichtstrahlen steht, am hÃ¶chsten. Dies macht auch Sinn, da
Subsurface-Scattering-Effekte am hÃ¤ufigsten bei Haut anzutreffen sind
und dabei rote Lichtstrahlen am stÃ¤rksten zu erkennen sind. Die zweite
Zeile steht fÃ¼r grÃ¼ne Lichtstrahlen und die dritte Zeile fÃ¼r blaue
Lichtstrahlen. In der Regel werden diese Zahlen so belassen, wie sie
sind.

\marginnote{Subsurface-Color}

Mittels der Farbbox Â«\emph{Subsurface Color}Â» kann eine Farbe definiert
werden, welche sich unterhalb der OberflÃ¤che befinden soll und so durch
das Subsurface-Scattering erscheinen soll. Oftmals handelt es sich dabei
um eine hellere Farbe der Base-Color.

\marginnote{Subsurface-Method}

Das zweite Dropdown-MenÃ¼ im Principled-BSDF-Shader, in dem per Default
Â«\emph{Christensen-Burley}Â» ausgewÃ¤hlt ist, beschreibt die
Â«\emph{Subsurface Method}Â». Dabei kann zwischen zwei Arten der
Berechnung des Subsurface-Scattering-Effekts ausgewÃ¤hlt werden. Die
Option Â«\emph{Christensen-Burley}Â» ist physikalisch weniger akkurat als
die Option Â«\emph{Random Walk}Â», benÃ¶tigt dafÃ¼r allerdings weniger
Leistung beim Rendern von Materialien.

\section{Specularity}\label{specularity}

\marginnote{Specularity fÃ¼r Bereich der Lichtreflexion}

Bislang wurden die Einstellungen Â«\emph{Metallic}Â» und
Â«\emph{Roughness}Â» verwendet, um eine Reflexion zu erzielen. Der
Metallic-Wert beschrieb dabei, wie hoch der Anteil der Refraktion ist,
welcher zur Reflexion hinzukommt, wÃ¤hrend die Roughness durch eine
unebenere OberflÃ¤che zu einer diffuseren Lichtreflexion fÃ¼hrt. Die
Specularity wurde dabei jeweils konstant gelassen. TatsÃ¤chlich ist
allerdings auch die Specularity fÃ¼r die Reflexion mitverantwortlich. Sie
dient der Berechnung, an welchen Stellen eine Reflexion erfolgen soll.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_31/31_3_Low_Angle.png}

\caption{\label{fig-1_3}Lichtstrahlen mit einem tiefen Einfallswinkel.
In solchen FÃ¤llen kommt es eher zu einer Refraktion.}

\end{figure}%

\subsection{Einfallswinkel und Index of
Refraction}\label{einfallswinkel-und-index-of-refraction}

\marginnote{Fresnel}

Jedes Objekt hat ein gewisses Potenzial, um Licht zu reflektieren.
Abbildung 2 zeigt eine Katze innerhalb einer Kartonschachtel. Diese
Kartonschachtel reflektiert die Umgebung nicht besonders stark,
allerdings zeigt sie an den vorderen und hinteren Kanten des Kartons
einen etwas helleren Bereich. An diesen Stellen entsteht ein Effekt, der
als Fresnel bezeichnet wird.

\marginnote{Einfallswinkel sorgt fÃ¼r Fresnel}

Ein Fresnel-Effekt ergibt sich durch den Einfallswinkel des Lichtes. Je
hÃ¶her der Einfallswinkel des Lichtes ist, desto eher kommt es zu einer
Reflexion des Lichtes. Ist der Einfallswinkel des Lichtes geringer,
kommt es eher zu einer Refraktion. An Kanten ergeben sich dadurch hÃ¶here
Einfallswinkel je nach Ausrichtung zu einer Lichtquelle und dadurch wird
dort ein hÃ¶herer Anteil von Licht reflektiert.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_31/31_4_High_Angle.png}

\caption{\label{fig-1_4}Lichtstrahlen mit einem hohen Einfallswinkel. In
solchen FÃ¤llen kommt es eher zu einer Reflexion.}

\end{figure}%

\marginnote{IOR}

Dieser Fresnel-Effekt hÃ¤ngt nebst dem Einfallswinkel des Lichtes auch
vom Â«Index of RefractionÂ» (IOR) eines Materials ab. Jedes physikalische
Material besitzt diese Eigenschaft und beschreibt, wie stark dieses
Material Lichtreflexionen bricht. Eine genauere Beschreibung hierzu
erfolgt spÃ¤ter bei den Transmission-Einstellungen.

\subsection{Specularity ermitteln}\label{specularity-ermitteln}

\marginnote{IOR berechnen}

Durch eine kurze Internetrecherche lÃ¤sst sich schnell der IOR fÃ¼r ein
Material ausfindig machen. So hat Gold einen IOR von 0.479, Eis einen
IOR von 1.309, Milch einen IOR von 1.350 und Asphalt weist einen IOR von
1.635 auf (Quelle: \url{https://pixelandpoly.com/ior.html}). Diese Werte
kÃ¶nnten nun direkt in die Zeile Â«\emph{Specular}Â» eingegeben werden. Das
Problem ist jedoch, dass diese Zeile nicht fÃ¼r physikalisch korrekte
IOR-Werte angepasst ist und mit Inputs von 0 bis 1 arbeitet. Aus diesem
Grund muss der IOR von Hand in den Specular-Input umgewandelt werden.
Die Formel hierfÃ¼r lautet:

\includegraphics{Chapters/Images/Chapter_31/Formula.png}\hfill

\marginnote{Value-Node hinzufÃ¼gen und IOR eintragen}

Somit kÃ¶nnte man von Hand die Specularity anhand dieser Formel
ausrechnen. Es gibt allerdings auch die MÃ¶glichkeit, dass Blender diese
Formel automatisch fÃ¼r ein Material berechnet. HierfÃ¼r wird im
Shader-Editor ein Â«\emph{Value}Â»-Node hinzugefÃ¼gt, welcher im
Â«\emph{Add}Â»-MenÃ¼ unter Â«\emph{Input \textbar{} Value}Â» zu finden ist.
In diesem Node wird anschliessend der Wert des IORs fÃ¼r das
entsprechende Material eingegeben, beispielsweise 0.479 fÃ¼r ein goldenes
Material.

\marginnote{Math-Node zum Addieren verwenden}

Nun wird ein Â«\emph{Math}Â»-Node benÃ¶tigt. Dieser ermÃ¶glicht die
DurchfÃ¼hrung mathematischer Operationen anhand eingegebener Werte. Der
Math-Node kann im Â«\emph{Add}Â»-MenÃ¼ unter Â«\emph{Converter \textbar{}
Math}Â» hinzugefÃ¼gt und rechts neben dem Value-Node platziert werden. Der
Value-Output des Value-Nodes wird anschliessend mit dem ersten
Value-Input des Math-Nodes verbunden. Im zweiten Value-Felddes
Math-Nodes kann anschliessend der Wert 1 eingegeben werden. Dies fÃ¼hrt
nun dazu, dass die Operation, welche im Math-Node ausgewÃ¤hlt ist, mit
diesen beiden Werten durchgefÃ¼hrt wird. In dem Fall berechnet der Node
also 0.479 + 1.

\marginnote{Math-Node zum Subtrahieren verwenden}

Der Math-Node kann nun mittels der Tastenkombination \kbd{Shift} +
\kbd{D} dupliziert und oberhalb des ersten Math-Nodes platziert werden.
Sein erster Value-Input sollte ebenfalls die Informationen aus dem
Value-Output des Value-Nodes erhalten. Nun soll allerdings die Differenz
zwischen dem Value-Input und 1 berechnet werden. Deshalb wird im
Dropdown-MenÃ¼ innerhalb des Nodes statt der Operation Â«\emph{Add}Â» die
Operation Â«\emph{Subtract}Â» ausgewÃ¤hlt. Dadurch wird nun 0.479 -- 1
berechnet.

\marginnote{Math-Node zum Dividieren verwenden}

Nun wird der Math-Node erneut dupliziert und das Duplikat rechts neben
den beiden bisherigen Math-Nodes platziert. Der erste Value-Input dieses
neuen Math-Nodes sollte den Value-Output des subtrahierenden Math-Nodes
erhalten und der zweite Value-Input den Value-Output des addierenden
Math-Nodes. Dieser Math-Node wird anschliessend im Dropdown-MenÃ¼ auf
Â«\emph{Divide}Â» umgestellt. Dadurch wird der Output des subtrahierenden
Math-Nodes durch den Output des addierenden Math-Nodes dividiert.

\marginnote{Math-Node zum Potenzieren verwenden}

Als NÃ¤chstes wird erneut ein Duplikat des Math-Nodes erstellt und rechts
neben den dividierenden Math-Node platziert. Dieser Math-Node sollte als
ersten Value-Input den Value-Output des dividierenden Math-Nodes
erhalten und in der zweiten Zeile sollte der Wert 2 eingegeben werden.
Die Operation dieses Math-Nodes sollte auf Â«\emph{Power}Â» gestellt
werden. Dadurch wird nun das Ergebnis der Division potenziert.

\marginnote{Math-Node zum erneuten Dividieren}

Nun wird noch ein letztes Mal ein Duplikat des dividierenden Math-Nodes
erstellt und rechts neben den potenzierenden Math-Node platziert. Der
erste Value-Input wird mit dem Value-Output des potenzierenden
Math-Nodes verbunden und die zweite Value-Zeile wird auf 0.08 gesetzt.
Dadurch wird der Output des potenzierenden Math-Nodes durch den Wert
0.08 dividiert. Wenn nun alle Nodes entsprechend der Abbildung 6
eingefÃ¼gt wurden, sollte der Output des letzten Math-Nodes nun den Wert
fÃ¼r den Specular-Input enthalten.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_31/31_5_Specularity_Calc.png}

\caption{\label{fig-1_6}Node-Anordnung, um die Specularity anhand des
IORs zu berechnen.}

\end{figure}%

\marginnote{Was ist dabei passiert?}

Ãœber den Value-Node wird eine Zahl als Input definiert -- in diesem Fall
der IOR, welcher fÃ¼r das Material bekannt ist. Dieser IOR durchlÃ¤uft
anschliessend die Operationen zur Berechnung der Specularity und gibt
dieses anschliessend als Wert des letzten Math-Nodes aus. Dieser kann
nun direkt mit dem Specular-Input des Principled-BSDF-Nodes verbunden
werden. Wenn ein anderer IOR verwendet werden mÃ¼sste, kann lediglich der
Wert innerhalb des Value-Nodes verÃ¤ndert werden und Blender berechnet
basierend auf dem Node-System anschliessend die korrekte Specularity und
Ã¼berweist diese dem Specular-Input des Principled-BSDF-Shaders.

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Wenn Sie mit Nodes in Blender arbeiten, stellt dies eine Form des Programmierens dar. Statt mit Codes und Zeilen wird allerdings mit Nodes und Verbindungen zwischen den Nodes gearbeitet. Dies stellt eine Form des Programmierens dar, welche auch in einigen Game-Engines zur VerfÃ¼gung steht. Sollten Sie die Anleitung zur Berechnung des IORs selbst ausprobiert haben: Gratulation, Sie haben eine Funktion zur Berechnung der Specularity anhand des IORs in Blender erstellt!
\end{tipp}

\marginnote{Specular-Tint}

Nebst dem Specular-Reiter verfÃ¼gt der Principled-BSDF-Shader noch Ã¼ber
den Reiter Â«\emph{Specular Tint}Â». Die Reflexion der Lichtstrahlen
basierend auf dem Specular-Wert erfolgt jeweils anhand weisser Farbe.
Diese Farbe kann allerdings auch mit der Base-Color des jeweiligen
Materials gemischt werden. HierfÃ¼r steht der Reiter Specular-Tint zur
VerfÃ¼gung. Je hÃ¶her dieser Reiter ist, desto hÃ¶her ist der Anteil der
Base-Color in der Mischung der weissen Reflexionsfarbe.

\marginnote{Muss die Specularity angepasst werden?}

Ãœber den Nutzen des Specularity-Effekts gibt es verschiedene Meinungen.
Jedes Material verfÃ¼gt Ã¼ber einen Fresnel-Effekt. Dementsprechend
verfÃ¼gt auch jedes Material Ã¼ber eine gewisse Specularity. Per Default
ist der Wert fÃ¼r den Specular-Reiter bereits auf 0.5 eingestellt. Einige
Nutzer von Blender verweisen darauf, dass dieser Wert direkt so belassen
werden kann, da dies in den meisten FÃ¤llen ausreichend ist.

\section{Anisotropie}\label{anisotropie}

\marginnote{Anisotropie}

Mithilfe der Einstellungen zur Anisotropie kann die rÃ¤umliche
Ausbreitung von Reflexionen gesteuert werden. Hierbei ist allerdings zu
berÃ¼cksichtigen, dass diese Einstellung in der bislang verwendeten
Render-Engine (Eevee) nicht berÃ¼cksichtigt wird. Um den Effekt der
Anisotropie auf einem Modell nachvollziehen zu kÃ¶nnen, mÃ¼sste Cycles als
Render-Engine ausgewÃ¤hlt werden.

\marginnote{Tangente}

Die Reflexion durch die Anisotropie erfolgt entlang der sogenannten
Tangente. Diese Tangente kann angesteuert und verÃ¤ndert werden, indem
ein entsprechender Â«\emph{Tangent}Â»-Node, welcher im Â«\emph{Add}Â»-MenÃ¼
unter Â«\emph{Input \textbar{} Tangent}Â» zu finden ist, mit dem
Tangent-Input des Principled-BSDF-Shaders verbunden wird.

\marginnote{Anisotropic}

Mithilfe des Reiters Â«\emph{Anisotropic}Â» kann bearbeitet werden, wie
sich Glanzlichter einer Reflexion entlang eines Objekts vollziehen. Je
hÃ¶her dieser Wert eingestellt ist, desto mehr werden Reflexionslichter
entlang der Tangente erstreckt. Negative Werte fÃ¼hren hingegen dazu,
dass sich die Reflexionslichter senkrecht zur Tangente erstrecken.

\marginnote{Anisotropic Rotation}

Mithilfe des Reiters Â«\emph{Anisotropic Rotation}Â» kann zudem eine
Rotation fÃ¼r die Anisotropie erzeugt werden. Ein Wert von 1 bedeutet
dabei, dass die Anisotropie kreisfÃ¶rmig verlÃ¤uft, wÃ¤hrend ein Wert von 0
zu einer Ausbreitung entlang einer Linie fÃ¼hrt.

\section{Sheen}\label{sheen}

\marginnote{Sheen}

Die Einstellung Â«\emph{Sheen}Â» wird lediglich in sehr seltenen FÃ¤llen
verwendet. Dadurch wird die Reflexion von OberflÃ¤chen an deren Kanten
abgedÃ¤mpft. Dieser Effekt ist vor allem bei Textilien relevant, da diese
an den Kanten etwas weniger stark reflektieren. Mithilfe des Reiters
Â«\emph{Sheen}Â» wird angegeben, wie stark dieser AbdÃ¤mpfungseffekt
vollzogen werden soll. FÃ¼r Textilien wÃ¤re ein Wert von 1 zu empfehlen,
wÃ¤hrend fÃ¼r andere Materialien die Standardeinstellung von 0 verwendet
werden kann.

\marginnote{Sheen Tint}

Mithilfe des Reiters Â«\emph{Sheen Tint}Â» kann dem Sheen-Effekt ein Mass
fÃ¼r die EinfÃ¤rbung mittels der Base-Color zugewiesen werden. Der Effekt
der Sheen-Reflexion basiert auf einer Reflexion mit weisser Farbe.
Mithilfe des Reglers Â«\emph{Sheen Tint}Â» kann diese Farbe mit der
Base-Color vermischt werden. Je hÃ¶her der Wert des Sheen-Tints, desto
hÃ¶her der Anteil der Base-Color am Sheen-Effekt.

\section{Clearcoat}\label{clearcoat}

\marginnote{Clearcoat}

Mittels der Clearcoat-Einstellungen kann eine weitere Schicht Ã¼ber einem
Material simuliert werden. Dadurch erscheint das Material, als wÃ¼rde es
aus mehreren Schichten bestehen. Die zweite Schicht stellt den Clearcoat
dar. Dabei handelt es sich um eine reflektierende OberflÃ¤che. Clearcoat
kann etwa fÃ¼r Lack verwendet werden, welcher eine zusÃ¤tzliche
reflektierende OberflÃ¤che auf einem bestehenden Metall-Material
darstellt.

\marginnote{Einstellungen fÃ¼r den Clearcoat}

FÃ¼r den Clearcoat gibt es folgende EinstellungsmÃ¶glichkeiten im
Principled-BSDF-Shader:

\begin{itemize}
\tightlist
\item
  Â«\textbf{\emph{Clearcoat}}Â»: Mittels des Reiters Â«\emph{Clearcoat}Â»
  kann das Ausmass der Reflexion der Clearcoat Schicht, welche Ã¼ber dem
  Material simuliert wird, eingestellt werden. Ein Wert von 0 bedeutet
  dabei, dass der Clearcoat nicht berÃ¼cksichtigt wird, wÃ¤hrend ein Wert
  von 1 fÃ¼r einen stark reflektierenden Clearcoat verwendet wird.
\item
  Â«\textbf{\emph{Clearcoat Roughness}}Â»: Mittels des Reiters
  Â«\emph{Clearcoat Roughness}Â» kann fÃ¼r die Clearcoat Schicht ein
  individuelles Ausmass der Roughness definiert werden.
\item
  Â«\textbf{\emph{Clearcoat Normal}}Â»: Mittels des Inputs
  Â«\emph{Clearcoat Normal}Â» kann fÃ¼r die Clearcoat-Schicht ein eigener
  Normalen-Input verwendet werden. Dies ermÃ¶glicht es etwa, dass ein
  Bump-Node mit der Clearcoat-Normal verbunden wird. Dadurch kÃ¶nnen
  Unebenheiten auf der Clearcoat-Schicht individuell erstellt werden.
\end{itemize}

\section{Transmission}\label{transmission}

\marginnote{Transmission}

Die Einstellungen zur Transmission werden verwendet, um Materialien zu
erstellen, durch die man hindurchblicken kann -- beispielsweise GlÃ¤ser.
In solchen FÃ¤llen durchdringen die Lichtstrahlen das Objekt vollstÃ¤ndig
und Inhalte, welche sich hinter dem Objekt befinden, werden sichtbar.
Dabei werden die Lichtstrahlen je nach Beschaffenheit des Materials
gebrochen. Dadurch werden Inhalte, die sich hinter dem Glas befinden, zu
einem gewissen Grad verschoben dargestellt. Diese Brechung der
Lichtstrahlen beschreibt der IOR.

\marginnote{IOR}

Ein IOR mit einem Wert von 1 wÃ¼rde bedeuten, dass keine Brechung der
Lichtstrahlen erfolgt. Je stÃ¤rker der IOR vom Wert 1 abweicht, desto
stÃ¤rker werden die Lichtstrahlen gebrochen. Das heisst: Ein Glas,
welches einen IOR von 1 aufweist, wÃ¼rde Licht refraktieren lassen, aber
es gÃ¤be keine Brechung in der Refraktion. Dadurch wÃ¼rde das Glas
unsichtbar und kÃ¶nnte nicht mehr erkannt werden. Ein IOR von 1.01 wÃ¼rde
allerdings bereits zu einer Brechung der Lichtstrahlen fÃ¼hren, wodurch
das Glas ersichtlich wird. Durch einen IOR von 1.45 wird diese Brechung
nochmals erhÃ¶ht.

\marginnote{IOR fÃ¼r GlÃ¤ser festlegen}

Um den IOR bei der Transmission festzulegen, kann im
Principled-BSDF-Shader die Zeile Â«\emph{IOR}Â» verwendet werden und dort
der jeweilige IOR eingegeben werden. Die Zeile Â«\emph{IOR}Â» bezieht sich
lediglich auf den IOR im Falle einer Transmission. Deshalb ist es
beispielsweise bei der Einstellung der Specularity nÃ¶tig, den IOR
mittels des Specular-Reiters zu definieren.

\marginnote{Transmission}

Der Reiter Â«\emph{Transmission}Â» beschreibt anschliessend den Anteil an
Lichtstrahlen, welche das Material durchdringen. Eine Transmission von 0
bedeutet, dass kein Licht das Objekt durchdringt, wÃ¤hrend eine
Transmission von 1 bedeutet, dass das gesamte Licht durchdringt. In der
Regel wird fÃ¼r die Erstellung eines Glas-Materials dieser Wert auf 1
gesetzt.

\marginnote{Transmission-Roughness}

Mittels des Reiters Â«\emph{Transmission Roughness}Â» kann zudem
eingestellt werden, wie gebÃ¼ndelt die Lichtstrahlen das Objekt
durchdringen sollen. Durch eine erhÃ¶hte Transmission-Roughness erscheint
ein Glas zunehmend milchiger, weil die Lichtstrahlen zunehmend diffuser
durch das Glas hindurchscheinen.

\section{Emission}\label{emission}

\marginnote{AbhÃ¤ngigkeit von Lichtquellen}

Die Einstellungen des Materials hÃ¤ngen zu einem Grossteil auch von den
Lichtquellen innerhalb einer Szene ab. Wenn ein Material kein Licht
bekommt, kann es kein Licht reflektieren und wird deshalb schwarz
dargestellt.

\marginnote{Emission, um Licht durch das Material auszustrahlen}

Es ist allerdings mÃ¶glich, dass ein Material Licht aussendet. HierfÃ¼r
kÃ¶nnen die Parameter Â«\emph{Emission}Â» und Â«\emph{Emission Strength}Â»
verwendet werden. In der Farbbox Â«\emph{Emission}Â» kann eine Farbe
ausgewÃ¤hlt werden, welche das Material anschliessend ausstrahlt. Mittels
des Reiters Â«\emph{Emission Strength}Â» kann eingestellt werden, wie
stark diese Farbe ausgestrahlt wird. Eine Emission von 0 steht fÃ¼r keine
Ausstrahlung und eine Emission von 1 steht fÃ¼r eine Ausstrahlung. Dieser
Wert kann allerdings noch deutlich erhÃ¶ht werden, um eine noch stÃ¤rkere
Ausstrahlung zu erzielen.

\marginnote{Schwarze Farbe strahlt nicht aus}

Bei einer genauen Betrachtung fÃ¤llt allerdings auf, dass der
Principled-BSDF-Shader in seinen Standardeinstellungen eine
Emission-Strength von 1 aufweist. Trotzdem wurde bislang nie eine Farbe
ausgestrahlt. Dies liegt daran, dass in den Standardeinstellungen die
Farbe Schwarz in der Emission-Farbbox ausgewÃ¤hlt ist. Diese verfÃ¼gt Ã¼ber
keine Helligkeitswerte, welche ausgestrahlt werden kÃ¶nnen. Deshalb wird
in diesem Fall keine Farbe ausgestrahlt. Sobald eine andere Farbe in der
Emission-Farbbox ausgewÃ¤hlt wird, sollte diese Farbe ausgestrahlt
werden.

\marginnote{Emission Ã¼berdeckt andere Parameter des Materials}

Die ausgestrahlte Farbe Ã¼berdeckt jeweils die anderen Einstellungen im
Principled-BSDF-Shader. So bleibt die Darstellung der Materialien
identisch, wenn beispielsweise die Roughness- oder die
Metallic-Parameter verÃ¤ndert werden. Lediglich bei einer sehr geringen
Emission-Strength lÃ¤sst sich noch ein minimaler Einfluss, beispielsweise
der Base-Color, erkennen.

\section{Distribution}\label{distribution}

\marginnote{Distribution-Einstellungen}

Zuoberst im Principled-BSDF-Shader befindet sich das Dropdown-MenÃ¼
Â«\emph{Distribution}Â». Dieses ist standardmÃ¤ssig auf Â«\emph{GGX}Â»
eingestellt. Alternativ kann die Einstellung Â«\emph{Multiscatter GGX}Â»
eingestellt werden. Bei diesen Optionen handelt es sich um
Einstellungen, anhand derer Blender die Materialien berechnet. GGX ist
schneller in der Berechnung als Multiscatter-GGX, aber physikalisch
weniger akkurat. In der Regel kann GGX als Einstellung beibehalten
werden. Zudem ist zu beachten, dass bei der Verwendung von
Multiscatter-GGX die Transmission-Roughness nicht mehr definiert werden
kann.

\chapter{Der Wechsel von Eevee zu Cycles am Beispiel von
Glas}\label{der-wechsel-von-eevee-zu-cycles-am-beispiel-von-glas}

\section{GlÃ¤ser in Eevee richtig darstellen
lassen}\label{gluxe4ser-in-eevee-richtig-darstellen-lassen}

\marginnote{Beispiel mit Glas auf Tisch}

Das Arbeiten mit Glas als Material benÃ¶tigt einige Anpassungen bei der
Darstellung innerhalb der Einstellungen der aktuellen Render-Engine
(Eevee). Die Datei Â«\emph{Beispiel\_Glas\_Material}Â» wird nachfolgend
verwendet, um diese Problematik aufzuzeigen. Innerhalb dieser Datei ist
ein Glas auf einem Tisch dargestellt. SÃ¤mtliche Texturen und Materialien
wurden bereits fÃ¼r die verschiedenen Objekte erstellt. Deshalb kann das
Beispiel im Render-Shading-Modus betrachtet werden.

\marginnote{Weitere Einstellungen benÃ¶tigt, um Glasmaterialien zu verwenden}

Das Glas reflektiert seine Umwelt zu einem bestimmten Grad, allerdings
wirkt die Umwelt stark verzogen. Dies liegt daran, dass die aktuell
ausgewÃ¤hlte Render-Engine (Eevee) darauf ausgelegt ist, dass Inhalte
mÃ¶glichst schnell und idealerweise in Echtzeit gerendert werden. HierfÃ¼r
mÃ¼ssen einige Abstriche gemacht werden. Ein solcher Abstrich ist nun bei
diesem Glas sichtbar.

\marginnote{Screen-Space-Reflections aktivieren}

Um mÃ¶glichst schnell arbeiten zu kÃ¶nnen, ist bei Eevee standardmÃ¤ssig
eine komplexere Berechnung von Reflexionen ausgeschaltet. Diese wird nun
allerdings benÃ¶tigt, damit das Glas realistischer erscheint. Um diese
Option einzuschalten, muss im Properties-Editor der zweitoberste Reiter
Â«\emph{Render Properties}Â» geÃ¶ffnet werden. Darin ist ein Reiter fÃ¼r die
Â«\emph{Screen Space Reflections}Â» aufzufinden, der allerdings
deaktiviert ist. Dieser Reiter sollte aktiviert werden. Durch die
Aktivierung dieses Reiters ist bereits ersichtlich, dass Reflexionen nun
deutlicher wiedergeben werden. ZusÃ¤tzlich sollte allerdings dieser
Reiter geÃ¶ffnet und Â«\emph{Refraction}Â» aktiviert werden. Dadurch sollte
nun auch das Fenster im Hintergrund lichtdurchlÃ¤ssig und die Aussenwelt
sichtbar werden.

\marginnote{Screen-Space-Refraction fÃ¼r ein Material aktivieren}

Im Glas selbst hat sich allerdings bislang noch keine VerÃ¤nderung
gezeigt. Dies liegt daran, dass in Eevee zusÃ¤tzlich fÃ¼r jedes Material
per Default die Einstellung zur komplexeren Berechnung von Reflexionen
deaktiviert ist. Deshalb muss das Glas ausgewÃ¤hlt werden und der
Material-Reiter im Properties-Editor geÃ¶ffnet werden. Unter dem Reiter
Â«\emph{Settings}Â» kÃ¶nnen anschliessend weitere Einstellungen vorgenommen
werden. Hier muss nun fÃ¼r das ausgewÃ¤hlte Material die Einstellung
Â«\emph{Screen Space Refraction}Â» aktiviert werden. Dadurch werden auch
beim Glas, welches sich auf dem Tisch befindet, die Reflexionen durch
das Glas korrekt berechnet.

\marginnote{Zusammenfassung der Einstellungen, um GlÃ¤ser in Eevee anzeigen zu lassen}

Um GlÃ¤ser korrekt anzeigen zu lassen, sind somit folgende drei
Einstellungen in Eevee nÃ¶tig:

\begin{itemize}
\tightlist
\item
  In den Render-Properties muss Â«\emph{Screen Space Reflections}Â»
  aktiviert werden.
\item
  Im Reiter zu den Screen-Space-Reflections muss Â«\emph{Refraction}Â»
  aktiviert werden.
\item
  In den Einstellungen zum Glas-Material muss zusÃ¤tzlich Â«\emph{Screen
  Space Refraction}Â» aktiviert werden.
\end{itemize}

\marginnote{Glas-Parameter variieren}

Mithilfe dieser Vorbereitungen kann nun anhand dieses Beispiels
betrachtet werden, welche Auswirkungen verschiedene IOR-, Transmission-
und Transmission-Roughness-Werte mit sich bringen. Ein IOR von 1 fÃ¼hrt
beispielsweise dazu, dass das Glas praktisch unsichtbar erscheint. Durch
eine ErhÃ¶hung der Transmission-Roughness wird das Glas wiederum etwas
milchiger.

\section{Der Wechsel von Eevee zu
Cycles}\label{der-wechsel-von-eevee-zu-cycles}

\marginnote{Eevee vs. Cycles}

Wie bereits erwÃ¤hnt, ist Eevee als Render-Engine darauf ausgerichtet,
dass Bilder mÃ¶glichst in Echtzeit erzeugt werden. Dies geschieht auf
Kosten von realitÃ¤tsgetreuen Darstellungen. Blender verfÃ¼gt nebst Eevee
noch Ã¼ber eine zweite Render-Engine namens Cycles. Diese Engine benÃ¶tigt
deutlich mehr Leistung und braucht dadurch auch lÃ¤nger, um die
Darstellung von Inhalten zu berechnen. Dabei hÃ¤ngt es stark von den
KapazitÃ¤ten des jeweiligen Rechners ab, wie lange diese Berechnung
dauert. ZusÃ¤tzlich gibt es noch die Render-Engine Â«WorkbenchÂ». Diese ist
sehr rudimentÃ¤r aufgebaut und ist nicht fÃ¼r realistische Darstellungen
geeignet.

\marginnote{Render-Engine wechseln}

Die Render-Engine lÃ¤sst sich im Properties-Editor unter dem Reiter fÃ¼r
die Render-Properties einstellen. Zuoberst wird dabei unter
Â«\emph{Render Engine}Â» ein Dropdown-MenÃ¼ dargestellt, in dem zwischen
den verschiedenen Engines gewechselt werden kann. Durch die Auswahl von
Cycles wird das Bild anschliessend mittels dieser Engine berechnet.

\marginnote{Arbeitsweise von Cycles}

Cycles funktioniert etwas anders als Eevee. WÃ¤hrend Eevee ein finales
Bild erzeugt hat, erstellt Cycles eine Vielzahl von Bildern (sogenannte
Samples) und Ã¼berlappt diese zu einem finalen Bild. Dies fÃ¼hrt zu
realistischeren Darstellungen, aber auch dazu, dass es Fehler in der
Abbildung gibt. Dies zeigt sich in der Form von weissem Noise, welcher
Ã¼ber das Bild gestreut wird. Die einzelnen Punkte dieses Noises werden
als Fireflies bezeichnet.

\marginnote{Fireflies entfernen}

In Blender gibt es eine eingebaute Option, damit die Fireflies entfernt
werden. Diese ist in den Render-Properties unter dem Reiter
Â«\emph{Sampling}Â» unter dem darunterliegenden Reiter Â«\emph{Denoising}Â»
zu finden. Dort kann die Einstellung Â«\emph{Viewport}Â» aktiviert werden.
Dadurch entfernt Blender automatisch die Fireflies im
3D-Viewport-Editor. Wird zudem die Option Â«\emph{Render}Â» ausgewÃ¤hlt,
geschieht dies auch bei finalen Renders.

\marginnote{Pausieren des Renderns}

Durch den Wechsel der Render-Engine erscheint im 3D-Viewport-Editor in
der rechten oberen Ecke eine zusÃ¤tzliche SchaltflÃ¤che. Diese gibt
jeweils an, ob gerade gerendert wird oder nicht. Sollte das Bild einmal
einfrieren und nicht neu gerendert werden, sollte anhand dieser
SchaltflÃ¤che Ã¼berprÃ¼ft werden, ob das Rendern gerade pausiert wurde.

\section{Rendern mit der GPU in
Cycles}\label{rendern-mit-der-gpu-in-cycles}

\marginnote{Prozessorleistung benÃ¶tigt fÃ¼r Cycles}

Bei der Erstellung der 3D-Objekte wird jeweils der Prozessor des
Computers verwendet. Die Leistung, welcher dieser Prozessor aufweist,
hÃ¤ngt dabei vom jeweiligen Modell ab. Dadurch kann es vorkommen, dass
manche Computer fÃ¼r komplexere Projekte weniger geeignet sind. Durch den
Wechsel der Render-Engine von Eevee auf Cycles wird die Rechenleistung
des Prozessors zunehmend bedeutsamer, da in Cycles bereits die Vorschau
im 3D-Viewport-Editor im Render-Shading-Modus vom Prozessor abhÃ¤ngt.
Etwas schneller verlÃ¤uft hingegen die Darstellung im
Material-Preview-Shading-Modus. Dies liegt daran, dass dieser Modus auf
Eevee zurÃ¼ckgreift, selbst wenn Cycles als Render-Engine ausgewÃ¤hlt ist.

\marginnote{GPU kann zum Rendern in Cycles verwendet werden}

Auf einigen Computern ist es mÃ¶glich, dass die Grafikkarte verwendet
wird, um die nÃ¶tige Renderleistung zu erzielen. Dies bringt allerdings
nur einen Vorteil mit sich, wenn die Grafikkarte die entsprechende
Leistung aufbringen kann. Zudem hÃ¤ngt dies auch von Eigenschaften des
GerÃ¤tes und des Betriebssystems ab. Auf Apple-GerÃ¤ten steht diese Option
beispielsweise nicht zur VerfÃ¼gung.

\marginnote{Cycles-Render-Devices}

Windows-Nutzer kÃ¶nnen unter Â«\emph{Edit \textbar{} Preferences}Â» im
Reiter Â«\emph{System}Â» nachverfolgen, ob das Ansteuern der Grafikkarte
mÃ¶glich ist. Unter dem Bereich Â«\emph{Cycles Render Devices}Â» sind
jeweils vier Tabs aufzufinden. FÃ¼r Mac-Nutzer wird dieser Reiter gar
nicht angezeigt. In den Reitern Â«\emph{CUDA}Â», Â«\emph{OptiX}Â» und
Â«\emph{OpenCL}Â» wird jeweils die Grafikkarte nebst dem Prozessor
aufgefÃ¼hrt, insofern diese durch die entsprechenden Optionen anwÃ¤hlbar
sind. Sollte die Grafikkarte dort auffindbar sein, kann diese angewÃ¤hlt
werden. Von nun an kann die Grafikkarte (GPU) statt des Prozessors (CPU)
fÃ¼r das Rendern in Cycles verwendet werden.

\marginnote{GPU zum Rendern aktivieren}

Damit die GPU auch wirklich beim Rendern verwendet wird, muss im
Render-Properties-Reiter des Properties-Editors die Einstellung
Â«\emph{Device}Â» von der Auswahl Â«\emph{CPU}Â» auf Â«\emph{GPU Compute}Â»
umgestellt werden. Die erste gerenderte Darstellung mittels der GPU wird
allerdings eine Weile benÃ¶tigen. Blender nimmt im Hintergrund einige
Anpassungen vor, um mit der GPU zu arbeiten. Dadurch erscheint es, als
ob das Unterfangen nicht funktioniert. Sollten die Viewport Overlays
aktiviert sein, wird allerdings mittels eines Textes in der linken
oberen HÃ¤lfte erlÃ¤utert, dass aktuell die Render-Kerne geladen werden
und dies einige Minuten in Anspruch nehmen wird.

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Unterschiedliche GPUs und CPUs benÃ¶tigen in Cycles unterschiedlich lange zum Rendern von Szenen. Auf der Website <https://opendata.blender.org/> sind Benchmarks fÃ¼r verschiedene Prozessoren, Grafikkarten und Betriebssysteme ersichtlich. So kann verglichen werden, wie lange verschiedene Hardware-Optionen zum Rendern verschiedener Beispielszenen benÃ¶tigen. Zudem kann auch eine Applikation heruntergeladen werden, welche einen Benchmark auf dem eigenen Rechner durchfÃ¼hrt.
\end{tipp}

\marginnote{GPU Compute ohne entsprechende Devices auswÃ¤hlen bringt nichts}

Die Option Â«\emph{GPU Compute}Â» kann auch von Nutzern ohne die
entsprechende Hardware ausgewÃ¤hlt werden, allerdings wird sich kein
Effekt zeigen. Dies ist jeweils daran zu erkennen, dass das
Dropdown-MenÃ¼ mit der Auswahl von Â«\emph{GPU Compute}Â» dann grau
hinterlegt wird.

\chapter{Lichtquellen in einer Szene}\label{lichtquellen-in-einer-szene}

\marginnote{Lichtstrahlen werden benÃ¶tigt}

Die Abbildung 1 zeigt eine in Blender gerenderte Szene einer Spielfigur
auf einem Spielbrett. Damit diese Szene Ã¼berhaupt erstellt werden kann,
benÃ¶tigt es eine Beleuchtung. Anhand der Beleuchtung erhalten die
Objekte Lichtstrahlen, welche sie reflektieren kÃ¶nnen. Ohne die
reflektierten Lichtstrahlen wÃ¼rde das Objekt schwarz dargestellt. Wenn
kein Licht in einer Szene vorhanden ist, wird eine gerenderte Szene
komplett schwarz dargestellt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_33/33_1_NoLight_Image.png}

\caption{\label{fig-1_1}Eine Spielfigur auf einem Spielfeld. Die
Beleuchtung erfolgt aus allen Winkeln gleichmÃ¤ssig durch die
Hintergrundwelt.}

\end{figure}%

\marginnote{MÃ¶glichkeiten, um Lichtstrahlen zu erzeugen}

Um eine Beleuchtung zu erzielen, gibt es drei gÃ¤ngige Methoden:

\begin{itemize}
\tightlist
\item
  Ein Lichtobjekt wird der Szene hinzugefÃ¼gt (z.B. Lampe, Sonne).
\item
  Die Welt im Hintergrund der Szene wird als Lichtquelle verwendet.
\item
  Ein Material wird als Lichtquelle verwendet (z.B. Ã¼ber die Einstellung
  Â«\emph{Emission}Â» im Principled BSDF-Shader).
\end{itemize}

\marginnote{Welt als Lichtquelle}

In der Abbildung 1 werden das Spielbrett, der darunterliegende blaue
Boden und die Spielfigur durch die Hintergrundwelt beleuchtet. Die
Hintergrundwelt besteht in diesem Beispiel aus einer konstanten Farbe,
welche aus allen Winkeln gleich stark ausgestrahlt wird. Dadurch
reflektieren die Objekte die Strahlen aus allen Richtungen gleich stark.

\marginnote{Einfluss von einzelnen Lichtquellen}

Die Abbildung 2 zeigt dieselbe Szene. In dieser Szene wurde zusÃ¤tzlich
ein Lichtobjekt der Szene hinzugefÃ¼gt. Die Objekte werden durch die
Hintergrundwelt immer noch aus allen Winkeln mit dem gleichen Ausmass
beleuchtet. Anhand des Lichtobjekts werden die Objekte nun allerdings
zusÃ¤tzlich durch dieses Objekt beleuchtet, wodurch sich beispielsweise
auf der Spielfigur eine zusÃ¤tzliche Reflexion ergibt. Ausserdem ist nun
etwas deutlicher zu erkennen, dass das Spielfeld am Rand eine kleine
Einkerbung hat. Diese war im vorangehenden Beispiel nicht ersichtlich,
da sich durch die identische Beleuchtung aus allen Winkeln keine
Schatten innerhalb der Kerbe bilden konnten.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_33/33_2_NoShadow_Image.png}

\caption{\label{fig-1_2}Eine Spielfigur auf einem Spielfeld. Nebst der
Beleuchtung durch die Hintergrundwelt werden die Objekte auch durch ein
Lichtobjekt beleuchtet.}

\end{figure}%

\marginnote{Szene mit Schatten}

Die Abbildung 3 zeigt erneut dieselbe Szene wie in Abbildung 1 und
Abbildung 2. In den vorherigen Szenen wurde in den
Material-Einstellungen der Figur der Schatten fÃ¼r das entsprechende
Material deaktiviert. Deshalb wurde kein Schatten dargestellt. Nun mit
dem Schatten der Figur werden zusÃ¤tzliche Informationen zu den
VerhÃ¤ltnissen im dreidimensionalen Raum dargestellt. Durch den Abstand
des Schattens zur Figur wird klar, dass die Figur sich nicht direkt auf
dem Spielfeld befindet und stattdessen darÃ¼ber schwebt. TatsÃ¤chlich
befindet sich die Spielfigur Ã¼ber dem Spielfeld I2 und schwebt darÃ¼ber.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_33/33_3_Image_WithLight_and_Shadow.png}

\caption{\label{fig-1_3}Dieselbe Szene erneut dargestellt. Im Material
der Spielfigur wurde nun ein Schatten hinzugefÃ¼gt. Dadurch wird
erkennbar, dass sich die Spielfigur gar nicht auf dem Feld J1 befindet,
sondern Ã¼ber dem Feld I2 schwebt.}

\end{figure}%

\marginnote{Einfluss von Schatten}

Anhand dieses simplen Beispiels wird bereits deutlich, dass Schatten
auch verwendet werden, um Objekte im dreidimensionalen Raum zu
verordnen. Damit es Schatten aber Ã¼berhaupt geben kann, wird eine
Lichtquelle benÃ¶tigt.

\marginnote{Material als Lichtquelle}

Eine weitere Option fÃ¼r eine Lichtquelle kÃ¶nnte in diesem Beispiel die
Figur respektive deren Material darstellen. Die Abbildung 4 zeigt eine
gelbe Spielfigur, welche sich tatsÃ¤chlich auf dem Spielfeld J1 befindet.
SÃ¤mtliche Lichtquellen, also das Lichtobjekt und die Hintergrundwelt,
wurden ausgeschaltet. Bei beiden Beispielen innerhalb der Abbildung 4
wurden beim Material der Spielfigur der Â«\emph{Emission}Â»-Wert im
Principled-BSDF-Shader auf 25 und die Farbe auf gelb (RGB 1-1-0)
gestellt. Dadurch sendet die Spielfigur nun Licht aus. Beide Beispiele
in der Abbildung 4 zeigen diese Grundeinstellung, allerdings wurde fÃ¼r
die linke Abbildung Eevee und fÃ¼r die rechte Abbildung Cycles verwendet.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_33/33_4_Cycles_Eevee_Emission_Comparison.png}

\caption{\label{fig-1_4}Zweimal eine Szene, deren einzige Lichtquelle
aus dem Material einer Spielfigur besteht. Links ein Beispiel mit Eevee
als Render-Engine, rechts ein Beispiel mit Cycles als Render-Engine.}

\end{figure}%

\marginnote{Limitation der Emission von Materialien}

Cycles verarbeitet die Informationen akkurater und viel weitlÃ¤ufiger,
wodurch sich eine bessere Beleuchtung der Szene durch das Material
ergibt. Anhand dieses Beispiels wird allerdings bereits ersichtlich,
dass das Material nur begrenzt als Lichtquelle verwendet werden kann.
Nichtsdestotrotz kann die Emission manchmal auch sinnvoll sein, wenn
etwa ein Material ohne Lichtquelle oder unabhÃ¤ngig von der Lichtquelle
dargestellt werden soll.

\chapter{Lichtobjekte}\label{lichtobjekte}

\section{Lichtquellen einstellen}\label{lichtquellen-einstellen}

\marginnote{Lichtobjekte hinzufÃ¼gen}

Lichtobjekte werden wie auch Meshes im Â«\emph{Add}Â»-MenÃ¼ hinzugefÃ¼gt.
Unter Â«\emph{Light}Â» sind die jeweiligen Lichtquellen zu finden. Es gibt
vier verschiedene Arten von Lichtquellen, welche jeweils
unterschiedliche Eigenschaften mit sich bringen. Nach dem HinzufÃ¼gen
einer Art von Lichtobjekten kann die Art des Lichtobjektes jederzeit
wieder geÃ¤ndert werden. Die verschiedenen Arten von Lichtobjekten sind:

\begin{itemize}
\tightlist
\item
  Point
\item
  Sun
\item
  Spot
\item
  Area
\end{itemize}

\marginnote{Object-Data-Properties fÃ¼r Licht}

Wird ein Lichtobjekt hinzugefÃ¼gt und ausgewÃ¤hlt, wird das Icon des
Reiters Â«\emph{Object Data Properties}Â» im Properties-Editor mit dem
Icon einer GlÃ¼hbirne ausgewechselt. Dadurch wird visualisiert, dass das
ausgewÃ¤hlte Objekt nun kein Mesh mehr darstellt, sondern ein
Lichtobjekt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_34/34_1_Icon_Object_Data.png}

\caption{\label{fig-1_1}Icon des Â«\emph{Object Data Properties}Â»-Reiters
im Properties-Editor, wenn ein Lichtobjekt ausgewÃ¤hlt wurde.}

\end{figure}%

\marginnote{Unterschiedliche Einstellungen in Eevee und Cycles}

Innerhalb des Reiters Â«\emph{Object Data Properties}Â» kÃ¶nnen nun
genauere Einstellungen fÃ¼r das Licht-Objekt vorgenommen werden. Die
nachfolgende Beschreibung der Lichtobjekte orientiert sich an den
Einstellungsoptionen in Eevee. Einige dieser Einstellungsoptionen stehen
in Cycles nicht zur VerfÃ¼gung. In Cycles ist es dafÃ¼r mÃ¶glich, die
Lichtobjekte mittels des Shader-Editors genauer zu bearbeiten. HierfÃ¼r
muss allerdings jeweils die Einstellung Â«\emph{Use Nodes}Â» in den
Â«\emph{Object Data Properties}Â» ausgewÃ¤hlt werden.

\marginnote{Wechsel zwischen den Lichtobjekt-Arten}

Unter dem Reiter Â«\emph{Light}Â» kann die Art, wie das Objekt Licht
ausstrahlt, bearbeitet werden. Darin befindet sich zuoberst eine
Auflistung der vier Arten von Lichtobjekten. Durch die Auswahl einer
anderen Art kann so jederzeit unkompliziert zwischen den Lichtarten
gewechselt werden. Einige der Einstellungsoptionen variieren zwischen
den verschiedenen Objektarten.

\marginnote{StÃ¤rke des Lichts}

WÃ¤hrend in der Farbbox Â«\emph{Color}Â» eine Farbe fÃ¼r das Licht
ausgewÃ¤hlt werden kann, kann im Feld Â«\emph{Power}Â» die StÃ¤rke des
ausgestrahlten Lichts eingestellt werden. Je hÃ¶her dieser Wert ist,
desto stÃ¤rker wird die Szene durch das Lichtobjekt beleuchtet. Die
StÃ¤rke des Lichts wird in Watt angegeben. Dabei handelt es sich
allerdings nicht um dieselben Watt-Angaben, wie sie beispielsweise auf
GlÃ¼hbirnen angegeben werden. Eine LED-Birne mit 60 Watt (oder etwa 800
Lumen) wÃ¼rde mittels der Power von etwa 2.1 W angegeben werden. Um die
jeweiligen Werte, welche in Blender verwendet werden sollten, zu
erzielen, mÃ¼ssten komplexe Umrechnungen erfolgen. Im Handbuch zu Blender
sind allerdings einige Beispielwerte aufgelistet sowie die dazu
verwendeten Arten von Lichtobjekten (Quelle:
\url{https://docs.blender.org/manual/en/latest/render/lights/light_object.html}).

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Objekt & Power/Strength & Lichtobjekt-Art \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Kerze & 0.05 W & Point \\
LED-Birne (800 lm) & 2.1 W & Point \\
GlÃ¼hbirne (1000 lm) & 2.9 W & Point \\
Scheinwerfer (1500 lm) & 4 W & Area (Form: Disk) \\
LeuchtstoffrÃ¶hre (2500 lm) & 4.5 W & Area (Form: Rectangle) \\
Autoscheinwerfer (5000 lm) & 22 W & Spot (GrÃ¶sse: 125Â°) \\
Klarer Himmel & 1000 W/m\textsuperscript{2} & Sun \\
BewÃ¶lkter Himmel & 500 W/m\textsuperscript{2} & Sun \\
Wolkenbedeckter Himmel & 200 W/m\textsuperscript{2} & Sun \\
Mondlicht & 0.001 W/m\textsuperscript{2} & Sun \\
\end{longtable}

\marginnote{Faktoren, um die Lichtquelle zu prÃ¤zisieren}

Um das Licht etwas genauer bearbeiten zu kÃ¶nnen, stehen drei zusÃ¤tzliche
Faktorwerte zur VerfÃ¼gung:

\begin{itemize}
\tightlist
\item
  Â«\textbf{\emph{Diffuse}}Â»: Der Faktor Â«\emph{Diffuse}Â» beschreibt, ob
  das Licht der Lichtquelle stark gebÃ¼ndelt ausgesendet wird oder
  stÃ¤rker streut. Je hÃ¶her der Diffuse-Wert ist, desto breiter wird das
  Licht gestreut. Bei einem tieferen Diffuse-Wert wird das Licht stÃ¤rker
  gebÃ¼ndelt.
\item
  Â«\textbf{\emph{Specular}}Â»: Der Faktor Â«\emph{Specular}Â» beschreibt,
  wie stark das Licht der Lichtquelle die FÃ¤higkeit zur Specularity
  aufweist. Wenn dieser Faktor auf 0 gesetzt wird, kÃ¶nnen keine
  Lichtstrahlen basierend auf dieser Lichtquelle reflektiert werden.
\item
  Â«\textbf{\emph{Volume}}Â»: Mittels des Faktors Â«\emph{Volume}Â» kann ein
  Wert festgelegt werden, mit dem Lichtstrahlen in Volumen multipliziert
  werden. Da dieser Kurs allerdings nicht auf Volumen eingeht, kann
  dieser Faktor ignoriert werden.
\end{itemize}

\marginnote{Je kleiner die Lichtquelle, desto heller}

Anhand des Feldes Â«\emph{Radius}Â» respektive Â«\emph{Size}Â» kann
definiert werden, wie gross das Lichtobjekt ist. Je kleiner der Radius
ist, desto stÃ¤rker erhellt die Lichtquelle die unmittelbare Umgebung.
Durch eine VergrÃ¶sserung des Radius wird der Bereich, von dem aus die
Punkt-Beleuchtung, ausgedehnt. Da die LichtstÃ¤rke allerdings gleich
bleibt -- nÃ¤mlich entsprechend dem Wert der Â«\emph{Power}Â» -- wird diese
StÃ¤rke nun Ã¼ber einen grÃ¶sseren Bereich ausgestrahlt. Dies hat zur
Folge, dass die umliegenden Objekte weniger hell beleuchtet werden.

\marginnote{Custom Distance}

Mittels der Option Â«\emph{Custom Distance}Â» kann definiert werden, dass
die Lichtstrahlen des Lichtobjektes lediglich bis zu einer gewissen
Distanz reichen. Alle Bereiche, welche weiter als diese definierte
Distanz von der Lichtquelle entfernt liegen, werden nicht davon
beleuchtet. Per Default ist diese Option allerdings ausgeschaltet.

\marginnote{Schatten}

Im Reiter Â«\emph{Shadow}Â» sind weitere Einstellungen zu Schatten, welche
diese Lichtquelle erzeugt, zu finden. So kann der gesamte Reiter
deaktiviert werden, wenn diese Lichtquelle keine Schatten erzeugen soll.
Zudem kann mittels Â«\emph{Clip Start}Â» eine Distanz definiert werden, ab
welcher Objekte ausgehend von der Lichtquelle einen Schatten werfen
kÃ¶nnen.

\section{Point}\label{point}

\marginnote{Navigation zwischen Szenen}

In der Datei Â«\emph{Gameboard\_Lights}Â» sind verschiedene Beispielszenen
fÃ¼r unterschiedliche Belichtungen aufzufinden. Die verschiedenen
Beispiele sind in unterschiedliche Szenen aufgeteilt. Um zwischen den
Szenen wechseln zu kÃ¶nnen, muss im Dropdown-MenÃ¼ Â«\emph{Browse Scene to
be linked}Â», welches in der Ecke oben rechts zu finden ist, die
entsprechende Szene ausgewÃ¤hlt werden. Auch die Beispiele aus dem
vorangehenden Kapitel sind in dieser Datei aufzufinden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_34/34_2_Pointlight.png}

\caption{\label{fig-1_2}Eine Szene, welche mit einer Point-Lichtquelle
beleuchtet wird.}

\end{figure}%

\marginnote{Beispiel eines Point-Lichtobjektes}

Â«\emph{Example6\_Light\_Point}Â» beinhaltet das Beispiel aus der
Abbildung 2. In diesem Beispiel befindet sich ein Lichtobjekt des Typs
Â«\emph{Point}Â» oberhalb des Spielfelds J1. Die Lichtobjekte als solche
werden beim Rendern nicht dargestellt, sondern lediglich die Reflexionen
des Lichtes. Aus diesem Grund wurde die Position des Point-Lichtobjektes
in der Abbildung 2 mit einer Sphere visualisiert.

\marginnote{Points kÃ¶nnen bewegt werden, aber ihre Rotation hat keine Auswirkung}

Anhand eines Point-Lichtobjektes werden ausgehend von der Position des
Lichtobjektes die Lichtstrahlen kreisfÃ¶rmig ausgestrahlt.
Dementsprechend fÃ¼hrt eine Rotation des Objektes zu keiner VerÃ¤nderung
der Lichtausstrahlung. Lediglich aufgrund der Position des Lichtobjektes
des Typs Â«\emph{Point}Â» kann eine VerÃ¤nderung der Beleuchtung erfolgen.

\section{Sun}\label{sun}

\marginnote{Beispiel eines Sun-Lichtobjektes}

Die Abbildung 3 zeigt ein Beispiel, in dem eine Szene mit einem
Sun-Lichtobjekt beleuchtet wird. Die Sonne ist dabei auf derselben HÃ¶he
wie die KÃ¶pfe der anderen Spielfiguren auf dem Feld J1 platziert und
gegen die blaue Spielfigur rotiert.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_34/34_3_Sunlight.png}

\caption{\label{fig-1_3}Eine Szene, welche mit einer Sun-Lichtquelle
beleuchtet wird.}

\end{figure}%

\marginnote{Sonnen kÃ¶nnen rotiert werden, allerdings hat ihre Position keine Auswirkung}

Ein Lichtobjekt des Typs Â«\emph{Sun}Â» wird jeweils Ã¼ber die gesamte
Szene erstreckt und beleuchtet die Objekte allesamt entsprechend der
Rotation der Sonne. In ihren Grundeinstellungen mit einer Rotation von
0-0-0 werden alle Objekte senkrecht entlang der Z-Achse beleuchtet.
Durch eine VerÃ¤nderung der Rotationswerte kann der Winkel, mit dem die
Sonne auf die Objekte eintrifft, variiert werden. Zu beachten ist dabei,
dass die Position der Sonne keinen Einfluss auf die Beleuchtung hat.
Mithilfe der Sonne wird eine Beleuchtung erschaffen, welche im gleichen
Winkel Ã¼ber die ganze Szene erstreckt wird.

\marginnote{Andere Masseinheit fÃ¼r die StÃ¤rke der Lichtstrahlen}

Da die Distanz von Sonnen-Objekten keinen Einfluss auf die Wirkung der
Sonne hat, wird die Masseinheit fÃ¼r die Sonnenausstrahlung mit
Â«\emph{Strength}Â» ausgegeben und anhand von Watt pro Quadratmeter
definiert. Zudem werden fÃ¼r Sonnen sehr hohe Werte verwendet (200-1000
W/m\textsuperscript{2}).

\marginnote{Helligkeitsadaption erstellen}

Die hohen Werte fÃ¼r die Sonnenausstrahlung fÃ¼hren dazu, dass die Objekte
deutlich Ã¼berbelichtet werden. Im Gegensatz zum menschlichen Auge
verfÃ¼gen der Computer und die Render-Engine Ã¼ber keine MÃ¶glichkeiten, um
an die Helligkeit der Sonne zu adaptieren. Cycles verfÃ¼gt Ã¼ber die
MÃ¶glichkeit, dass in den Render-Einstellungen im Properties-Editor unter
Â«\emph{Film}Â» der Exposure-Wert reduziert werden kann. In Eevee steht
diese Option nicht zur VerfÃ¼gung, allerdings kann zumindest fÃ¼r die
gerenderten Farben der Exposure-Wert unter dem Reiter Â«\emph{Color
Management}Â» angepasst werden. Alternativ kann auch ein geringerer Wert
fÃ¼r die Sonne verwendet und auf die realitÃ¤tsgetreuen Werte verzichtet
werden.

\section{Spot}\label{spot}

\marginnote{Spot als Beleuchtungsoption}

In Abbildung 4 wird eine Szene mittels eines Spot-Lichtobjektes
beleuchtet. Der Spot agiert wie ein Scheinwerfer, mit dem gezielt ein
Objekt beleuchtet werden kann. HierfÃ¼r sind sowohl die Position als auch
die Rotation des Spot-Lichtobjektes bedeutsam. Anhand dieser beiden
Merkmale kann der Spot entsprechend auf ein Objekt ausgerichtet werden.
Die Beleuchtung erfolgt anschliessend ausgehend von der Form eines
Cones, der von der Position des Lichtobjektes ausgeht.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_34/34_4_Spotlight.png}

\caption{\label{fig-1_4}Eine Szene, welche mit einer Spot-Lichtquelle
beleuchtet wird.}

\end{figure}%

\marginnote{GrÃ¶sse des Spots einstellen}

In den Einstellungen zum Lichtobjekt findet sich unter dem Reiter
Â«\emph{Spot}Â» zusÃ¤tzlich ein Reiter Â«\emph{Spot Shape}Â». Innerhalb
dieses Reiters kÃ¶nnen weitere Verfeinerungen an der Art der Beleuchtung
vorgenommen werden. Mittels der Option Â«\emph{Size}Â» kann definiert
werden, wie gross der Bereich ist, welcher der Spot erfassen kann.
Dieser Bereich kann von 0Â° bis 180Â° variieren. Bei einer GrÃ¶sse von 180Â°
wird der gesamte Bereich, welcher sich vor dem Spot befindet,
beleuchtet. Je kleiner die GrÃ¶sse ist, desto mehr fokussiert sich die
Beleuchtung auf einen entsprechenden Bereich.

\marginnote{Blend-Einstellung}

Mittels des Feldes Â«\emph{Blend}Â» kann der Ãœbergang vom Bereich, welcher
durch den Spot beleuchtet wird, zu dem Bereich, welcher nicht beleuchtet
wird, beschrieben werden. Je hÃ¶her dieser Wert ist, desto weicher wird
der Ãœbergang von beleuchteten zu nicht beleuchteten Arealen. Bei einem
tiefen Wert erscheint dieser Ãœbergang als klare Linie. Zudem kann
mittels der Option Â«\emph{Show Cone}Â» das Licht auch innerhalb des
Volumens der Spotbeleuchtung dargestellt werden.

\section{Area}\label{area}

\marginnote{Areale als Beleuchtungsobjekt}

Die Abbildung 5 zeigt eine Szene, welche mit einem Area-Lichtobjekt
beleuchtet wird. Diese Art der Beleuchtung hÃ¤ngt wie auch der Spot von
der Position und der Rotation des Lichtobjektes ab. Mithilfe des
Area-Lichtobjektes kann ein Bereich erstellt werden, welcher Licht
aussendet. Dabei kann ein viereckiges Areal definiert werden, indem im
Dropdown-MenÃ¼ Â«\emph{Shape}Â» die Option Â«\emph{Square}Â» fÃ¼r ein Quadrat
oder die Option Â«\emph{Rectangle}Â» fÃ¼r ein Rechteck ausgewÃ¤hlt wird.
Mittels der Optionen Â«\emph{Disk}Â» fÃ¼r einen Kreis und Â«\emph{Ellipse}Â»
fÃ¼r eine Ellipse kÃ¶nnen auch runde Areale gewÃ¤hlt werden.

\marginnote{GrÃ¶sse der Areale variieren}

Mittels des Reiters Â«\emph{Size}Â» kann die GrÃ¶sse des Areals definiert
werden. Bei aktivierten Viewport-Overlays kann diese VerÃ¤nderung direkt
visuell nachverfolgt werden. Das Quadrat und der Kreis als Option
verfÃ¼gen leidglich Ã¼ber einen Reiter fÃ¼r die GrÃ¶sse. Bei den Formen
Rechteck und Ellipse kÃ¶nnen zwei Achsen fÃ¼r die GrÃ¶sse unabhÃ¤ngig
voneinander definiert werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_34/34_5_Arealight.png}

\caption{\label{fig-1_5}Eine Szene, welche mit einer Area-Lichtquelle
beleuchtet wird.}

\end{figure}%

Ãœbung 16: Lichtobjekte

\textbf{Ãœbung 16.1}

Ã–ffnen Sie in der Datei Â«\emph{Gameboard\_Lights}Â» die Szene
Â«\emph{Exercise\_Lights}Â» und versuchen Sie, die abgebildete
Beleuchtungssituation nachzustellen.

\includegraphics{Chapters/Images/Chapter_34/Exercise_16_1.png}\hfill

Die LÃ¶sung finden Sie in der Szene Â«Exercise\_Lights\_SolutionÂ»

\chapter{Welten}\label{welten}

\marginnote{Verwendung von Licht beim Rendern}

Mithilfe der Lichtobjekte ist es nun mÃ¶glich, die Szenen in Blender mit
Licht auszustatten. Damit der Einfluss dieser Lichtobjekte sichtbar ist,
muss allerdings der Rendered-Viewport-Shading-Modus im
3D-Viewport-Editor ausgewÃ¤hlt werden. Im
Material-Preview-Viewport-Shading-Modus werden diese Lichtobjekte per
Default nicht mit angezeigt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_35/35_1_Dunes_Standardworld.png}

\caption{\label{fig-1_1}Eine gerenderte Szene.}

\end{figure}%

\marginnote{Der gerenderte Hintergrund}

Die Abbildung 1, welche auch in der Datei Â«\emph{Dune}Â» zu finden ist,
zeigt eine gerenderte Szene, so wie sie auch im
Rendered-Viewport-Shading-Modus dargestellt wird. Das Objekt zeigt eine
DÃ¼ne mit einer Sandtextur, welche von einer Sonne beleuchtet wird.
Dahinter verbirgt sich ein leerer, grauer Hintergrund. Dabei handelt es
sich um den Standardhintergrund, der in einer Szene per Default
eingestellt ist. Dieser Hintergrund bildet die sogenannte Welt der Szene
ab.

\marginnote{Die Unendlichkeit der Welt}

Die Welt stellt im Grunde genommen eine unendlich grosse Kugel dar,
welche um die Szene gespannt wird. Das Ende dieser Welt kann somit nie
erreicht werden. Man kÃ¶nnte sich dies auch als eine UV-Sphere
vorstellen, welche so stark vergrÃ¶ssert wird, dass sie die gesamte Szene
in sich beheimatet. Im Unterschied zur Welt, wÃ¤re die UV-Sphere
allerdings endlich, da sie einen klar definierten Durchmesser innehat,
welcher die Szene umfasst. Die Welt hingegen, stellt ein unendliches
Konstrukt dar.

\marginnote{World-Properties}

FÃ¼r die Einstellung der Welt findet sich im Properties-Editor unter dem
Reiter Â«\emph{World Properties}Â» die MÃ¶glichkeit, Eigenschaften der Welt
zu definieren. Allerdings kann diese Einstellung der Welt auch im
Shader-Editor vorgenommen werden. Im Shader-Editor kÃ¶nnen nicht nur
Materialien, sondern auch die Welt und Linien bearbeitet werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_35/35_2_Icon_World_Properties.png}

\caption{\label{fig-1_2}Icon des Â«\emph{World Properties}Â»-Reiters im
Properties-Editor.}

\end{figure}%

\marginnote{Weltbearbeitung im Shader-Editor Ã¶ffnen}

In der linken oberen Ecke des Shader-Editors, direkt neben dem
Dropdown-MenÃ¼ zur Auswahl des Editors, findet sich ein weiteres
Dropdown-MenÃ¼, welches standardmÃ¤ssig auf Â«\emph{Object}Â» eingestellt
ist. Unter dieser Auswahl werden jeweils die Materialien des Objekts
dargestellt und bearbeitet. Wird im entsprechenden Dropdown-MenÃ¼
allerdings Â«\emph{World}Â» ausgewÃ¤hlt, werden die Einstellungen der Welt
dargestellt und kÃ¶nnen bearbeitet werden.

\marginnote{Background-Node}

StandardmÃ¤ssig wird fÃ¼r die Welt der Â«\emph{Background}Â»-Shader
verwendet. Dieser verfÃ¼gt lediglich Ã¼ber die Einstellungen
Â«\emph{Color}Â» und Â«\emph{Strength}Â». Bei der Farbe handelt es sich um
die Hintergrundfarbe, welche in der gerenderten Ansicht dargestellt
wird. Diese Farbe sendet zudem auch Lichtstrahlen aus. Das Ausmass, in
dem Licht ausgestrahlt werden soll, kann mit der Einstellung
Â«\emph{Strength}Â» definiert werden. Indem diese beiden Parameter
variiert werden, kÃ¶nnen bereits unterschiedliche
Hintergrundbeleuchtungen erzielt werden.

\section{HDRIs hinzufÃ¼gen}\label{hdris-hinzufuxfcgen}

\marginnote{HDRI}

Welten kÃ¶nnen, so wie auch bei Materialien, Texturen hinzugefÃ¼gt werden.
Dabei werden allerdings in der Regel besondere Arten von Texturen
verwendet, sogenannte HDRIs. HDRI steht fÃ¼r Â«High Dynamic Range ImageÂ»
und beschreibt Bilder, welche sehr hohe Helligkeitsunterschiede
innerhalb des Bildes aufweisen. Dies ist besonders zur Darstellung von
Welten geeignet.

\marginnote{HDRIs im Internet beziehen}

HDRIs kÃ¶nnen so wie auch Texturen im Internet bezogen werden. Teilweise
bieten die Datenbanken, welche Texturen anbieten, in einer gesonderten
Kategorie zusÃ¤tzlich HDRIs an. Etwa die Webseiten
\url{https://polyhaven.com/} und \url{https://ambientcg.com/} beinhalten
gesonderte Kategorien fÃ¼r HDRIs. Oftmals werden verschiedene AuflÃ¶sungen
angeboten. Bei den HDRIs, welche fÃ¼r die Hintergrundwelt verwendet
werden, empfiehlt es sich, eine etwas grÃ¶ssere AuflÃ¶sung zu verwenden,
da die entsprechenden Bilder anschliessend Ã¼ber die gesamte Welt gezogen
werden.

\marginnote{HDRI in Blender einfÃ¼gen}

Die HDRIs kÃ¶nnen nun im Shader-Editor als Textur hinzugefÃ¼gt werden.
HierfÃ¼r kann der Background-Shader-Node ausgewÃ¤hlt werden und die
Tastenkombination \kbd{Ctrl} + \kbd{T} gedrÃ¼ckt werden. Dadurch werden
automatisch ein Texture-Node, ein Mapping-Node und ein
Texture-Coordinate-Node hinzugefÃ¼gt. Anders als bei den Materialien wird
allerdings kein Image-Texture-Node hinzugefÃ¼gt, sondern ein
Environment-Texture-Node. Dieser fungiert Ã¤hnlich wie der
Image-Texture-Node, ist allerdings darauf angepasst, dass er die runde
Welt Ã¼berspannt, statt ein Objekt. Im Â«\emph{Add}Â»-MenÃ¼ kann dieser Node
unter Â«\emph{Texture \textbar{} Environment Texture}Â» hinzugefÃ¼gt
werden. Innerhalb dieses Environment-Texture-Nodes kann anschliessend
das HDRI-Bild geÃ¶ffnet werden.

\marginnote{Welten rotieren und verschieben}

Abbildung 3 zeigt eine gerenderte Szene, deren Welt auf einem HDRI
basiert. HierfÃ¼r wurde das HDRI Â«\emph{Sky-Only HDRI 009}Â» von der
Website \url{https://ambientcg.com/} verwendet. Mittels des
Mapping-Nodes kann die Welt zusÃ¤tzlich angepasst werden. Durch eine
Rotation entlang der Z-Achse kann die Textur etwa innerhalb der Szene
gedreht werden, oder mittels einer VerÃ¤nderung der Position entlang der
Z-Achse kann der Horizont in der HÃ¶he etwas verschoben werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_35/35_3_Scene_With_HDRI_Image.png}

\caption{\label{fig-1_3}Eine gerenderte Szene mit einem HDRI-Bild als
Welt.}

\end{figure}%

\section{Einen prozeduralen Sternenhimmel
erstellen}\label{einen-prozeduralen-sternenhimmel-erstellen}

\marginnote{Prozedurale Welten erstellen}

Welten kÃ¶nnen, so wie bereits bei den Texturen betrachtet, auch
prozedural aufgebaut werden. So kann etwa ein Sternenhimmel erstellt
werden, ohne dass eine Bilddatei dafÃ¼r benÃ¶tigt wird. Abbildung 4 zeigt
ein Beispiel fÃ¼r eine gerenderte Szene, die im Hintergrund einen solchen
prozedural erstellen Sternenhimmel beinhaltet.

\marginnote{Noise-Textur hinzufÃ¼gen}

Um einen solchen Effekt zu erzielen, kann eine Noise-Textur verwendet
werden. Diese kann im Â«\emph{Add}Â»-MenÃ¼ des Shader-Editors unter
Â«\emph{Texture \textbar{} Noise Texture}Â» hinzugefÃ¼gt werden. Diese
Noise Textur kann anschliessend ausgewÃ¤hlt werden und mittels der
Tastenkombination \kbd{Ctrl} + \kbd{T} ein Mapping- und ein
Texture-Coordinate-Node hinzugefÃ¼gt werden. Die Noise-Textur erzeugt ein
zufÃ¤lliges schwarz-weisses Bild, bestehend aus Noise.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_35/35_4_Dunes_Starfield.png}

\caption{\label{fig-1_4}Eine gerenderte Szene mit einem prozedural
erstellten Sternenhimmel als Hintergrundwelt.}

\end{figure}%

\marginnote{Parameter des Noise-Texture-Nodes}

Der Noise-Texture-Node beinhaltet verschiedene MÃ¶glichkeiten, um
bearbeitet zu werden. Die entsprechenden Parameter sind:

\begin{itemize}
\tightlist
\item
  Â«\textbf{\emph{Scale}}Â»: Wie stark soll das resultierende Bild mit dem
  Noise skaliert werden? Je grÃ¶sser der Wert, desto grÃ¶sser wird das
  dargestellte Bild und desto detaillierter werden die dargestellten
  Inhalte. Gleichzeitig benÃ¶tigt ein hÃ¶herer Wert allerdings auch mehr
  Leistung.
\item
  Â«\textbf{\emph{Detail}}Â»: Mittels des Detail-Parameters kann definiert
  werden, dass der Noise detaillierter dargestellt wird. Auch dies geht
  zulasten der Computerleistung.
\item
  Â«\textbf{\emph{Roughness}}Â»: Mittels der Roughness-Einstellung kann
  definiert werden, wie sehr die ÃœbergÃ¤nge des Noises ineinander
  Ã¼berfliessen sollen. Je hÃ¶her der Roughness-Wert, desto weicher und
  fliessender werden die ÃœbergÃ¤nge.
\item
  Â«\textbf{\emph{Distortion}}Â»: Mittels des Distortion-Parameters kann
  der Noise zusÃ¤tzlich verzogen werden. Je hÃ¶her dieser Wert, desto mehr
  wird der Noise verzogen.
\end{itemize}

\marginnote{4D-Option, um mittels des W-Werts den Noise zu variieren}

ZusÃ¤tzlich verfÃ¼gt der Noise-Texture-Node Ã¼ber ein Dropdown-MenÃ¼, mit
dem eine DimensionalitÃ¤t der Noise-Textur ausgewÃ¤hlt werden kann. In der
Regel wird die Option Â«\emph{3D}Â» ausgewÃ¤hlt. Die Option Â«\emph{4D}Â» hat
allerdings den Vorteil, dass ein zusÃ¤tzliches Â«\emph{W}Â» im
Noise-Texture-Node hinzugefÃ¼gt wird. Mithilfe dieses Parameters kann
zwischen verschiedenen Abstufungen des Noises gewÃ¤hlt werden. Dadurch
kÃ¶nnen unkompliziert andere Ergebnisse in dem prozedural erstellten
Sternenhimmel erzielt werden, lediglich indem dieser Parameter variiert
wird.

FÃ¼r das Beispiel aus der Abbildung 4 wurde die DimensionalitÃ¤t
Â«\emph{4D}Â» verwendet und der Parameter Â«\emph{W}Â» auf 15.2 eingestellt.
Zudem wurde der Faktor Â«\emph{Scale}Â» auf den Wert 10 und die
Â«\emph{Roughness}Â» auf 1 erhÃ¶ht. Im Mapping-Node wurde die Skalierung
ebenfalls auf den Wert 15 entlang aller drei Achsen erhÃ¶ht.

\marginnote{Color-Ramp hinzufÃ¼gen}

Um den Noise der Noise-Textur nun in einen Sternenhimmel zu verwandeln,
wird eine Color-Ramp benÃ¶tigt. Diese ist im Â«\emph{Add}Â»-MenÃ¼ unter
Â«\emph{Converter \textbar{} ColorRamp}Â» zu finden. Der Fac-Output des
Noise-Texture-Nodes kann anschliessend mit dem Fac-Input des
Color-Ramp-Nodes verbunden werden.

\marginnote{Wieso wird der Fac-Output der Noise-Textur verwendet?}

Der Noise-Texture-Node kann sowohl farbigen Noise als auch
schwarz-weissen Noise erzeugen. Mittels des Color-Outputs kann die
farbige Version des Noises verwendet werden, mittels des Fac-Outputs
kann die schwarz-weisse Version des Noises verwendet werden. Die
schwarz-weisse Version des Noises hat den Vorteil, dass die
Schwarz-weiss-Abstufungen direkt als Faktor verwendet werden kÃ¶nnen. Die
Color-Ramp kann auch mit farbigen Inputs umgehen und diese umwandeln,
allerdings werden die Farben dann anders Ã¼ber die Color-Ramp
aufgespannt. Schlussendlich kÃ¶nnen allerdings beide Outputs verwendet
werden.

\marginnote{Viewer-Node zur Color-Ramp hinzufÃ¼gen}

Innerhalb der Color-Ramp kann anschliessend der Noise zum Sternenhimmel
umgewandelt werden. Um diese Prozesse zu verstehen, empfiehlt es sich,
bei gedrÃ¼ckter Tastenkombination \kbd{Ctrl} + \kbd{Shift} die Color-Ramp
auszuwÃ¤hlen, um den Viewer-Node zu Ã¶ffnen und mit der Color-Ramp zu
verbinden. Dadurch kann der Effekt der Color-Ramp im 3D-Viewport-Editor
betrachtet werden.

\marginnote{Schwarzanteil durch die Color-Ramp erhÃ¶hen}

Innerhalb der Color-Ramp werden nun die schwarz-weissen Abstufungen der
Noise-Textur entlang der Farbachse aufgespannt. Schwarze Farben befinden
sich am linken Ende der Farbachse und weisen den Faktor 0 auf, wÃ¤hrend
weisse Farben am rechten Ende der Farbachse zu finden sind und den
Faktor 1 aufweisen. Wenn nun der schwarze Farbmarker am linken Ende nach
rechts verschoben wird, beispielsweise auf die Position 0.732, werden
alle Schwarz-weiss-Abstufungen, welche fÃ¼r einen Wert unterhalb von
0.732 stehen, konstant schwarz gehalten. Die Werte rechts daneben,
welche zwischen dem schwarzen und dem weissen Farbmarken liegen, werden
graduell neu berechnet. Visuell hat dies die Folge, dass ein Grossteil
der Noise-Textur nun schwarz geworden ist.

\marginnote{Weissanteil durch die Color-Ramp erhÃ¶hen}

Damit nun vereinzelt weisse Punkte in der Noise-Textur erscheinen, muss
der zweite, weisse Farbmarker am rechten Ende etwas nach links
verschoben werden. Wird dieser beispielsweise auf die Position 0.795
gesetzt, werden alle Faktor-Werte der Noise-Textur, welche Ã¼ber 0.795
liegen, weiss eingefÃ¤rbt. Durch diese Einstellung sollte sich nun ein
schwarzer Himmel mit vereinzelten weissen Punkten ergeben. Dieser kann
nun als Sternenhimmel verwendet werden, indem der Color-Output der
Color-Ramp mit dem Color-Input des Background-Nodes verbunden wird.
Durch einen Klick auf den Background-Node bei gedrÃ¼ckter
Tastenkombination \kbd{Ctrl} + \kbd{Shift} wird der Viewer-Node zudem
wieder geschlossen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_35/35_5_Starfiel_Nodes.png}

\caption{\label{fig-1_5}Node-System, um einen prozeduralen Sternenhimmel
als Welt zu erstellen.}

\end{figure}%

\chapter{Kamera}\label{kamera}

\marginnote{Kameras}

Mit den bisher besprochenen Inhalten kÃ¶nnen komplexe Szenen erstellt und
in Blender betrachtet werden. Durch das finale Rendern der Szenen kÃ¶nnen
Bilder oder Filme erstellt werden, welche auch in anderen Programmen
betrachtet werden kÃ¶nnen. Die Erstellung dieser Bilder und Filme geht
von der Kamera aus, welche jeweils in einer Szene platziert wird und
auch in der Default-Szene vorzufinden ist.

\marginnote{Kamera-Objekttyp}

Falls eine neue Kamera innerhalb einer Szene benÃ¶tigt wird, kann diese
jederzeit im Â«\emph{Add}Â»-MenÃ¼ unter Â«\emph{Camera}Â» hinzugefÃ¼gt werden.
Die Kamera stellt eine eigene Objektart dar. Um die Einstellungen der
Kamera anzupassen, kann im Properties-Editor der Reiter Â«\emph{Object
Data Properties}Â» ausgewÃ¤hlt werden. FÃ¼r die Kameras wird ein anderes
Symbol als bei einem Mesh angezeigt, um zu verdeutlichen, dass es sich
um eine andere Objektart handelt. Um den Einfluss der
Kameraeinstellungen besser nachvollziehen zu kÃ¶nnen, empfiehlt es sich,
die Kamera als Ansicht im 3D-Viewport mit der Taste \kbd{0} auszuwÃ¤hlen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_36/36_1_Camera.png}

\caption{\label{fig-1_1}Icon fÃ¼r den Reiter Â«\emph{Object Data
Properties}Â» bei einer Kamera.}

\end{figure}%

\marginnote{Kameralinsen}

In den Object-Data-Properties kann im ersten Reiter Â«\emph{Lens}Â» die
Linse der Kamera angepasst werden. Je nach Art der Kameralinse werden
die Objekte innerhalb einer Szene unterschiedlich dargestellt. HierfÃ¼r
stehen drei verschiedene Ansichten zur VerfÃ¼gung:

\begin{itemize}
\tightlist
\item
  Â«PerspectiveÂ»
\item
  Â«OrthographicÂ»
\item
  Â«PanoramicÂ»
\end{itemize}

\marginnote{Perspektivische Kameralinse}

Die perspektivische Linse entspricht der perspektivischen Ansicht, die
im 3D-Viewport-Editor verwendet werden kann. Dabei werden
tiefenperspektivische Inhalte berÃ¼cksichtigt. Dies hat zur Folge, dass
Objekte zunehmend kleiner dargestellt werden, je weiter weg sie sich von
der Kamera befinden. Abbildung 2 zeigt den StandardwÃ¼rfel aus der
Kameraansicht mit einer perspektivischen Linse. Obwohl die Edges des
oberen Faces gleich lang sind, werden sie durch die perspektivische
Linse unterschiedlich lang dargestellt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_36/36_2_Default_Scene.png}

\caption{\label{fig-1_2}Die Default-Szene aus der Sicht der Kamera.}

\end{figure}%

\marginnote{Orthografische Kameralinse}

Die orthografische Linse entspricht der orthografischen Ansicht, die im
3D-Viewport-Editor verwendet werden kann. Tiefenperspektivische Inhalte
werden dabei nicht berÃ¼cksichtigt. Dies hat zur Folge, dass Objekte mit
derselben GrÃ¶sse gleich gross dargestellt werden, unabhÃ¤ngig von der
Distanz zur Kamera. Abbildung 3 zeigt den StandardwÃ¼rfel mit einer
orthografischen Kameralinse. Da die Tiefenperspektive nicht
berÃ¼cksichtigt wird, sind die Edges gleich lang dargestellt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_36/36_3_Default_Scene_Otho.png}

\caption{\label{fig-1_3}Die Default-Szene aus einer orthografischen
Kameraperspektive.}

\end{figure}%

\marginnote{Panoramische Kameralinse}

Mithilfe der panoramischen Kameralinse kÃ¶nnen Panoramabilder erstellt
werden. Diese Option ist lediglich in der Render-Engine Cycles
verfÃ¼gbar. Dabei wird ausgehend von der Kameraposition ein Panoramabild
erstellt. Mithilfe des Dropdown-MenÃ¼s Â«\emph{Panorama Type}Â» kÃ¶nnen
verschiedene Formen von Panoramabildern ausgewÃ¤hlt werden.

\marginnote{Sichtfeld der Kamera}

Mittels der Zeile Â«\emph{Focal Length}Â» kann mit der Kamera hinein- oder
hinausgezoomt werden. Dadurch wird das Blickfeld von der Kamera
vergrÃ¶ssert oder verkleinert. Durch einen hÃ¶heren Wert fÃ¼r die
Focal-Length wird hineingezoomt und mit einem tieferen Wert wird
hinausgezoomt. Alternativ kann die Â«\emph{Lens Unit}Â» von
Â«\emph{Millimeters}Â» auf Â«\emph{Field of View}Â» umgestellt werden.
Dadurch kann ein Winkel fÃ¼r die Breite des Sichtfelds angegeben werden.

\marginnote{Wie weit reicht die Kamera?}

Die Kamera erfasst nicht alle Inhalte, welche sich in ihrem Sichtfeld
befinden. Wenn Objekte zu nah oder zu weit von der Kamera entfernt sind,
werden diese von der Kamera nicht berÃ¼cksichtigt -- unabhÃ¤ngig davon,
wie gross und deutlich ersichtlich die Objekte eigentlich sind.
StandardmÃ¤ssig werden Objekte, welche nÃ¤her als 0.1 Meter vor der Kamera
liegen, und Objekte, die Ã¼ber 100 Meter von der Kamera entfernt sind,
nicht berÃ¼cksichtigt. Diese Werte kÃ¶nnen allerdings in den Zeilen
Â«\emph{Clip Start}Â» und Â«\emph{End}Â» verÃ¤ndert werden.

\marginnote{TiefenschÃ¤rfe definieren}

Innerhalb des Reiters Â«\emph{Depth of Field}Â» kann die TiefenschÃ¤rfe
bearbeitet werden, sofern diese Option aktiviert wurde. Dabei kann die
TiefenschÃ¤rfe entweder mittels Â«\emph{Focus Distance}Â» auf Objekte mit
einer bestimmten Distanz zur Kamera oder mit der Option Â«\emph{Focus on
Object}Â» direkt passend auf ein Objekt fokussiert werden.

\marginnote{Kamera auf die Ansicht ausrichten}

Um die Kamera im Raum auszurichten, kann ihre Position und ihre Rotation
wie bei anderen Objekten bearbeitet werden. Eine alternative
Bearbeitungsform besteht darin, die Kamera an die Ansicht im 3D-Viewport
anzupassen. HierfÃ¼r muss zunÃ¤chst die Kameraansicht mit der Taste
\kbd{0} ausgewÃ¤hlt werden. In der Sidebar kann unter dem Reiter
Â«\emph{View}Â» unter Â«\emph{View Lock}Â» die Option Â«\emph{Camera to
View}Â» aktiviert werden. Durch diese Einstellung wird die Kamera nun an
die eigene Ansicht gekoppelt. Bei einer VerÃ¤nderung der Ansicht wird
dementsprechend automatisch die Kamera verschoben und rotiert. Anhand
der roten Umrandung des Kamerafelds ist jeweils ersichtlich, dass die
Option Â«\emph{Camera to View}Â» aktiviert ist. Um die Ansicht verÃ¤ndern
zu kÃ¶nnen, ohne die Kamera zu verschieben, muss die Option Â«\emph{Camera
to View}Â» wieder deaktiviert werden.

\marginnote{Kamera auf aktuelle Ansicht umsetzen}

Die beste Ansicht fÃ¼r eine Kamera zu finden, ist manchmal schwierig.
Teilweise findet man wÃ¤hrend des Bearbeitungsprozesses plÃ¶tzlich eine
Ansicht, die besonders fÃ¼r die Kameraansicht geeignet wÃ¤re. In solchen
FÃ¤llen kann die Kamera direkt zur aktuellen Ansicht umgeÃ¤ndert werden,
indem die Tastenkombination \kbd{Ctrl} + \kbd{Alt} + \kbd{0} gedrÃ¼ckt
wird.

\marginnote{Aktive Kamera auswÃ¤hlen}

Sollten sich innerhalb einer Szene mehrere Kameras befinden, kann
lediglich eine davon als aktive Kamera verwendet werden, um Szenen zu
rendern. Im Properties-Editor innerhalb des Reiters Â«\emph{Scene
Properties}Â» kann jeweils nachverfolgt werden, welche Kamera die Szene
rendern wird. Innerhalb des Reiters Â«\emph{Scene}Â» wird in der Zeile
Â«\emph{Camera}Â» das entsprechende Kamera-Objekt aufgefÃ¼hrt, oder kann
bei Bedarf gewechselt werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_36/36_4_Scene_Properties.png}

\caption{\label{fig-1_4}Icon fÃ¼r den Reiter Â«\emph{Scene Properties}Â».}

\end{figure}%

\chapter{Rendern}\label{rendern}

\marginnote{Renderprozess starten}

Um ein Bild ausgehend von der Perspektive der Kamera in einer Szene zu
erhalten, muss dieses Bild gerendert werden. Diese Funktion ist in der
MenÃ¼leiste Â«\emph{Render \textbar{} Render Image}Â» aufzufinden, kann
allerdings auch mit der Taste \kbd{F12} gestartet werden. Dadurch Ã¶ffnet
sich ein neues Fenster mit dem Image-Editor. AbhÃ¤ngig von der
LeistungsstÃ¤rke des Computers kann es einen Moment dauern, bis das
gerenderte Bild im Image-Editor dargestellt wird.

\marginnote{Bild abspeichern}

Das gerenderte Bild kann in der MenÃ¼leiste unter Â«\emph{Image \textbar{}
Save}Â» abgespeichert werden. Dabei sind zusÃ¤tzlich verschiedene Optionen
einstellbar. Per Default wird das Bild als PNG-File abgespeichert.
Allerdings sind auch andere Bildformate mÃ¶glich, wie beispielsweise JPEG
oder TIFF.

\marginnote{Rendern abbrechen}

WÃ¤hrend des Renderprozesses kann die Taste \kbd{esc} gedrÃ¼ckt werden, um
den Renderprozess abzubrechen. Ebenfalls erscheint wÃ¤hrend des
Renderprozesses in der Fussleiste von Blender ein Fortschrittsbalken
inklusive einer SchaltflÃ¤che mit einem Kreuz. Durch einen Klick auf
dieses Kreuz kann der Renderprozess ebenfalls abgebrochen werden. Wenn
der Renderprozess allerdings abgebrochen wird, kann der Prozess nicht
spÃ¤ter an der Abbruchstelle fortgefÃ¼hrt werden. Es ist also nÃ¶tig, dass
der gesamte Renderprozess am StÃ¼ck absolviert wird.

\marginnote{Was passiert beim Rendern?}

Beim Rendern wird ein Bild erzeugt. Dabei wird fÃ¼r jedes Pixel des
Bildes ermittelt, wie dieses auszusehen hat. Dies geschieht anhand
mehrerer Samples, die miteinander abgeglichen werden. Die Anzahl der
Samples lÃ¤sst sich im Render-Properties-Reiter des Properties-Editors
unter Â«\emph{Sampling}Â» definieren. Die Anzahl der Samples hat einen
Einfluss auf die Dauer des Renderprozesses. Je mehr Samples benÃ¶tigt
werden, desto lÃ¤nger dauert das Rendern.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_37/37_1_Render_Properties.png}

\caption{\label{fig-1_1}Icon fÃ¼r den Reiter Â«\emph{Render Properties}Â».}

\end{figure}%

\marginnote{Dauer des Renderprozesses}

Die ausgewÃ¤hlten Render-Engines unterscheiden sich deutlich in der Zeit,
welche sie fÃ¼r das Rendern benÃ¶tigen. Eevee erzielt jeweils schnellere
Render-Ergebnisse, wÃ¤hrend Cycles in der Regel deutlich lÃ¤nger braucht.
Dies liegt daran, dass Cycles das zu erstellende Bild in kleine
Unterareale aufteilt -- sogenannte Tiles -- und diese einzeln
nacheinander rendert. Dies fÃ¼hrt auch dazu, dass Eevee jeweils das ganze
Bild auf einmal erstellt, wÃ¤hrend man bei Cycles die Erstellung jedes
einzelnen Tiles auf dem Bildschirm nachverfolgen kann. Cycles gibt
wÃ¤hrend des Renderprozesses in der oberen linken Ecke des Image-Editors
an, wie lange der Renderprozess bereits benÃ¶tigte, und schÃ¤tzt die noch
benÃ¶tigte Dauer des Renderprozesses.

\marginnote{AuflÃ¶sung verÃ¤ndern}

Die GrÃ¶sse und die AuflÃ¶sung des Bildformats basieren auf den
Render-Einstellungen, welche wiederum auch das Format der aktiven Kamera
beeinflussen. Im Properties-Editor kann im Reiter Â«\emph{Output
Properties}Â» definiert werden, wie der Output erzeugt wird. Unter dem
Reiter Â«\emph{Dimensions}Â» kann die AuflÃ¶sung des Bildformats anhand der
X- und der Y-Achse der Kamera definiert werden. Je hÃ¶her diese AuflÃ¶sung
ist, desto mehr Pixel werden verwendet, um das Bild zu erzeugen. Dies
fÃ¼hrt allerdings auch zu einem grÃ¶sseren Dateiformat des gerenderten
Bildes und zu einer lÃ¤ngeren Dauer des Renderprozesses.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_37/37_2_Output_Properties.png}

\caption{\label{fig-1_2}Icon fÃ¼r den Reiter Â«\emph{Output Properties}Â».}

\end{figure}%

\marginnote{Bildformat verÃ¤ndern}

Durch eine VerÃ¤nderung der Pixelwerte lediglich anhand einer Achse der
Dimensionen wird das Bildformat der Kamera verÃ¤ndert. Wenn etwa ein
quadratisches Bild entstehen soll, mÃ¼ssten die Werte der AuflÃ¶sung fÃ¼r
die X- und die Y-Achse identisch sein. Um die VerÃ¤nderung der
BildschirmauflÃ¶sung nachvollziehen zu kÃ¶nnen, empfiehlt es sich, jeweils
die Kameraansicht im 3D-Viewport-Editor mit der Taste \kbd{0} zu
aktivieren.

\marginnote{Bezeichnungen fÃ¼r verschiedene BildschirmauflÃ¶sungen}

Per Default betrÃ¤gt die AuflÃ¶sung 1920 x 1080 Pixel. Eine solche
AuflÃ¶sung wird als Â«High DefinitionÂ» (HD) bezeichnet. Durch eine
Verdopplung der Anzahl Pixel auf 3840 x 2160 Pixel wird eine
Ultra-HD-AuflÃ¶sung erzielt. Teilweise wird diese AuflÃ¶sung als Â«4KÂ»
bezeichnet. Die AuflÃ¶sung 4K wird allerdings in einem anderen Bildformat
erzielt. Die BildauflÃ¶sung HD und Ultra-HD verwenden ein Bildformat von
16:9. Das heisst, die AuflÃ¶sung 3840 x 2160 ist ein Vielfaches von 16 x
9. Die AuflÃ¶sung 4K basiert hingegen auf dem Bildformat 17:9 und
entspricht 4096 x 2160. Dadurch beinhaltet 4K in der Breite Ã¼ber 4000
Pixel.

\marginnote{Bezeichnung der AuflÃ¶sung anhand der vertikalen Anzahl Pixel}

Nebst den bisher erwÃ¤hnten Bezeichnungen wird die AuflÃ¶sung von Bildern
teilweise auch anhand der vertikalen Anzahl Pixel angegeben.
Beispielsweise kann auf YouTube die BildschirmauflÃ¶sung von Videos
anhand dieser Bezeichnung eingestellt werden. Diese Angabe wird jeweils
mit dem KÃ¼rzel Â«pÂ» angegeben. Eine Ultra-HD-AuflÃ¶sung mit 3840 x 2160
Pixeln wÃ¼rde dementsprechend als 2160 p bezeichnet. Ebenso wird die
4K-AuflÃ¶sung mit 4096 x 2160 Pixeln mit 2160 p bezeichnet.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
AuflÃ¶sung
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Format
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Anzahl Pixel
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Vertikale Anzahl Pixel
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Standard-Definition (SD)} & 16:9 & 720 x 576 & 576 p \\
\textbf{HD-Ready/Half-HD} & 16:9 & 1280 x 720 & 720 p \\
\textbf{High Definition (HD)} & 16:9 & 1920 x 1080 & 1080 p \\
\textbf{Ultra-HD} & 16:9 & 3840 x 2160 & 2160 p \\
\textbf{Ultra-HD-2} & 16:9 & 7680 x 4320 & 4320 p \\
\textbf{Digital Cinema Initiatives (DCI) 4K} & 17:9 & 4096 x 2160 & 2160
p \\
\textbf{Digital Cinema Initiatives (DCI) 8K} & 17:9 & 8192 x 4320 & 4320
p \\
\end{longtable}

\marginnote{Transparenter Hintergrund}

Es ist auch mÃ¶glich, ein transparentes Bild zu Rendern. Dabei handelt es
sich um eine Render-Einstellung, welche im Properties-Editor im Reiter
Â«\emph{Render Properties}Â» vorgenommen werden muss. Im Reiter
Â«\emph{Film}Â» kann das KontrollkÃ¤stchen fÃ¼r Â«\emph{Transparent}Â»
aktiviert werden. In der gerenderten Ansicht wird die Hintergrund-Welt
anschliessend mit einem schachbrettartigen Muster Ã¼berzogen, um die
Transparenz zu signalisieren. Dieses Muster wird nach dem Rendern
ebenfalls im Image-Editor angezeigt, um darauf hinzuweisen, dass der
Hintergrund transparent ist.

\marginnote{Transparente Bilder speichern}

Beim Abspeichern von transparenten Bildern sollte darauf geachtet
werden, dass ein Dateiformat verwendet wird, welches Transparenz
unterstÃ¼tzt. JPEG unterstÃ¼tzt beispielsweise keine Transparenz, wÃ¤hrend
PNG Transparenz unterstÃ¼tzt. Zudem sollte auch darauf geachtet werden,
dass die korrekte Farbeinstellung beim Abspeichern von transparenten
Bildern verwendet wird. In der Regel werden die Farbeinstellungen
Â«\emph{BW}Â» (schwarz-weiss), Â«\emph{RGB}Â» (Farben, ohne Transparenz) und
Â«\emph{RGBA}Â» (Farben, mit Transparenz) angeboten. FÃ¼r transparente
Bilder mÃ¼sste die Option Â«\emph{RGBA}Â» verwendet werden.

\section{Renderprozess in Cycles
beschleunigen}\label{renderprozess-in-cycles-beschleunigen}

Quelle:
\url{https://www.blenderguru.com/articles/4-easy-ways-to-speed-up-cycles}

\marginnote{Renderprozess beschleunigen}

Beim Rendern in Cycles kann es ratsam sein, gewisse Vorkehrungen zu
treffen, um den Renderprozess zu beschleunigen. HierfÃ¼r gibt es einige
Tricks, um dies zu erzielen:

\begin{itemize}
\tightlist
\item
  GPU statt CPU fÃ¼rs Rendern verwenden.
\item
  Die AuflÃ¶sung des Bildes reduzieren.
\item
  Sampling reduzieren.
\item
  Tile-GrÃ¶sse reduzieren.
\item
  Anzahl berechneter Lichtreflexionen reduzieren.
\end{itemize}

\marginnote{Tile-GrÃ¶sse variieren}

Die Anzahl Pixel, welche in einem Tile erzeugt werden, kann in den
Render-Properties unter Â«\emph{Performance \textbar{} Tiles}Â» definiert
werden. Bei der Verwendung der CPU ist eine geringere GrÃ¶sse der Tiles
mit kÃ¼rzeren Renderzeiten verbunden. Diese Faustregel kann allerdings
nicht bei der GPU angewendet werden. Zudem sollten die Anzahl Tiles eine
Potenzierung von 2 darstellen (beispielsweise 26 = 64 Pixel pro Tiles).

\marginnote{Anzahl Light-Bounces reduzieren}

Der realistische Effekt von Cycles basiert darauf, dass auch
Lichtreflexionen, welche sich durch die Reflexion anderer Objekte
ergeben, fÃ¼rs Rendern berÃ¼cksichtigt werden. Dies fÃ¼hrt dazu, dass das
Rendern lÃ¤ngere Zeit in Anspruch nimmt. In den Render-Properties kann
unter Â«\emph{Light Paths \textbar{} Max Bounces}Â» definiert werden, wie
oft das Licht von OberflÃ¤chen abprallen kann. Je hÃ¶her dieser Wert ist,
desto mehr Berechnungen mÃ¼ssen beim Rendern durchgefÃ¼hrt werden. Hierbei
kÃ¶nnen die Anzahl berÃ¼cksichtigter Lichtreflexionen auch fÃ¼r
verschiedene Einstellungen (Â«\emph{Glossy}Â», Â«\emph{Transparency}Â»,
Â«\emph{Volume}Â», usw.) einzeln definiert werden.

\chapter{Tutorial: Ein Glas mit Wasser
erstellen}\label{tutorial-ein-glas-mit-wasser-erstellen}

\marginnote{Ziel dieses Tutorials}

Im Rahmen dieses Tutorials wird ein vorgefertigtes Glas mit Wasser,
Kondenswasser und KohlensÃ¤ureblÃ¤schen ergÃ¤nzt. Damit wird auch die
Funktionsweise von Partikeln und Haaren erlÃ¤utert. Als Vorlage kann die
Datei Â«\emph{Glas\_Particles}Â» verwendet werden. Diese Vorlage
beinhaltet ein Glas innerhalb einer Szene, welches mit Materialien
ausgestattet ist.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_38/38_1_Water_Final.png}

\caption{\label{fig-1_1}Das Ziel dieses Tutorials: Ein Glas mit Wasser,
Kondenswasser am Glas und KohlensÃ¤ureblÃ¤schen.}

\end{figure}%

\section{Wasser hinzufÃ¼gen}\label{wasser-hinzufuxfcgen}

\marginnote{Duplikat des Glases erstellen}

Im ersten Schritt geht es darum, das Glas mit Wasser zu ergÃ¤nzen.
HierfÃ¼r wird ein Mesh benÃ¶tigt, welches dieselbe Form wie das Innere des
Glases hat. HierfÃ¼r kann das bereits vorhandene Glas mit der
Tastenkombination \kbd{Shift} + \kbd{D} dupliziert und an derselben
Stelle platziert werden. Auf diesem Duplikat sollte anschliessend der
Subdivision-Surface-Modifier im Modifier-Properties-Reiter des
Properties-Editors angewendet werden.

\marginnote{Nicht benÃ¶tigte Vertices aus Duplikat entfernen}

Das Duplikat kann anschliessend im Edit-Mode bearbeitet werden. Als
Erstes wird die erste Reihe Vertices auf der Innenseite des Glases,
welche sich oberhalb der gewÃ¼nschten WasserhÃ¶he befindet, bei gedrÃ¼ckter
\kbd{Alt}-Taste mit einem Mausklick ausgewÃ¤hlt. Diese Reihe wird danach
mit der Taste \kbd{X} und dem Befehl Â«\emph{Delete \textbar{} Vertices}Â»
gelÃ¶scht. Nun kann der Mauszeiger Ã¼ber den Ã¤usseren Bereich des Glases
bewegt werden und die Taste \kbd{L} gedrÃ¼ckt werden. Dadurch werden alle
verbundenen Vertices ausgewÃ¤hlt, sodass der gesamte Teil des Glases,
welcher nicht fÃ¼r das Wasser verwendet wird, mit der Taste \kbd{X}
gelÃ¶scht werden kann.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_38/38_2_Water_Select_Linked.png}

\caption{\label{fig-1_2}Die Kopie des Glases, aus der eine Reihe von
Vertices im Inneren entfernt wurde. Der Ã¤ussere Rand kann nun mittels
Â«\emph{Select Linked}Â» einfach ausgewÃ¤hlt werden.}

\end{figure}%

\marginnote{OberflÃ¤che des Wassers nach innen extrudieren}

Das Wasser beinhaltet noch keine OberflÃ¤che. Aus diesem Grund wird die
oberste Reihe der Vertices ausgewÃ¤hlt und der ausgewÃ¤hlte Kreis mittels
der Taste \kbd{E} extrudiert und mittels der Taste \kbd{S} verkleinert.
Dieser Schritt wird mehrmals wiederholt, bis nur noch ein kleines Loch
Ã¼brigbleibt. Dieses Loch kann anschliessend mit der Taste \kbd{F}
gefÃ¼llt werden.

\marginnote{Normalen umkehren}

Das nun resultierende Mesh hat bereits die Form des Wassers, welches
erstellt werden soll. Allerdings sind die Normalen des Wassers in die
falsche Richtung ausgerichtet. Die Seite, welche zuvor im Glas nach
aussen gerichtet war, ist nun beim Wasser nach innen ausgerichtet.
Deshalb sollten alle Vertices ausgewÃ¤hlt werden, mittels der
Tastenkombination \kbd{Alt} + \kbd{N} das Â«\emph{Normals}Â»-MenÃ¼ geÃ¶ffnet
werden und die Option Â«\emph{Flip}Â» ausgewÃ¤hlt werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_38/38_3_Water_Top_Fill.png}

\caption{\label{fig-1_3}Die Form des Wasser-Objekts.}

\end{figure}%

\marginnote{Auto-Smooth der Normalen}

An der Kante der WasseroberflÃ¤che ist nun eine Scharfe Kante zwischen
den horizontalen und den vertikalen Faces entstanden. Dies fÃ¼hrt dazu,
dass das geglÃ¤ttete Shading des Objekts verzerrt wird. Um dies zu
eliminieren, kann Blender damit beauftragt werden, die dazugehÃ¶rigen
Normalen ebenfalls zu glÃ¤tten. Diese Option findet sich im
Objekt-Data-Properties-Reiter des Properties-Editors unter dem Abschnitt
Â«\emph{Normals}Â». Dort kann die Option Â«\emph{Auto Smooth}Â» aktiviert
werden. Dadurch werden die Normalen von nebeneinanderliegenden Faces
geglÃ¤ttet, wenn der Winkel zwischen diesen Faces grÃ¶sser als ein
vordefinierter Winkel ist. Dieser vordefinierte Winkel lÃ¤sst sich im
Feld neben der Option Â«\emph{Auto Smooth}Â» definieren.

\marginnote{Neues Material}

Das Wasser-Objekt beinhaltet noch die Materialien des Glases. Aus diesem
Grund wird im Material-Reiter des Properties-Editors eine Kopie des
Materials erstellt, welches anschliessend umbenannt werden kann
(beispielsweise in Â«\emph{Wasser}Â»). Das Wasser kann in seinen
Einstellungen praktisch identisch zum Glas belassen werden. Lediglich
der Wert fÃ¼r die IOR sollte auf 1.33 gesetzt werden.

\section{Lichtbrechung zwischen mehreren
Materialien}\label{lichtbrechung-zwischen-mehreren-materialien}

Quelle:
\url{https://www.aversis.be/tutorials/vray/vray-20-glass-liquid-01.htm}

\marginnote{Wasser innerhalb des Glases verschieben}

Das erstellte Wasser stellt eine exakte Kopie der InnenflÃ¤che des Glases
dar und beinhaltet den korrekten IOR fÃ¼r Wasser. Ebenso beinhaltet das
Glas den korrekten IOR von Glas. Da sich allerdings sowohl das Glas als
auch das Wasser an einer bestimmten Stelle berÃ¼hren, resultiert ein
komplexerer, inakkurater IOR-Wert.

\marginnote{IOR zwischen zwei Materialien}

Der IOR beschreibt die Brechung des Lichtes, wenn es auf ein bestimmtes
Material trifft oder dieses Material durchdringt. Genauer gesagt
beschreibt der IOR die Brechung des Lichts an der Ãœbergangsstelle
zwischen zwei Materialien. Was ist das zweite Material? Bei diesem
Material handelt es sich um Luft. Jede Lichtbrechung durch Materialien
stellt also nicht eine Brechung durch das Material, sondern eine
Brechung durch den Ãœbergang vom Material zur Luft dar. HierfÃ¼r wird der
Luft per Definition ein IOR von 1 zugewiesen.

\marginnote{Anpassung der Lichtbrechung zwischen zwei Materialien}

Wenn sich nun zwei Materialien berÃ¼hren, ohne dass sich Luft dazwischen
befindet, so mÃ¼ssten die jeweiligen IORs miteinander dividiert werden.
Da diese Werte allerdings anschliessend inakkurat sind, mÃ¼ssten die
Normalen dieser Faces umgekehrt werden, um damit die IOR anzupassen.
Dies hat allerdings einen negativen Effekt auf das Shading, weshalb
diese Faces in separate Objekte aufgeteilt werden mÃ¼ssten. Ein komplexer
Prozess.

\marginnote{BehelfslÃ¶sung: Wasser in das Glas hineinverschieben}

Eine Alternative zu diesem Prozess besteht darin, das Wasser so
anzupassen, dass es sich ein wenig im Inneren des Glases befindet.
HierfÃ¼r kÃ¶nnen alle Vertices im Wasser-Objekt ausgewÃ¤hlt und mittels der
Taste \kbd{S} vergrÃ¶ssert werden, sodass sich das Wasser etwas innerhalb
des Glases befindet. Lediglich die Vertices am Rand der WasseroberflÃ¤che
sollten dabei an derselben Position wie das Glas bleiben.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_38/38_4_Water_Top_Move_Down.png}

\caption{\label{fig-1_4}Die Vertices an der WasseroberflÃ¤che werden
etwas nach unten verschoben, sodass die Vertices am Rand eine gewisse
Wasserspannung simulieren.}

\end{figure}%

\marginnote{Wasser anpassen}

ZusÃ¤tzlich sollte allerdings auch eine gewisse OberflÃ¤chenspannung
erzeugt werden, sodass sich der Rand der WasseroberflÃ¤che ein wenig
oberhalb der WasseroberflÃ¤che befindet. Da der Rand der WasseroberflÃ¤che
allerdings genau der Position des Glases entspricht, ist es sinnvoller,
den Rest der WasseroberflÃ¤che tiefer zu setzen. HierfÃ¼r wird die gesamte
OberflÃ¤che des Wassers ausgewÃ¤hlt und der Rand der WasseroberflÃ¤che
abgewÃ¤hlt. Anschliessend kÃ¶nnen die inneren Vertices der
WasseroberflÃ¤che etwas tiefer gesetzt werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_38/38_5_Surface_Vertrices.png}

\caption{\label{fig-1_5}Die Vertices unterhalb der WasseroberflÃ¤che
werden ausgewÃ¤hlt und vergrÃ¶ssert, damit sie sich etwas innerhalb des
Glases befinden.}

\end{figure}%

\section{Kondenswasser am Glas
hinzufÃ¼gen}\label{kondenswasser-am-glas-hinzufuxfcgen}

\subsection{Vorbereitung}\label{vorbereitung-1}

\marginnote{Kondenswasser mit Wassertropfen erzeugen}

Der nÃ¤chste Schritt besteht darin, dass der Ã¤ussere Rand des Glases mit
Kondenswasser ergÃ¤nzt wird. HierfÃ¼r wird zunÃ¤chst ein Wassertropfen
erzeugt, welcher anschliessend Ã¼ber das Mesh verteilt wird. Dieser
Wassertropfen wird sehr klein und sehr hÃ¤ufig dargestellt. Damit dies
nicht zu viel Leistung benÃ¶tigt, sollte der Wassertropfen mÃ¶glichst
wenig Vertices beinhalten. Idealerweise wird hierfÃ¼r ein WÃ¼rfel als Mesh
verwendet und in seiner Form verÃ¤ndert, ohne weitere Vertices
hinzuzufÃ¼gen.

\marginnote{Tropfen des Kondenswassers erstellen}

Durch die Tastenkombination \kbd{Shift} + \kbd{A} kann das
Â«\emph{Add}Â»-MenÃ¼ geÃ¶ffnet werden und unter Â«\emph{Mesh \textbar{}
Cube}Â» ein WÃ¼rfel hinzugefÃ¼gt werden. Dabei ist allerdings wichtig, dass
der WÃ¼rfel anschliessend im Edit-Mode so verschoben wird, dass sich der
Ursprung des WÃ¼rfels am Rand des WÃ¼rfels befindet. Aus diesem Grund muss
der gesamte WÃ¼rfel im Edit-Mode um den Faktor 1 entlang der Z-Achse
verschoben werden (mittels den Tasten \kbd{G}, \kbd{Z} und \kbd{1}).

Anschliessend kann das obere Face des WÃ¼rfels um den Faktor 0.5 skaliert
werden (mittels den Tasten \kbd{S} , \kbd{Shift} + \kbd{Z} und danach
\kbd{0} \kbd{.} \kbd{5} ) und um einen Meter entlang der Z-Achse nach
unten verschoben werden (mittels den Tasten \kbd{G}, \kbd{Z} und \kbd{-}
\kbd{1}). Dadurch sollte eine Form wie in Abbildung 6 entstehen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_38/38_6_Drop.png}

\caption{\label{fig-1_6}Die Form eines sehr simplen Wassertropfens.}

\end{figure}%

\marginnote{Material des Wassertropfens}

Der Wassertropfen wird wie auch das Wasserobjekt aus einem
Wasser-Material bestehen. Damit die Wassertropfen allerdings etwas
stÃ¤rker auffallen, kann ihr Anteil von reflektiertem Licht erhÃ¶ht
werden. HierfÃ¼r wird eine Kopie des Wasser-Materials erstellt und dem
Wassertropfen zugewiesen. Innerhalb dieses kopierten Materials kann
anschliessend der Metallic-Wert etwas erhÃ¶ht werden (beispielsweise auf
0.3).

\marginnote{Einzelne Collection fÃ¼r den Wassertropfen wird erstellt und deaktiviert}

Dieser Wassertropfen sollte nun versteckt werden. Da der Wassertropfen
auch im finalen Render nicht dargestellt werden sollte, empfiehlt es
sich, im Outliner eine neue Collection hinzuzufÃ¼gen und den
Wassertropfen in diese Collection zu verschieben. Diese Collection kann
wahlweise innerhalb oder ausserhalb der bereits bestehenden Collection
platziert werden. Anschliessend sollte der Wassertropfen noch sinnvoll
benannt werden (beispielsweise Â«\emph{Wassertropfen}Â»). Die Collection,
welche den Wassertropfen nun beinhaltet, kann nun deaktiviert werden,
indem deren dazugehÃ¶riges KontrollkÃ¤stchen deaktiviert wird.

Als NÃ¤chstes muss definiert werden, an welchen Stellen des Glases das
Kondenswasser auftreten soll. HierfÃ¼r werden im Mesh des Glases alle
Faces ausgewÃ¤hlt, welche die Wassertropfen aufweisen sollen. HierfÃ¼r
kann die gesamte Ã¤ussere FlÃ¤che des Glases ausgewÃ¤hlt werden.
Anschliessend wird im Object-Data Properties-Reiter des Meshes eine neue
Vertex-Gruppe hinzugefÃ¼gt und mit einem Namen versehen (beispielsweise
Â«Kondenswasser-BereichÂ»). Durch einen Klick auf die Taste
Â«\emph{Assign}Â» werden anschliessend die ausgewÃ¤hlten Vertices -- und
somit auch die damit verbundenen Faces -- der neuen Vertex-Gruppe
zugewiesen. Dadurch sind alle Vorbereitungen abgeschlossen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_38/38_7_Condense_Select_Group.png}

\caption{\label{fig-1_7}Vertices, welche spÃ¤ter das Kondenswasser
abbilden und zu einer Vertex-Gruppe zusammegefasst werden.}

\end{figure}%

\subsection{Haare}\label{haare}

\marginnote{Particle-Properties}

Nun wird das Glas mit Haaren versehen. Wieso ein haariges Glas erstellt
wird, sollte im Verlaufe des Kapitels klar werden. HierfÃ¼r wird das
Glas-Objekt ausgewÃ¤hlt und im Properties-Editor der Reiter
Â«\emph{Particle Properties}Â» geÃ¶ffnet. Innerhalb dieses Reiters finden
sich die Partikel- und Haar-Systeme, welche auf das aktuell ausgewÃ¤hlte
Objekt angewendet werden. Zuoberst in diesem Reiter befindet sich ein
Feld, in dem mehrere Slots fÃ¼r Partikel- oder Haarsysteme hinzugefÃ¼gt
werden kÃ¶nnen, indem die SchaltflÃ¤che Â«+Â» fÃ¼r das HinzufÃ¼gen und die
SchaltflÃ¤che Â«-Â» fÃ¼r das Entfernen gedrÃ¼ckt wird. Wenn solche Systeme
vorhanden sind, wird jeweils die Einstellung fÃ¼r das jeweilige
Partikelsystem darunter angezeigt. Die Partikel-Einstellungen und die
Partikelsysteme lassen sich dabei individuell benennen.

\marginnote{Haare hinzufÃ¼gen}

ZunÃ¤chst werden dem Glas ein paar Haare hinzugefÃ¼gt. HierfÃ¼r sollte die
Option Â«\emph{Hair}Â» unterhalb des Namens der Partikel-Einstellungen
ausgewÃ¤hlt werden. Im 3D-Viewport werden anschliessend dem Glas Haare
hinzugefÃ¼gt. Diese Haare werden jeweils vom Mesh aus in der Richtung der
Normalen erstreckt.

\marginnote{Haar-Einstellungen}

Innerhalb des Â«\emph{Emission}Â»-Reiters kÃ¶nnen genauere Einstellungen zu
den Haaren vorgenommen werden. So lÃ¤sst sich unter Â«\emph{Number}Â» die
Anzahl der Haare definieren und unter Â«\emph{Hair Length}Â» die LÃ¤nge der
Haare. Da doch etwas mehr Haare benÃ¶tigt werden, kann die Anzahl Haare
unter Â«\emph{Number}Â» auf 5000 gesetzt werden. Da die Haare deutlich zu
lang sind, kann die Â«\emph{Hair Length}Â» auf 0.01 reduziert werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_38/38_8_Condense_Hair_All.png}

\caption{\label{fig-1_8}Das Glas mit Haaren.}

\end{figure}%

\marginnote{Haarquelle}

Die Quelle der Haare kann zusÃ¤tzlich im Reiter Â«\emph{Emission
\textbar{} Source}Â» bearbeitet werden. Dort kann definiert werden, ob
die Haare an den Positionen der Vertices, der Faces oder aus dem Volumen
des Objekts erzeugt werden sollen. Diese Einstellung kann unter
Â«\emph{Emit From}Â» vorgenommen werden. ZusÃ¤tzlich kann definiert werden,
wie die Haare Ã¼ber das Objekt verteilt werden sollen. HierfÃ¼r kann im
Dropdown-MenÃ¼ Â«\emph{Distribution}Â» entweder Â«\emph{Jittered}Â», wenn ein
bestimmter Abstandswert zwischen den einzelnen Haaren verwendet werden
soll, oder Â«\emph{Random}Â» fÃ¼r eine zufÃ¤llige Platzierung ausgewÃ¤hlt
werden. Mittels des KontrollkÃ¤stchens Â«\emph{Random Order}Â» werden die
einzelnen Haare in einer zufÃ¤lligen Reihenfolge auf dem Objekt erstellt.
ZusÃ¤tzlich kann mit der Option Â«\emph{Even Distribution}Â» eingestellt
werden, ob alle Faces gleichmÃ¤ssig viele Haare aufweisen oder nicht.

\marginnote{Einstellungen der Haarquelle fÃ¼r das Glas}

FÃ¼r dieses Beispiel sollten die Einstellungen Â«\emph{Emit From
\textbar{} Faces}Â» und Â«\emph{Distribution \textbar{} Random}Â»
ausgewÃ¤hlt werden. ZusÃ¤tzlich kann die Auswahl Â«\emph{Even
Distribution}Â» deaktiviert werden. So werden die Faces des Glases
verwendet, um Haare zu erzeugen. Diese Haare werden anschliessend
zufÃ¤llig Ã¼ber das Mesh hinweg erzeugt und dabei nicht gleichmÃ¤ssig auf
die einzelnen Faces verteilt.

\marginnote{Wassertropfen als Haare}

NatÃ¼rlich besteht das Ziel dieses Tutorials nicht darin, dass ein
haariges Glas erstellt wird. Anstelle der Haare sollen jeweils die
WassertrÃ¶pfchen des Kondenswassers erstellt werden. Im Reiter
Â«\emph{Render}Â» lÃ¤sst sich definieren, was die einzelnen Haare
darstellen sollen. In diesem Fall sollen die Haare jeweils das
Wassertropfen-Objekt darstellen. Deshalb wird die Einstellung
Â«\emph{Render As}Â» von Â«\emph{Path}Â» auf Â«\emph{Object}Â» umgestellt.
Dadurch kann nun im Reiter Â«\emph{Render \textbar{} Object}Â» unter
Â«\emph{Instance Object}Â» das Objekt, welches als Haar erzeugt werden
soll, ausgewÃ¤hlt werden. Hier wird deshalb nun das Wassertropfen-Objekt
ausgewÃ¤hlt.

\marginnote{GrÃ¶sse der Wassertropfen anpassen}

Anstelle der einzelnen HÃ¤rchen werden nun die Wassertropfen als Objekt
erstellt. Da diese noch klein dargestellt werden, kann ihre GrÃ¶sse unter
Â«\emph{Render \textbar{} Scale}Â» etwas vergrÃ¶ssert werden, etwa auf den
Wert 0.2. ZusÃ¤tzlich kann die GrÃ¶sse unter Â«\emph{Scale Randomness}Â»
zufÃ¤llig variiert werden. Wird dieser Wert auf 1 gesetzt, erfolgt eine
maximale zufÃ¤llige Variation der GrÃ¶sse. Dadurch werden die
Wassertropfen nun etwas grÃ¶sser, aber unterschiedlich gross dargestellt.

\marginnote{Haare auf Vertex-Gruppe beschrÃ¤nken}

Die Wassertropfen werden allerdings Ã¼ber das gesamte Mesh erzeugt.
TatsÃ¤chlich werden diese Wassertropfen allerdings lediglich an den Faces
benÃ¶tigt, welche vorhin einer Vertex-Gruppe zugewiesen wurden. Deshalb
wird im Reiter Â«\emph{Vertex Groups}Â» unter Â«\emph{Density}Â» die vorher
definierte Vertex-Gruppe ausgewÃ¤hlt. Dadurch wird definiert, dass die
Haare lediglich an den Stellen dieser Vertex-Gruppe dargestellt werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_38/38_9_Condense_Hair_Object.png}

\caption{\label{fig-1_9}Das Glas, dessen Haare nun aus Wassertropfen
bestehen.}

\end{figure}%

\marginnote{Wassertropfen rotieren}

Bei einer genauen Betrachtung fÃ¤llt nun auf, dass die Wassertropfen im
falschen Winkel dargestellt werden. Dies liegt daran, dass Objekte im
Partikelsystem jeweils um 90Â° gedreht werden. Um dies zu beheben, muss
der Wassertropfen nochmals bearbeitet werden. HierfÃ¼r muss die
Collection des Wassertropfens nochmals aktiviert werden, damit der
Wassertropfen wieder angezeigt wird und bearbeitet werden kann.
Idealerweise stellt man den 3D-Cursor mittels des Snap-Tools
(\kbd{Shift} + \kbd{S}) auf den Ursprung des Wassertropfens. HierfÃ¼r
muss der Wassertropfen im Object-Mode ausgewÃ¤hlt werden und im Snap-Tool
Â«\emph{Cursor to Selected}Â» ausgewÃ¤hlt werden. Nun kann der Pivot-Point
auf den 3D-Cursor gesetzt werden und der Wassertropfen im Edit-Mode um
-90Â° entlang der X-Achse rotiert werden (\kbd{R}, \kbd{X} und \kbd{9}
\kbd{0}). Anschliessend kann die Collection des Wassertropfens wieder
deaktiviert werden.

\section{Partikel}\label{partikel}

\marginnote{Vertex-Gruppe im Wasserobjekt definieren}

Das jetzt erstellte Glas beinhaltet Wasser ohne KohlensÃ¤ure. Im nÃ¤chsten
Schritt werden dem Wasser KohlensÃ¤ureblÃ¤schen hinzugefÃ¼gt. HierfÃ¼r wird
erneut das Wassertropfen-Objekt verwendet. Nun werden die Wassertropfen
allerdings vom Boden des Wassers aus aufsteigen. HierfÃ¼r wird eine
Vertex-Gruppe im Wasser-Objekt erstellt. Im Edit-Mode werden deshalb
alle Vertices, welche am Boden des Wassers zu finden sind, ausgewÃ¤hlt
und einer neuen Vertex-Gruppe fÃ¼r das Wasser-Objekt hinzugefÃ¼gt.

\marginnote{Emitter-Einstellungen}

Nun kann dem Wasser-Objekt im Particle-Properties-Reiter des
Properties-Editors ein neues Partikelsystem hinzugefÃ¼gt werden. Dieses
Partikelsystem wird allerdings nicht aus Haaren bestehen, sondern aus
Partikeln. Deshalb wird die Option Â«\emph{Emitter}Â» anstelle der Option
Â«\emph{Hair}Â» verwendet. Auch hier werden die Einstellungen Â«\emph{Emit
From \textbar{} Faces}Â», Â«\emph{Distribution \textbar{} Random}Â» und
keine Â«\emph{Even Distribution}Â» im Reiter Â«\emph{Emission \textbar{}
Source}Â» verwendet. Unter Â«\emph{Vertex Groups}Â» wird fÃ¼r die
Â«\emph{Density}Â» die neu definierte Vertex-Gruppe ausgewÃ¤hlt.

\marginnote{WasserblÃ¤schen erstellen}

Nun kann das Wassertropfen-Objekt fÃ¼r das Erzeugen der
KohlensÃ¤ureblÃ¤schen verwendet werden. HierfÃ¼r muss in der Option
Â«\emph{Render As}Â» die Einstellung Â«\emph{Object}Â» ausgewÃ¤hlt werden und
anschliessend der Wassertropfen als Â«\emph{Instance Object}Â» definiert
werden. Die GrÃ¶sse des Objekts sollte reduziert werden, indem der Wert
Â«\emph{Scale}Â» beispielsweise auf 0.0025 und der Wert Â«\emph{Scale
Randomness}Â» auf 1 erhÃ¶ht wird.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_38/38_10_Bubbles_Select_Group.png}

\caption{\label{fig-1_10}Die Vertices am unteren Bereich des
Wasser-Objekts werden zu einer Vertex-Gruppe zusammengefasst.}

\end{figure}%

\marginnote{Emitter fungieren als Animationen}

Trotz all dieser Einstellungen sind die Effekte des Partikelsystems wohl
nicht klar ersichtlich. Dies liegt daran, dass Partikelsysteme vom Typ
Â«\emph{Emitter}Â» anders funktionieren als Haare. Bei diesem Typ werden
nacheinander Partikel erzeugt, welche sich physikalisch wÃ¤hrend einer
Animation durch den Raum bewegen. Dementsprechend muss die Animation
gestartet werden, damit der Effekt des Partikelsystems sichtbar wird.

\marginnote{Timeline-Editor}

Zum Starten der Animation kann die \kbd{Space}-Taste verwendet werden.
Je nach Grundeinstellungen in Blender ist dieser Taste mÃ¶glicherweise
eine andere Funktion zugewiesen. In diesen FÃ¤llen kann die
Tastenkombination \kbd{Shift} + \kbd{Space} verwendet werden. Alternativ
kann der Timeline-Editor geÃ¶ffnet werden und darin auf den
Â«\emph{Play}Â»-Button gedrÃ¼ckt werden, um die Animation zu starten. Der
Timeline-Editor ermÃ¶glicht zudem eine Ãœbersicht der Animation.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_38/38_11_Timeline_Icon.png}

\caption{\label{fig-1_11}Icon fÃ¼r den Timeline-Editor.}

\end{figure}%

\marginnote{Frames}

Per Default dauert eine Animation 250 Frames, wobei auch eine hÃ¶here
oder geringere Animationsdauer definiert werden kann. Frames bezeichnen
einzelne Bilder, welche im Rahmen einer Animation erstellt werden. Durch
die Aneinanderreihung der einzelnen Frames entsteht anschliessend eine
Animation. Im Timeline-Editor werden diese Frames anhand eines
Zeitstrahls aufgelistet. Durch das Starten der Animation bewegt sich ein
blauer Marker entlang dieses Zeitstrahls, wÃ¤hrend parallel im
3D-Viewport die Szene wÃ¤hrend dieser Frames dargestellt wird.

\marginnote{Partikelsystem als Animation}

Die Grundeinstellungen zum Partikelsystem des Typs Â«\emph{Emitter}Â»
hÃ¤ngen von diesen Frames ab. So wird das ganze Partikelsystem Ã¼ber eine
gewisse Dauer erzeugt, welche sich aus dem Startpunkt der Animation und
dem Endpunkt der Animation ergibt. Im Reiter Â«\emph{Emission}Â» kann
unter Â«\emph{Frame Start}Â» definiert werden, beim wievielten Frame das
Partikelsystem starten soll, und unter Â«\emph{End}Â», beim wievielten
Frame dieses Partikelsystem enden soll. Die Anzahl Partikel, welche
unter Â«\emph{Number}Â» definiert sind, werden anschliessend gleichmÃ¤ssig
Ã¼ber die ganze Animationsdauer aufgeteilt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_38/38_12_Bubles_Emit.png}

\caption{\label{fig-1_12}Das Wasser-Objekt schÃ¼ttet Wassertropfen aus.}

\end{figure}%

\marginnote{Tote Partikel}

Sobald ein einzelner Partikel erzeugt wird, bestreitet er einen
physikalischen Weg -- beispielsweise indem er entlang der Z-Achse fÃ¤llt.
Diese Animation ist allerdings nicht unendlich. Jeder einzelne Partikel
lebt nur fÃ¼r eine gewisse Zeit lang und verschwindet anschliessend.
Unter der Zeile Â«\emph{Lifetime}Â» kann definiert werden, fÃ¼r wie viele
Frames ein Partikel existieren soll. Wenn die Lifetime auf 50 gestellt
ist, existiert ein Partikel fÃ¼r 50 Frames. Das heisst allerdings nicht,
dass nach 50 Frames keine Partikel mehr vorhanden sind, da laufend neue
Partikel erstellt werden. Es heisst aber auch, dass nach dem Frame, ab
dem der letzte Partikel erzeugt wurde, dieser Partikel noch entsprechend
seiner Lebensdauer durch die Szene wandert.

\marginnote{GravitationskrÃ¤fte und wie sie verÃ¤ndert werden kÃ¶nnen}

In diesem Beispiel wurden am Boden des Glases Partikel erzeugt. Diese
Partikel fallen entlang der Z-Achse durch den physikalischen Raum. Dies
basiert auf simulierten GravitationskrÃ¤ften. Im Reiter Â«\emph{Field
Weights}Â» lÃ¤sst sich der Einfluss dieser Gravitationskraft, aber auch
anderer KrÃ¤fte, einstellen. So kann der Wert Â«\emph{Gravity}Â»
beispielsweise auf -1 gesetzt werden, um die GravitationskrÃ¤fte fÃ¼r
dieses Partikelsystem umzukehren. Dadurch steigen die Partikel entlang
der Z-Achse hinauf, da die GravitationskrÃ¤fte umgekehrt wurden.

\marginnote{AusschÃ¼tten der Partikel erfolgt entgegen der neuen Schwerkraft}

Obwohl die GravitationskrÃ¤fte umgekehrt wurden, scheinen die einzelnen
Partikel zunÃ¤chst zu fallen, bevor sie entlang der Z-Achse aufsteigen.
Dies liegt daran, dass die Partikel zunÃ¤chst aus dem Mesh ausgeschÃ¼ttet
werden. Dies geschieht entlang der Normalen des Meshes. Die Partikel
werden also entlang der Normalen ausgeschÃ¼ttet und erhalten dadurch
einen physikalischen Antrieb, bevor sie schliesslich der manuell
erstellten Gravitationskraft folgen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_38/38_13_Bubles_Emit_Gravity.png}

\caption{\label{fig-1_13}Trotz umgekehrter Schwerkraft werden die
Wassertropfen entlang der Normalen des Objektes -- also nach unten --
ausgeschÃ¼ttet, bevor sie aufsteigen.}

\end{figure}%

\marginnote{Partikel umgekehrt ausschÃ¼tten}

Durch ein Umkehren der Normalen wÃ¼rden die Partikel nach oben
ausgestossen und dadurch von Anfang an der Gravitationskraft folgen.
Dies wÃ¼rde allerdings dazu fÃ¼hren, dass die Normalen des Wasser-Objekts
fÃ¼r die Materialien falsch ausgerichtet wÃ¤ren. Stattdessen kann im
Reiter Â«\emph{Velocity}Â» der Wert fÃ¼r Â«\emph{Normal}Â» von 1 auf -1
gesetzt werden. Dadurch werden die Partikel entgegengesetzt der Normalen
ausgeschÃ¼ttet.

\marginnote{Letzte Anpassungen}

Zu guter Letzt werden noch zwei Anpassungen benÃ¶tigt: Indem unter
Â«\emph{Velocity}Â» der Wert fÃ¼r Â«\emph{Tangent}Â» erhÃ¶ht wird,
beispielsweise auf 0.75, verteilen sich die Partikel etwas mehr entlang
der Tangente. ZusÃ¤tzlich sollte die Lifetime der Partikel so angepasst
werden, dass die Partikel nicht so lange leben, dass sie das Glas
verlassen (beispielsweise eine Â«\emph{Lifetime}Â» von 9, je nach HÃ¶he des
Wassers).

\chapter{BÃ¤ume mittels Add-on
erstellen}\label{buxe4ume-mittels-add-on-erstellen}

\marginnote{Partikel und Haare kÃ¶nnen fÃ¼r Vielzahl von Objekten verwendet werden}

Mithilfe des Partikelsystems lassen sich Objekte mit vielen Details
erstellen. Dies muss nicht nur auf Haare als solche beschrÃ¤nkt sein,
sondern kann auch auf eine Reihe weiterer Objekte angewendet werden.
Eine Anwendungsoption wÃ¤re auch die Erstellung von BÃ¤umen, welche
anschliessend BlÃ¤tter als Haare aussenden. Allerdings gibt es fÃ¼r die
Erstellung von BÃ¤umen alternative Vorgehensweisen. Zudem wird mit
Blender automatisch ein Add-on mitgeliefert, welches die Erstellung von
BÃ¤umen vereinfacht.

\marginnote{Add-on aktivieren}

Das Add-on, welches fÃ¼r die Erstellung der BÃ¤ume benÃ¶tigt wird, heisst
Â«\emph{Sapling Tree Gen}Â». Um dieses Add-on zu aktivieren, mÃ¼ssen die
Benutzereinstellungen unter Â«\emph{Edit \textbar{} Preferences}Â»
geÃ¶ffnet werden und im Reiter Â«\emph{Add-ons}Â» nach dem Add-on gesucht
werden. Anschliessend kann das entsprechende Add-on aktiviert werden.

\marginnote{Baum hinzufÃ¼gen}

Durch das Aktivieren des Add-ons ist eine neue Option zum Erstellen von
BÃ¤umen verfÃ¼gbar. Diese Option basiert auf Kurven und muss deshalb im
Â«\emph{Add}Â»-MenÃ¼ unter Â«\emph{Curve \textbar{} Sapling Tree Gen}Â»
hinzugefÃ¼gt werden. Anschliessend wird innerhalb der Szene ein Baum
hinzugefÃ¼gt.

\marginnote{Bearbeitung der BÃ¤ume geschieht im Kontext-MenÃ¼}

Unten links im 3D-Viewport-Editor Ã¶ffnet sich zudem das Kontext-MenÃ¼ zum
hinzugefÃ¼gten Baum-Objekt. Dieses MenÃ¼ verschwindet jeweils, wenn mit
der Maus ausserhalb des Kontext-MenÃ¼s geklickt wird. Dementsprechend ist
darauf zu achten, dass nicht ungewollt ausserhalb des Kontext-MenÃ¼s
geklickt wird und das MenÃ¼ geschlossen wird. Anders als das
A.N.T.Landscape-Add-on erinnert sich das Sapling-Tree-Gen-Add-on nicht
an die zuletzt verwendeten Einstellungen und prÃ¤sentiert bei jedem neuen
Objekt wieder dasselbe Standardobjekt. Zur Not kann allerdings die
\kbd{F9}-Taste gedrÃ¼ckt werden. Diese blendet das Kontext-MenÃ¼ zur
letzten durchgefÃ¼hrten Einstellung nochmals bei der Maus ein. Dieses
zurÃ¼ckgeholte Kontext-MenÃ¼ verschwindet allerdings wieder, sobald sich
der Mauszeiger ausserhalb des MenÃ¼s befindet.

\section{Die Einstellungsoptionen von Â«Sapling Tree
GenÂ»}\label{die-einstellungsoptionen-von-sapling-tree-gen}

\marginnote{Vergabelungen von Ã„sten}

Das Sapling-Tree-Gen-Add-on erstellt jeweils BÃ¤ume basierend auf
Kurven-Objekten. Dabei wird eine Kurve erstellt und zufÃ¤llig in einzelne
Ã„ste des Baumes unterteilt. Diese Ã„ste kÃ¶nnen wiederum in weitere
Vergabelungen unterteilt werden, und diese Vergabelungen kÃ¶nnen erneut
weitere Vergabelungen von Ã„sten aufweisen. Mittels des Add-ons kÃ¶nnen
bis zu vier Stufen von Vergabelungen vorgenommen werden.

\marginnote{Einstellungen werden pro Ebene der Vergabelung definiert}

Die vier Stufen der Vergabelungen kÃ¶nnen einzeln innerhalb des Add-ons
bearbeitet werden. So kÃ¶nnen fÃ¼r die Ã„ste der einzelnen Stufen der
Vergabelungen individuelle Werte angegeben werden. HierfÃ¼r werden die
jeweiligen Einstellungswerte innerhalb von vier Feldern, die
untereinander dargestellt werden, angezeigt.

\marginnote{Unterteilung der Einstellungen auf verschiedene Seiten}

Die Einstellungen des Sapling-Tree-Gen-Add-ons sind jeweils auf
verschiedene MenÃ¼seiten verteilt. Diese lassen sich mittels des
Dropdown-MenÃ¼s Â«\emph{Settings}Â» auswÃ¤hlen. Innerhalb dieses Kapitels
werden ein paar grundlegende Einstellungsoptionen erlÃ¤utert.

\subsection{Geometry}\label{geometry}

\marginnote{Bevel-Option}

Im Bereich Â«\emph{Geometry}Â» kÃ¶nnen grundlegende Einstellungen zu der
Geometrie der BÃ¤ume vorgenommen werden. Dabei besteht die wichtigste
Einstellung aus dem KontrollkÃ¤stchen Â«\emph{Bevel}Â». Wenn dieses
KÃ¤stchen aktiviert ist, wird der Baum nicht anhand einer Kurve
dargestellt, sondern auch mit einer OberflÃ¤che versehen. Zudem kann mit
der Â«\emph{Bevel Resolution}Â» und der Â«\emph{Curve Resolution}Â» jeweils
angegeben werden, wie detailliert die Kurve respektive das Bevel
erfolgen soll. HÃ¶here Werte sind dabei mit einer hÃ¶heren Leistung des
Computers verbunden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_39/39_1_Tree_Forms.png}

\caption{\label{fig-1_1}Die verschiedenen Formen von BÃ¤umen.}

\end{figure}%

\marginnote{Shape}

Mittels des Dropdown-MenÃ¼s Â«\emph{Shape}Â» lassen sich verschiedene
Formen fÃ¼r den Baum einstellen.Es ist auch mÃ¶glich, eine eigene Form zu
erstellen. HierfÃ¼r muss die Option Â«\emph{Custom Shape}Â» fÃ¼r die Form
ausgewÃ¤hlt werden. Anschliessend kann mittels der vier Zeilen fÃ¼r die
Option Â«\emph{Custom Shape}Â» definiert werden, wie lang die Ã„ste des
Baumes sein sollen.

\marginnote{Custom-Shape-Optionen}

Die vier Zeilen der Custom-Shape-Option beschreiben:

\begin{itemize}
\tightlist
\item
  Die LÃ¤nge der unteren Ã„ste
\item
  Die LÃ¤nge der mittleren Ã„ste
\item
  Die Position der mittleren Ã„ste
\item
  Die LÃ¤nge der oberen Ã„ste
\end{itemize}

\marginnote{Astverteilung}

ZusÃ¤tzlich kÃ¶nnen auch die Ã„ste von weiteren Vergabelungen mit einer
speziellen Form versehen werden. HierfÃ¼r wird im Dropdown-MenÃ¼
Â«\emph{Secondary Splits}Â» die entsprechende Form ausgewÃ¤hlt. Mittels der
Einstellung Â«\emph{Branch Distribution}Â» kann zudem die Verteilung der
Ã„ste eher in den unteren Bereich des Baumes verlagert werden, indem
Werte gegen 0 verwendet werden, oder in den oberen Bereich des Baumes,
indem Werte gegen 10 verwendet werden.

\marginnote{ZufÃ¤llige BÃ¤ume}

Mittels der Option Â«\emph{Random Seed}Â» lassen sich verschiedene Formen
von zufÃ¤llig erstellen BÃ¤umen anzeigen, indem ein anderer Seed fÃ¼r den
Zufall verwendet wird. Zudem kann der Baum mittels Â«\emph{Scale}Â» in der
GrÃ¶sse verÃ¤ndert werden und diese GrÃ¶sse mittels Â«\emph{Scale
Variation}Â» zufÃ¤llig variiert werden. Diese Variation der Skalierung
fÃ¼hrt dazu, dass die BÃ¤ume bei einer VerÃ¤nderung der Seed mit zufÃ¤lligen
GrÃ¶ssen erstellt werden.

\marginnote{Voreinstellungen}

Zuunterst im Dropdown-MenÃ¼ Â«\emph{Load Preset}Â» kÃ¶nnen verschiedene
Voreinstellungen von BÃ¤umen geladen werden. Wenn die Option Â«\emph{Limit
Import}Â» aktiviert ist, werden lediglich basale Einstellungen dieser
Voreinstellung Ã¼bernommen. Durch eine Deaktivierung von Â«\emph{Limit
Import}Â» wird die gesamte Voreinstellung Ã¼bernommen. Zudem kÃ¶nnen eigene
Voreinstellungen abgespeichert werden. HierfÃ¼r muss im Feld
Â«\emph{Preset Name}Â» ein Name eingegeben werden und anschliessend auf
Â«\emph{Export Preset}Â» geklickt werden. Die abgespeicherte
Voreinstellung sollte anschliessend unter den Voreinstellungen abrufbar
sein.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_39/39_2_Tree_Presentations.png}

\caption{\label{fig-1_2}Die verschiedenen Voreinstellungen von
Baumarten.}

\end{figure}%

\subsection{Branch Radius}\label{branch-radius}

\marginnote{Ratio der Astdicke bestimmen}

Im Bereich Â«\emph{Branch Radius}Â» kÃ¶nnen Einstellungen bezÃ¼glich der
Radien der Ã„ste vorgenommen werden. So kann unter Â«\emph{Ratio}Â» ein
VerhÃ¤ltnis fÃ¼r die Dicke der Ã„ste zur GrÃ¶sse des Baumes definiert
werden. Mittels der zusÃ¤tzlichen Einstellungen kann diese Dicke weiter
verfeinert werden. Zudem kann der Baumstamm am Ende mittels des Werts
Â«\emph{Root Flare}Â» proportional skaliert werden.

\marginnote{Close Tip}

Mittels der Funktion Â«\emph{Close Tip}Â» werden die Ã„ste an ihren Enden
geschlossen. Ist diese Option deaktiviert, werden die Enden der Ã„ste
zylinderfÃ¶rmig dargestellt, ohne mit einem Face geschlossen zu werden.
Durch die Option Â«\emph{Close Tip}Â» werden die Enden der Ã„ste jeweils in
ihrem Mittelpunk zusammengefÃ¼hrt und geschlossen.

\marginnote{Taper}

Mittels der Â«\emph{Taper}Â»-Funktion kÃ¶nnen die Ã„ste verjÃ¼ngt werden. Das
heisst, dass weiter entfernte Ã„ste dÃ¼nner werden. Per Default sind die
Taper-Werte fÃ¼r alle Stufen der Vergabelungen auf den Wert 1 gesetzt,
sodass die Ã„ste verjÃ¼ngt werden. Dieser Wert kann reduziert werden,
damit die Ã„ste weniger verjÃ¼ngt werden. Zudem kann die Option
Â«\emph{Auto Taper}Â» aktiviert werden, damit dieser Effekt automatisch
angepasst wird.

\marginnote{Tweak-Radius}

Mittels der Zeilen fÃ¼r Â«\emph{Tweak Radius}Â» kÃ¶nnen die Radien der
einzelnen Stufen der Vergabelungen individuell angesteuert werden. Dabei
wird der Radius jede Stufe mit dem Tweak-Faktor multipliziert. Je
kleiner dieser Wert ist, desto dÃ¼nner werden die Ã„ste auf dieser Stufe.

\subsection{Branch Splitting}\label{branch-splitting}

\marginnote{Aufteilung der Ã„ste definieren}

Im Bereich Â«\emph{Branch Splitting}Â» kÃ¶nnen die einzelnen Stufen der
Baumvergabelungen anvisiert werden. ZunÃ¤chst kann mittels des Werts
Â«\emph{Levels}Â» definiert werden, wie viele Stufen von Vergabelungen der
Baum beinhalten soll. Diese Option kann Werte von 1 bis 4 annehmen.
Zudem kann im Bereich Â«\emph{Base Splits}Â» definiert werden, in wie
viele Ã„ste der Baumstamm aufgeteilt werden soll. Mittels der
Â«\emph{Trunk Height}Â» kann die HÃ¶he des Baumstamms definiert werden.
Mittels des Werts Â«\emph{Split Height}Â» kann zudem eingestellt werden,
ab welcher HÃ¶he des Baumes die Vergabelungen beginnen sollen.

\marginnote{Einstellungen der Vergabelungen}

FÃ¼r die Vergabelungen gibt es eine Reihe verschiedener Optionen, welche
fÃ¼r die verschiedenen Ebenen der Vergabelungen individuell angesteuert
werden kÃ¶nnen:

\begin{itemize}
\tightlist
\item
  Â«\textbf{\emph{Branches}}Â»: Damit wird definiert, wie viele Ã„ste pro
  Stufe erzeugt werden sollen.
\item
  Â«\textbf{\emph{Segment Splits}}Â»: Damit wird ein VerhÃ¤ltnis definiert,
  mit dem die Ã„ste innerhalb einer Stufe in mehrere Ã„ste aufgeteilt
  werden sollen. Je hÃ¶her dieser Wert ist, desto mehr Ã„ste werden auf
  derselben Stufe aufgeteilt.
\item
  Â«\textbf{\emph{Split Angle}}Â»: Mittels dieser Option kann eine
  KrÃ¼mmung auf den einzelnen Stufen der Ã„ste definiert werden.
\item
  Â«\textbf{\emph{Split Angle Variation}}Â»: Mittels dieser Option kann
  definiert werden, wie stark der Wert fÃ¼r Â«\emph{Split Angle}Â» auf dem
  jeweiligen Level zufÃ¤llig variiert werden soll.
\item
  Â«\textbf{\emph{Rotate Angle}}Â»: Mittels dieser Option kann ein Wert
  festgelegt werden, mit dem sich Vergabelungen von neuen Ã„sten vom
  Ursprungsast wegrotieren.
\item
  Â«\textbf{\emph{Rotate Angle Variation}}Â»: Mittels dieser Option kann
  definiert werden, wie sehr der Wert fÃ¼r Â«\emph{Rotate Angle}Â» auf der
  jeweiligen Stufe zufÃ¤llig variiert werden soll.
\item
  Â«\textbf{\emph{Outward Attraction}}Â»: Mit diesem Wert kann fÃ¼r jede
  Stufe des Baumes angegeben werden, wie stark sich die Ã„ste nach aussen
  hin orientieren sollen.
\item
  Â«\textbf{\emph{Curve Resolution}}Â»: Mit diesem Wert kÃ¶nnen die
  einzelnen Stufen des Baumes detaillierter erstellt werden. Je hÃ¶her
  diese Werte sind, desto mehr Leistung wird benÃ¶tigt.
\end{itemize}

\subsection{Branch Growth}\label{branch-growth}

\marginnote{Branch-Growth-Einstellungen}

Im Bereich Â«\emph{Branch Growth}Â» kÃ¶nnen Einstellungen gemacht werden,
welche die Verformung der Ã„ste beschreiben:

\begin{itemize}
\tightlist
\item
  Â«\textbf{\emph{Length}}Â»: Mit dieser Option kann die LÃ¤nge der Ã„ste
  fÃ¼r die einzelnen Stufen des Baumes definiert werden.
\item
  Â«\textbf{\emph{Length Variation}}Â»: Mit dieser Option kÃ¶nnen die
  LÃ¤ngen der Ã„ste des Baumes auf den einzelnen Stufen zufÃ¤llig variiert
  werden.
\item
  Â«\textbf{\emph{Down Angle}}Â»: Mit dieser Option kann ein Winkel
  angegeben werden, in dem die Ã„ste nach unten gezogen werden.
\item
  Â«\textbf{\emph{Down Angle Variation}}Â»: Mit dieser Option kann der
  maximale Winkel, welcher zufÃ¤llig dem Wert Â«\emph{Down Angle}Â»
  hinzugefÃ¼gt wird, eingestellt werden.
\item
  Â«\textbf{\emph{Curvature}}Â»: Mit dieser Option kann ein Winkel
  angegeben werden, mit dem sich die Ã„ste an deren Ende krÃ¼mmen.
\item
  Â«\textbf{\emph{Curvature Variation}}Â»: Mit dieser Option kann der
  maximale Winkel, welcher zufÃ¤llig dem Wert Â«\emph{Curvature}Â»
  hinzugefÃ¼gt wird, eingestellt werden.
\item
  Â«\textbf{\emph{Back Curvature}}Â»: Mit dieser Option kann ein Winkel
  fÃ¼r die KrÃ¼mmung in der zweiten HÃ¤lfte der Ã„ste definiert werden.
\item
  Â«\textbf{\emph{Vertical Attraction}}Â»: Mit diesem Wert kann ein Wert
  fÃ¼r eine vertikale Anziehung der Ã„ste nach oben definiert werden.
\end{itemize}

\subsection{Pruning}\label{pruning}

\marginnote{BÃ¤ume beschneiden}

Innerhalb der Einstellungen zum Â«\emph{Pruning}Â» kann der Baum
geschnitten werden. HierfÃ¼r muss die Option Â«\emph{Prune}Â» aktiviert
werden. Anschliessend erscheint ein Viewport-Overlay, welche die Form
der Beschneidung des Baumes veranschaulicht. Diese Beschneidung kann
dabei in der Breite variiert werden mit dem Wert Â«\emph{Prune Width}Â»
und in der HÃ¶he mit dem Wert Â«\emph{Prune Base}Â». Mittels Â«\emph{Prune
Width Peak}Â» kann die Baumkrone bearbeitet werden und mittels der Zeilen
Â«\emph{Prune Power}Â» kann die Beschneidung am unteren Ende und am oberen
Ende nicht-linear variiert werden.

\subsection{Leaves}\label{leaves}

\marginnote{BlÃ¤tter hinzufÃ¼gen}

Sofern nicht gerade Winter ist, besitzen BÃ¤ume auch BlÃ¤tter. Diese
kÃ¶nnen in den Einstellungen zu den Â«\emph{Leaves}Â» bearbeitet werden.
HierfÃ¼r muss allerdings die Option Â«\emph{Show Leaves}Â» aktiviert
werden. Mit dem Wert Â«\emph{Leaves}Â» kann die maximale Anzahl der
BlÃ¤tter pro Ast definiert werden. Dabei ist darauf zu achten, dass eine
hohe Anzahl BlÃ¤tter sehr viel Leistung vom Computer benÃ¶tigt.

\marginnote{BlÃ¤tter-Formen}

Die BlÃ¤tter kÃ¶nnen verschiedene Formen annehmen und unter Â«\emph{Leaf
Object}Â» kann auch ein Objekt als Blatt verwendet werden. Es gibt
folgende Formoptionen:

\begin{itemize}
\tightlist
\item
  Â«\textbf{\emph{Hexagonal}}Â»: Ein achteckiges Blatt.
\item
  Â«\textbf{\emph{Rectangular}}Â»: Ein viereckiges Blatt.
\item
  Â«\textbf{\emph{DupliFaces}}Â»: Faces, welche sich quer durch den Ast
  erstrecken.
\item
  Â«\textbf{\emph{DupliVertcs}}Â»: Es werden lediglich Vertices an den
  Stellen der BlÃ¤tter erstellt.
\end{itemize}

\marginnote{Einstellungen der BlÃ¤tter}

FÃ¼r die BlÃ¤tter kÃ¶nnen weitere Einstellungen vorgenommen werden:

\begin{itemize}
\tightlist
\item
  Â«\textbf{\emph{Leaf Down}}Â»: Der Winkel, zu dem die BlÃ¤tter vom Ast
  herabhÃ¤ngen.
\item
  Â«\textbf{\emph{Leaf Down Variation}}Â»: Der Wert, zu dem die
  Einstellung Â«\emph{Leaf Down}Â» zufÃ¤llig variiert werden.
\item
  Â«\textbf{\emph{Leaf Rotation}}Â»: Der Winkel, zwischen einem Blatt und
  dem Ast.
\item
  Â«\textbf{\emph{Leaf Rotation Variation}}Â»: Der Wert, zu dem die
  Einstellung Â«\emph{Leaf Rotation}Â» zufÃ¤llig variiert wird.
\item
  Â«\textbf{\emph{Leaf Scale}}Â»: Einstellung der GrÃ¶sse der BlÃ¤tter.
\item
  Â«\textbf{\emph{Leaf Scale X}}Â»: Einstellung der Breite der BlÃ¤tter.
\item
  Â«\textbf{\emph{Leaf Scale Taper}}Â»: Wie lange die BlÃ¤tter sein sollen.
\item
  Â«\textbf{\emph{Leaf Scale Variation}}Â»: Der Wert, zu dem die GrÃ¶sse
  der BlÃ¤tter variieren darf.
\item
  Â«\textbf{\emph{Leaf Angle}}Â»: Ein Wert, der beschreibt, wie stark die
  BlÃ¤tter vertikal ausgerichtet werden sollen.
\end{itemize}

\section{BlÃ¤tter texturieren}\label{bluxe4tter-texturieren}

\marginnote{UVs der BlÃ¤tter}

Sobald ein Baum mit BlÃ¤ttern erstellt wurde, werden die BlÃ¤tter in einem
separaten Objekt erstellt. Die BlÃ¤tter haben alle Form und dieselben UVs
pro Blatt. Dementsprechend kann mit diesen UVs ein Material erstellt
werden. HÃ¤ufig werden dabei Texturen fÃ¼r BlÃ¤tter verwendet. Einige
dieser Texturen beinhalten auch mehrere BlÃ¤tter, sodass die UVs so
angepasst werden mÃ¼ssen, dass sie jeweils ein Blatt der Textur abbilden.

\marginnote{Transparenz zu BlÃ¤ttern hinzufÃ¼gen}

Im Material des Blattes sollte jeweils darauf geachtet werden, dass eine
Alpha-Textur verwendet wird, welche mit dem Alpha-Input des
Principled-BSDF-Shaders verbunden wird. Dadurch wird nicht das gesamte
Bild, sondern lediglich der nicht-transparente Bereich des Bildes
dargestellt. Dies erfordert bei der Verwendung von Eevee zusÃ¤tzlich,
dass im Material-Reiter des Properties-Editors unter dem Reiter
Â«\emph{Settings}Â» der Â«\emph{Blend Mode}Â» auf Â«\emph{Alpha Hashed}Â» oder
Â«\emph{Alpha Blend}Â» gestellt wird.

Ãœbung 17: Baum erstellen

\textbf{Ãœbung 17.1}

Erstellen Sie einen eigenen Baum mittels des Sapling-Tree-Gen-Add-ons
und fÃ¼gen Sie dem Baum BlÃ¤tter hinzu.

\textbf{Ãœbung 17.2}

Texturieren Sie den Baum und die BlÃ¤tter.

\textbf{Ãœbung 17.3}

Rendern Sie ein Bild ihres Baumes.

\chapter{Workflows der
Charaktererstellung}\label{workflows-der-charaktererstellung}

\section{Charaktererstellung}\label{charaktererstellung}

\marginnote{KomplexitÃ¤t von Charakteren}

Die Erstellung von Charakteren stellt einen komplexen Bereich der
Erstellung von 3D-Objekten dar. Charakteren beinhalten deutlich
komplexere OberflÃ¤chen als GegenstÃ¤nde, was deutlich mehr Zeit
erfordert. Wenn zudem ein mÃ¶glichst fotorealistischer Charakter erzielt
werden soll, mÃ¼ssen Unebenheiten und Feinheiten genau ausgearbeitet
werden.

\marginnote{Charakter kÃ¶nnen Posen verÃ¤ndern}

Eine weitere Herausrforderung von Charakteren ergibt sich daraus, dass
sie stark verformbar sind und verschiedene Posen einnehmen kÃ¶nnen.
Dieses Problem ergibt sich bei den meisten GegenstÃ¤nden nicht.
Dementsprechend sollte bei der Charaktererstellung auch berÃ¼cksichtigt
werden, ob der Charakter in verschiedenen Situationen benÃ¶tigt wird und
ob daher eine VerÃ¤nderung der Pose benÃ¶tigt wird. In den meisten FÃ¤llen
ist dies der Fall. Dementsprechend muss bei der Bearbeitung des Meshes
jeweils darauf geachtet werden, dass das Mesh diese VerÃ¤nderungen der
Pose Ã¼berhaupt ermÃ¶glicht.

\marginnote{Schritt fÃ¼r Schritt}

Die Erstellung von Charakteren wird in der Regel in unterschiedliche
Teilaufgaben unterteilt. Diese Teilaufgaben werden in grossen Studios
teilweise auch auf verschiedene Gruppen oder Abteilungen aufgeteilt.

\begin{itemize}
\item
  \textbf{Character-Modeling}: Der Charakter wird als Mesh erstellt.
  HierfÃ¼r gibt es eine Reihe verschiedener Vorgehensweisen. Zudem wird
  der Charakter bereits mit Texturen und texturierten Kleidern
  ausgestattet.
\item
  \textbf{Character-Rigging}: Der Charakter wird fÃ¼r Animationen oder
  die Erstellung von Posen vorbereitet.

  \begin{itemize}
  \item
    Es wird ein Skelett aus Knochen erstellt, welches eine Verformung
    des Meshes ermÃ¶glicht.
  \item
    Das Skelett aus Knochen wird dem Charakter zugewiesen, sodass eine
    Verformung dieses Skeletts zu einer Verformung des Charakter-Meshes
    fÃ¼hrt.
  \item
    Die Datenstruktur des Meshes wird bearbeitet, sodass das Mesh besser
    auf das Skelett abgestimmt wird.
  \end{itemize}
\item
  \textbf{Character-Animation}: Der geriggte Charakter kann
  anschliessend verformt werden. Dadurch kÃ¶nnen verschieden Posen
  angesteuert werden (z.B. fÃ¼r Standbilder) oder ein Bewegungsablauf des
  Charakters erstellt werden (z.B. fÃ¼r Animationen).
\end{itemize}

\chapter{Character-Modeling}\label{character-modeling}

\marginnote{Vorgehensweisen zur Erstellung eines Charakters}

Um ein Mesh eines Charakters zu erzielen, gibt es verschiedene
Vorgehensweisen. Nachfolgend werden einige dieser Vorgehensweisen
erlÃ¤utert. Diese Liste ist allerdings nicht abschliessend.

\section{Sculpting von Charakteren}\label{sculpting-von-charakteren}

\subsection{Der Sculpt-Mode}\label{der-sculpt-mode}

\marginnote{Sculpt-Mode}

Eine MÃ¶glichkeit besteht darin, dass ein Charakter mittels Sculpting
modelliert wird. Da der Sculpting-Prozess ziemlich aufwendig ist, wird
er an dieser Stelle nur grob umschrieben. Ein ausgewÃ¤hltes Objekt kann
jeweils im Sculpt-Mode skulpturiert werden. Der Sculpt-Mode ist ein
alternativer Modus zum Object- und Edit-Mode und kann mit dem
Dropdown-MenÃ¼ in der linken oberen Ecke des 3D-Viewport-Editors
ausgewÃ¤hlt werden.

\marginnote{Pinsel anwenden}

In der Toolbar auf der linken Seite des Sculpt-Modes befinden sich
unterschiedliche Pinsel, mit denen das Mesh bearbeitet werden kann. FÃ¼r
die Bearbeitung muss jeweils mit der Maus auf die Stelle des Objektes
geklickt werden, welche bearbeitet werden soll. Anschliessend wird der
Effekt dieses Pinsels auf das Objekt angewendet. Wenn der Mauszeiger bei
gedrÃ¼ckter Maustaste bewegt wird, wird der Effekt entlang der Bewegung
des Mauszeigers auf das Objekt angewendet.

\marginnote{Pinsel vergrÃ¶ssern}

Um den Mauszeiger herum wird dabei ein Kreis angezeigt. Dieser Kreis
gibt an, wie gross die FlÃ¤che ist, auf welche der Effekt des
ausgewÃ¤hlten Pinsels angewendet werden soll. Durch einen Klick mit der
Taste \kbd{F} kann die GrÃ¶sse dieses Kreises verÃ¤ndert werden. Durch
eine Bewegung der Maus nach links oder rechts wird dabei das der Kreis
vergrÃ¶ssert oder verkleinert. Um die GrÃ¶sse des Kreises zu akzeptieren,
kann die linke Maustaste oder die \kbd{Enter}-Taste gedrÃ¼ckt werden.
Mittels der \kbd{esc}-Taste kann der Vorgang abgebrochen werden.

\marginnote{Einstellung des Pinsels}

In der Sidebar auf der rechten Seite des Sculpt-Modes kann unter dem
Reiter Â«\emph{Tool}Â» der ausgewÃ¤hlte Pinsel unter Â«\emph{Brush
Settings}Â» genauer definiert werden. Mit dem Wert Â«\emph{Radius}Â» kann
der Kreis fÃ¼r die Bearbeitung des Meshes mittels einer Zahl vergrÃ¶ssert
oder verkleinert werden. Mittels des Wertes Â«\emph{Strength}Â» kann
definiert werden, wie stark der Effekt des jeweiligen Pinsels auf das
Mesh angewendet werden soll. Mittels der Â«\emph{Direction}Â» lÃ¤sst sich
zudem bei vielen Pinseln auswÃ¤hlen, ob mit dem Pinsel der jeweilige
Effekt aus dem Mesh herausgezogen werden soll (bei der Option
Â«\emph{Add}Â») oder in das Mesh hineingedrÃ¼ckt werden soll (bei der
Option Â«\emph{Subtract}Â»). Dabei erfolgt eine Bearbeitung stets entlang
der Seite der Faces, auf der die jeweilige Normale liegt.

\marginnote{Dyntopo ermÃ¶glicht ein dynamisches Skulpturieren von Meshes}

Beim Skulpturieren werden jeweils die Vertices innerhalb des Meshes
entsprechend des Effektes verschoben. Dies bedeutet allerdings auch,
dass die Topografie des Meshes genug Vertices beinhalten muss, damit
diese bearbeitet werden kÃ¶nnen. Wird etwa einfach der StandardwÃ¼rfel
verwendet, kÃ¶nnen lediglich dessen acht Ecken bearbeitet werden. Es ist
allerdings auch mÃ¶glich, in der Sidebar unter dem Reiter Â«\emph{Tools}Â»
die Option Â«\emph{Dyntopo}Â» auszuwÃ¤hlen. Diese Option ermÃ¶glicht es,
dass beim Anwenden der Pinsel auf das Mesh direkt neue Vertices erstellt
werden, sodass eine dynamische Bearbeitung der Topografie des Meshes
mÃ¶glich ist. Dies hat allerdings zur Folge, dass Mesh-Daten, wie
beispielsweise die UVs, verformt werden.

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Wenn beim Ã–ffnen eines neuen Blender-Projektes die Auswahl Â«*Sculpting*Â» verwendet wird, erstellt Blender ein neues File mit einer Kugel als Startobjekt, welche im Sculpt-Mode bearbeitet werden kann. Bei dieser Kugel handelt es sich um eine Â«*Quad Sphere*Â», welche die beste Grundlage fÃ¼r das Erstellen von Objekten mittels Sculpting darstellt.
\end{tipp}

\subsection{Retopology}\label{retopology}

\marginnote{Sculpting-Modelle sind nicht fÃ¼r weitere Bearbeitungen geeignet}

Wenn Charaktere im Sculpt-Mode erstellt werden, weisen diese in der
Regel eine sehr hohe Anzahl Vertices auf, die durch die Bearbeitung
mittels Sculpting entstehen. Ein solches Mesh ist nicht geeignet zum
Animieren. Aus diesem Grund wird das gesculptete Mesh als Vorlage
verwendet, um ein neues Mesh zu verwenden, das eine praktischere
Gitterstruktur als Topologie aufweist. Dieser Prozess wird als
Retopology bezeichnet.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_41/41_1_Plane.png}

\caption{\label{fig-1_1}Eine Plane zur Vorbereitung des
Retopology-Prozesses.}

\end{figure}%

\marginnote{Mesh fÃ¼r Retopology vorbereiten}

Das skulpturierte Mesh stellt beim Retopology jeweils das Base-Mesh dar.
Anschliessend wird ein neues Mesh, welches lediglich aus einer FlÃ¤che
besteht, hinzugefÃ¼gt. HierfÃ¼r kann etwa im Â«\emph{Add}Â»-MenÃ¼ die Option
Â«\emph{Mesh \textbar{} Plane}Â» ausgewÃ¤hlt werden. Diese FlÃ¤che wird
anschliessend im Edit-Mode vor dem Base-Mesh platziert und um einen
Meter entlang der X-Achse verschoben, sodass die beiden linken Vertices
der FlÃ¤che genau auf dem Nullpunkt der X-Achse liegen. HierfÃ¼r muss die
Plane zudem um 90 Grad rotiert werden. Anschliessend wird ein
Mirror-Modifier hinzugefÃ¼gt, um das Mesh entlang der X-Achse zu
spiegeln. Das HinzufÃ¼gen des Mirror-Modifiers erÃ¼brigt sich bei einem
nicht-symmetrischen Mesh. In diesem Falle mÃ¼ssen beide Seiten
individuell erstellt werden. ZusÃ¤tzlich kann ein
Subidivision-Surface-Modifier hinzugefÃ¼gt werden um die FlÃ¤chen zu
unterteilen.

\marginnote{Shrinkwrap-Modifier}

Anschliessend kann dem Mesh ein Â«\emph{Shrinkwrap}Â»-Modifier hinzugefÃ¼gt
werden. Dieser ist in der Modifier-Auswahl in der dritten Spalte unter
Â«\emph{Deform}Â» zu finden. Mittels dieses Modifiers werden die Vertices
eines Objektes direkt auf ein anderes Objekt projiziert. HierfÃ¼r muss
unter Â«\emph{Target}Â» das entsprechende Objekt eingestellt werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_41/41_2_Plane_Modified.png}

\caption{\label{fig-1_2}Eine Plane mit Mirror-, Shrinkwrap- und
Subidivision-Surface-Modifier.}

\end{figure}%

\marginnote{Einstellung der Modifier}

Um die neu erstellte FlÃ¤che auf das Base-Mesh zu Ã¼bertragen, sollte das
Base-Mesh als Target im Shrinkwrap-Modifier ausgewÃ¤hlt werden. Dadurch
wird die FlÃ¤che des neuen Meshes direkt auf die FlÃ¤che des Base-Meshes
projiziert. Damit die jeweiligen VerÃ¤nderungen der Modifier im Edit-Mode
betrachtet werden kÃ¶nnen, empfiehlt es sich, bei den drei Modifiern die
Einstellung Â«\emph{On Cage}Â» und Â«\emph{Edit Mode}Â» zu aktivieren.

\marginnote{Objekt immer im Vordergrund darstellen lassen}

Teilweise entsteht das Problem, dass das Retopology-Mesh nicht klar
sichtbar ist, weil das Base-Mesh darÃ¼ber dargestellt wird. Im
Properties-Editor kann innerhalb des Reiters Â«\emph{Object Properties}Â»
der Reiter Â«\emph{Viewport Display}Â» ausgewÃ¤hlt werden. Dort kÃ¶nnen
verschiedene Darstellungsoptionen des Objektes im 3D-Viewport-Editor
ausgewÃ¤hlt werden. Durch das Aktivieren der Option Â«\emph{In Front}Â»
wird das aktuell ausgewÃ¤hlte Objekt immer vor anderen Objekten
dargestellt, selbst wenn sich die anderen Objekte eigentlich zwischen
der eigenen Ansicht und dem ausgewÃ¤hlten Objekt befinden. Diese Option
sollte aktiviert werden, wÃ¤hrend das Retopology-Mesh ausgewÃ¤hlt ist.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_41/41_3_Mesh_Extrusion.png}

\caption{\label{fig-1_3}Besondere kÃ¶rperliche Merkmale, wie etwa die
Augen, werden mit einer Schlaufe von Faces umreandet.}

\end{figure}%

\begin{figure}

\includegraphics{Chapters/Images/Chapter_41/41_4_Mesh_Head.png}

\caption{\label{fig-1_4}Die Edges werden schrittweise extrudiert.}

\end{figure}%

\marginnote{Snap-Funktion aktivieren}

Anschliessend kann das Retopology-Mesh im Edit-Mode bearbeitet werden.
HierfÃ¼r wird Schritt fÃ¼r Schritt eine neue FlÃ¤che aus dem
Retopology-Mesh erstellt, indem die einzelnen Edges der bestehenden
Faces extrudiert werden, und so das Base-Mesh mit einer klaren Struktur
nachgebildet. Damit die extrudierten Faces einfacher platziert werden
kÃ¶nnen, sollte hierfÃ¼r die Snap-Funktion im Header des
3D-Viewport-Editors aktiviert und beispielsweise auf die Einstellung
Â«\emph{Faces}Â» gesetzt werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_41/41_5_Object_Head.png}

\caption{\label{fig-1_5}Der Kopf nach dem Retopology-Prozess.}

\end{figure}%

\marginnote{Was bewirken die Modifier?}

Durch den Mirror-Modifier werden Bearbeitungen des Charakters auf der
einen Seite der X-Achse direkt auch auf die andere Seite der X-Achse
angewendet. Durch den Shrinkwrap-Modifier werden diese Faces direkt an
die Form des Base-Meshes angepasst. Da zuvor noch der
Subdivision-Surface-Modifier platziert wurde, kann der
Shrinkwrap-Modifier mehr Vertices an das Base-Mesh anpassen und so
dessen Verformungen etwas besser berÃ¼cksichtigen.

Mit diesem Vorgang kann anschliessend der ganze Charakter mit einer
sinnvollen Gitterstruktur extrudiert werden. Idealerweise werden die
Vertices im Retopology-Mesh so angepasst, dass sie jeweils gewollte
Einkerbungen (beispielsweise bei Augenringen) mit abdecken. Zudem
sollten Aspekte wie Mund, Nase, Ohren und Augen idealerweise kreisfÃ¶rmig
geschlossen sein. Ausserdem sollte beim Retopology darauf geachtet
werden, dass KÃ¶rperbereiche, welche sich stÃ¤rker verformen
(beispielweise, Ellbogen, Knie, FÃ¼sse, HÃ¤nde, Schultern, Gesicht), etwas
mehr Vertices aufweisen als KÃ¶rperteile, welche weniger stark verformbar
sein sollten.

\marginnote{Probleme beim Retopology-Prozess}

Der Retopology-Prozess ist dabei sehr aufwÃ¤ndig. Zudem kann es manchmal
zu Schwierigkeiten kommen, wenn etwa mehrere Reihen von Faces
miteinander verknÃ¼pft werden mÃ¼ssen, diese aber unterschiedliche Anzahl
Faces aufweisen. Zudem sollte auch hier darauf geachtet werden, wenn
mÃ¶glich nur Quads zu verwenden.

\subsection{Sculpt-Mesh neu berechnen
lassen}\label{sculpt-mesh-neu-berechnen-lassen}

\marginnote{Remesh-Funktionen}

Blender beinhaltet zwei MÃ¶glichkeiten, wie ein Sculpt-Mesh in seinem
Aufbau neu berechnet werden kann. Zum einen kann dem skulpturierten Mesh
ein Remesh-Modifier hinzugefÃ¼gt werden, zum anderen kann ein Mesh im
Object-Data-Properties-Reiter des Properties-Editors unter
Â«\emph{Remesh}Â» neu berechnet werden. Im Remesh-MenÃ¼ stehen dabei
verschiedene Berechnungsmethoden zur VerfÃ¼gung. So kann entweder
Voxel-basiert das Mesh neu erstellt werden oder basierend auf den Quads
der Faces (Â«\emph{QuadriFlow Remesh}Â»).

\marginnote{Nachteile von Remesh}

Der Nachteil dieser Methode ist allerdings die geringe Kontrolle.
Details im Mesh kÃ¶nnen nur automatisch ausgearbeitet werden und die
resultierende Mesh-Struktur entspricht nicht immer den eigenen
Vorstellungen. Zudem werden Symmetrien beim Remesh nicht berÃ¼cksichtigt.

\section{Direktes Modellieren eines
Charakters}\label{direktes-modellieren-eines-charakters}

\marginnote{Charaktere im Edit-Mode erstellen}

Eine weitere MÃ¶glichkeit, um Charaktere zu erstellen, besteht darin,
dass das Mesh direkt im Edit-Mode zu einer Figur verformt wird. Dies ist
allerdings ebenfalls mit einem gewissen Aufwand verbunden. Dabei ist zu
empfehlen, dass mehrere Fenster des 3D-Viewport-Editors geÃ¶ffnet werden
und diese jeweils dasselbe Objekt aus unterschiedlichen Perspektiven
darstellen. Dadurch kÃ¶nnen VerÃ¤nderungen schnell aus unterschiedlichen
Perspektiven betrachtet werden. Auch die Verwendung von Vorlagen kann
helfen, um ein Mesh nachzubilden.

\marginnote{Erstellung von Charakteren mittels Skin-Modifier}

Eine etwas einfachere Option zur Erstellung von Charakteren ergibt sich
zudem durch die Verwendung des Skin-Modifiers. HierfÃ¼r wird ein neues
Objekt erstellt und alle dessen Vertices in deren Mittelpunkt verbunden,
indem im Edit-Mode mit der Taste \kbd{A} alle Vertices ausgewÃ¤hlt werden
und mit der Taste \kbd{M} das Merge-MenÃ¼ geÃ¶ffnet wird. Darin kann
anschliessend die Option Â«\emph{Merge \textbar{} At Center}Â» ausgewÃ¤hlt
werden. Anschliessend kann dem Objekt ein Mirror-Modifier, gefolgt von
einem Skin-Modifier, hinzugefÃ¼gt werden.

\marginnote{Modifier vorbereiten}

Der Mirror-Modifier spiegelt nun die Vertices entlang der X-Achse und
der Skin-Modifier erstellt eine OberflÃ¤che um den einzelnen Vertex
herum. Wichtig ist dabei, dass die Funktion Â«\emph{Clipping}Â» im
Mirror-Modifier aktiviert ist, damit die Vertices nicht Ã¼ber den
Nullpunkt der X-Achse verschoben werden kÃ¶nnen. Dadurch ist es
allerdings nicht mehr mÃ¶glich, Vertices vom Nullpunkt der X-Achse zu
entfernen. Dementsprechend muss die Einstellung Â«\emph{Clipping}Â»
kurzzeitig deaktiviert werden, um einen Vertex vom Nullpunkt der X-Achse
zu entfernen. Zudem sollte die Option Â«\emph{Merge}Â» aktiviert sein,
damit die Vertices am Nullpunkt der X-Achse miteinander verbunden
werden.

\marginnote{Charakter anhand eines Vertex erstellen}

Mit diesen Einstellungen kann nun mittels Vertices und Edges ein GerÃ¼st
fÃ¼r einen Charakter erstellt werden. Indem die Skalierung der Vertices
erhÃ¶ht oder reduziert wird, kann die Breite verschiedener
KÃ¶rpersegmente, welche durch den Skin-Modifier erzeugt werden,
bearbeitet werden. Diese Skalierung der Vertices kann mit der
Tastenkombination \kbd{Ctrl} + \kbd{A} vorgenommen werden.

\marginnote{Kanten aus Charakter entfernen}

Der Charakter wird dabei kantig erstellt. Durch das HinzufÃ¼gen eines
Subdivision-Surface-Modifiers werden diese Kanten geglÃ¤ttet, wobei die
Anzahl Subdivisions in den meisten FÃ¤llen noch auf den Wert 2, wenn
nicht sogar 3, erhÃ¶ht werden sollte. Zudem kann im Skin-Modifier die
Option Â«\emph{Smooth Shading}Â» aktiviert werden. Dadurch werden noch
vorhandene Kanten abgerundet dargestellt. Die Aktivierung des
Smooth-Shadings unter Â«\emph{Object \textbar{} Shade Smooth}Â» fÃ¼hrt zu
keiner VerÃ¤nderung, wenn die Option Â«\emph{Smooth Shading}Â» im
Skin-Modifier nicht aktiviert wurde.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_41/41_6_Comparison_Remesh.png}

\caption{\label{fig-1_6}Ein Mesh, sowie deren Vertcies im Vergleich
zwischen dem gesculpteten original, einer Bearbeitung mit
Quadriflow-Remesh und einer Bearbeitung mit dem Remesh-Modifier.}

\end{figure}%

\section{Alternative Tools zur Erstellung von
Charakteren}\label{alternative-tools-zur-erstellung-von-charakteren}

\marginnote{MakeHuman}

Die Erstellung von realistischen menschlichen Charakteren ist komplex
aufgrund der vielen Details des menschlichen KÃ¶rpers. Es gibt allerdings
einige praktische alternative Programme, welche eine schnelle Erstellung
von menschlichen Charakteren ermÃ¶glichen. Das Programm
Â«\emph{MakeHuman}Â» stellt eine solche Applikation dar, welche
ursprÃ¼nglich als Add-on fÃ¼r Blender erstellt wurde, mittlerweile aber
als eigenstÃ¤ndiges Programm zur VerfÃ¼gung gestellt wird.

\marginnote{Download von MakeHuman}

Bei MakeHuman handelt es sich ebenfalls um ein kostenfreies Programm.
Auf der Website \url{http://www.makehumancommunity.org/} kann das
Programm heruntergeladen werden. Zudem gibt es auch Plug-ins fÃ¼r
MakeHuman und Add-ons fÃ¼r Blender. Durch diese kann unter anderem ein
schneller Transfer der in MakeHuman erstellten Avatare in Blender
ermÃ¶glicht werden.

\marginnote{Funktionsweise von MakeHuman}

Der Vorteil von MakeHuman besteht darin, dass sich leicht sehr
unterschiedliche Charaktere erstellen lassen. Diese werden anhand
verschiedener Parameter erstellt, welche unterschiedliche
KÃ¶rpereigenschaften der dreidimensionalen Charaktere verÃ¤ndern. Zudem
werden Charaktere mit Texturen und Materialien versehen und kÃ¶nnen auch
als 3D-Objekte aus dem Programm exportiert werden.

\section{Die Rolle der Kleider}\label{die-rolle-der-kleider}

\marginnote{Kleider als Duplikat des KÃ¶rpers}

Charaktere tragen oftmals Kleidung. Simplere KleidungsstÃ¼cke kÃ¶nnen
erstellt werden, indem ein Duplikat des Charakters erstellt wird und von
diesem Objekt die FlÃ¤chen ausgewÃ¤hlt werden, welche ein KleidungsstÃ¼ck
abdecken. FÃ¼r einen Pullover wÃ¼rden demnach die Vertices des Torsos und
der Arme ausgewÃ¤hlt. Die restlichen Vertices werden gelÃ¶scht. Dieser
Pullover kann anschliessend etwas grÃ¶sser skaliert werden und mit einer
Dicke versehen werden. Dadurch erhÃ¤lt man bereits eine simple Form eines
KleidungsstÃ¼ckes.

\marginnote{Kleider ohne darunterliegendes Charakter-Mesh}

In dem soeben beschriebenen Fall wÃ¼rden die KleidungsstÃ¼cke als Duplikat
des KÃ¶rpers erstellt, welches anschliessend einen Teil des
Charakter-Meshes Ã¼berdeckt. In manchen FÃ¤llen werden anschliessend die
Vertices des KÃ¶rpers, welche unterhalb der Kleidung liegen und somit
nicht sichtbar sind, gelÃ¶scht. Dadurch entsteht ein Charakter-Mesh,
welches nur die sichtbaren Teile des KÃ¶rpers beinhaltet, und ein Mesh
fÃ¼r die Kleidung, welches die fehlenden Teile des KÃ¶rpers Ã¼berdeckt.

\marginnote{Vorteile durch das Entfernen abgedeckter Vertices}

Der Verzicht auf die fehlenden KÃ¶rperteile hat mehrere Vorteile. Zum
einen wird damit die Anzahl Vertices, welche der Charakter benÃ¶tigt,
reduziert. Zum anderen kann es beim Posieren oder bei der Animation von
Charakteren vorkommen, dass durch Kleidung abgedeckte KÃ¶rperteile sich
so verformen, dass sie teilweise durch die Kleidung hindurchschauen.
Wenn diese KÃ¶rperteile jedoch fehlen, kann das Problem verhindert
werden.

\marginnote{Kleider und Charakter als verbundene Objekte}

Die letzte Option zum Umgang mit Kleidern besteht darin, dass das Mesh
so gestaltet wird, dass sich ein fliessender Ãœbergang zwischen den
Kleidern und den sichtbaren KÃ¶rperteilen ergibt und die unsichtbaren
KÃ¶rperteile entfernt werden. Dabei sind die KÃ¶rperteile und die Kleider
direkt mit Vertices verbunden und bilden somit ein verbundenes Objekt.

\chapter{Tutorial: Eine Cartoon-Katze als Charakter
erstellen}\label{tutorial-eine-cartoon-katze-als-charakter-erstellen}

\marginnote{Ziel dieses Tutorials}

Das Ziel dieses Tutorials besteht darin, einen simplen Charakter in der
Form einer Cartoon-Katze zu erstellen. HierfÃ¼r wird zunÃ¤chst das Mesh
der Cartoon-Katze erstellt. Anschliessend wird dieses Mesh texturiert,
wobei das Bemalen von eigenen Texturen innerhalb von Blender erlÃ¤utert
wird. Zudem wird der Katze anschliessend ein Fell hinzugefÃ¼gt.

\marginnote{Charaktererstellung mit Referenzbildern}

Bei der Entwicklung von Figuren fÃ¼r Filme oder Videospiele werden in den
frÃ¼hen Planungsphasen Skizzen der Charaktere erstellt. Solche Skizzen
und Vorlagen kÃ¶nnen fÃ¼r die Erstellung der 3D-Modelle im
Entwicklungsprozess verwendet werden. FÃ¼r das Beispiel in diesem
Tutorial wurde ebenfalls eine Vorlage erstellt. In der Referenzvorlage
ist die Cartoon-Katze aus allen Perspektiven abgebildet. Idealerweise
werden in solchen FÃ¤llen sechs Versionen des Referenzbildes erstellt und
in der Welt bewegt und rotiert, sodass pro Ansicht auf das Objekt ein
Referenzbild verfÃ¼gbar ist.

\marginnote{Referenzbilder sind in Datei eingebunden}

In der Datei Â«\emph{Cat\_Character}Â» wurden bereits sechs Versionen des
Referenzbildes erstellt und ausgerichtet und platziert. Um die
Referenzbilder zu sehen, muss jeweils eine entsprechende Perspektive
(beispielsweise die Vogelperspektive mit der Taste \kbd{7}) angesteuert
werden. Die Referenzbilder sind in der Collection
Â«\emph{Referenzbilder}Â» zusammengefasst. Durch ein Deaktivieren dieser
Collection im Outliner-Editor werden die Referenzbilder nicht mehr
angezeigt.

\section{Mesh-Erstellung}\label{mesh-erstellung}

\subsection{Grundformen hinzufÃ¼gen}\label{grundformen-hinzufuxfcgen}

\marginnote{Mesh-Primitive hinzufÃ¼gen}

Die Katze hat einen runden Torso und einen runden Kopf. Aus diesem Grund
ist eine Kugel das beste Primitiv, um mit der Erstellung der Katze zu
beginnen. Allerdings wird die Verwendung einer UV-Sphere im Verlaufe des
Tutorials zu Schwierigkeiten fÃ¼hren, da sich am oberen und unteren Ende
der UV-Sphere Tris befinden. Aus diesem Grund werden zunÃ¤chst die Tris
aus einer neu erstellten UV-Sphere entfernt. Dies wird allerdings
lediglich auf einer Seite der UV-Sphere durchgefÃ¼hrt, da die Tris auf
der anderen Seite der UV-Sphere noch von Nutzen sein werden.

\marginnote{Tris aus UV-Sphere entfernen}

Um die Tris aus einer UV-Sphere zu entfernen, kann zunÃ¤chst im
Â«\emph{Add}Â»-MenÃ¼ unter Â«\emph{Mesh \textbar{} UV Sphere}Â» eine neue
UV-Sphere hinzugefÃ¼gt werden. Anschliessend sollte das Kontext-MenÃ¼ zur
zuletzt durchgefÃ¼hrten Aktion in der linken unteren Ecke des
3D-Viewport-Editors ausgeklappt werden und die Anzahl Vertices und
Segmente angepasst werden. Die UV-Sphere soll viermal weniger
Subdivisions aufweisen als in den Standardeinstellungen. HierfÃ¼r wird
die Anzahl Â«\emph{Segments}Â» auf 8 gesetzt und die Anzahl Â«\emph{Rings}Â»
auf 4. Anschliessend kann die UV-Sphere von unten aus mit der
Tastenkombination \kbd{Alt} + \kbd{7} betrachtet werden. Aus dieser
Ansicht sollten nun die untersten zwei Reihen von Faces sichtbar sein.
Die unterste Reihe besteht aus acht Tris und die untere Reihe aus acht
Quads. Je zwei der Tris in der oberen Reihe kÃ¶nnten zu einem Quad
zusammengefÃ¼gt werden. HierfÃ¼r muss lediglich jedes zweite Edge zwischen
den aneinandergereihten Tris ausgewÃ¤hlt und aufgelÃ¶st werden. Dabei ist
wichtig, dass jene Edges aufgelÃ¶st werden, die nicht direkt auf den
Achsen liegen. Zum AuflÃ¶sen der Edges kann die Taste \kbd{X} zum Ã–ffnen
des LÃ¶sch-MenÃ¼s gedrÃ¼ckt werden, und anschliessend die Option
Â«\emph{Dissolve Edges}Â» ausgewÃ¤hlt werden. Dadurch werden die Edges
entfernt und die jeweiligen Tris zu Quads umgewandelt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_42/42_1_Edges_To_Delete.png}

\caption{\label{fig-1_1}Die Edges zwischen den Tris, welche nicht
entlang der Achsen verlaufen, kÃ¶nnen aufgelÃ¶st werden, damit Quads
entstehen.}

\end{figure}%

\marginnote{Subdivision-Surface-Modifier hinzufÃ¼gen}

Der bearbeiteten UV-Sphere, welche nur noch an einem Ende der Kugel Tris
aufweist, kann nun ein Subdivision-Surface-Modifier hinzugefÃ¼gt werden
und dessen Anzahl Subdivisions auf 2 erhÃ¶ht werden. Die Struktur der
Faces wird durch den Subdivision-Surface-Modifier nun unterschiedlich an
den beiden Enden verformt. An der Seite mit den Tris werden lediglich
die Edges, welche auf den Tris basieren, verformt und die
darÃ¼berliegenden Edges werden gleichmÃ¤ssig als Ringe dargestellt. Die
Seite mit den Quads wird ebenfalls verformt, sodass sich weniger
gleichmÃ¤ssige Ringe bilden. DafÃ¼r sind allerdings alle Faces Ã¤hnlich
strukturiert.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_42/42_2_Subdivisions.png}

\caption{\label{fig-1_2}Eine UV-Sphere, deren unteren Ende lediglich aus
Quads besteht und mit einem Subdivision-Surface-Modifier ausgestattet
wurde.}

\end{figure}%

\marginnote{KÃ¶rper ausrichten}

Die UV-Sphere kann nun als KÃ¶rper der Katze verwendet werden. HierfÃ¼r
wird die UV-Sphere mittig in der HÃ¶he des Torsos der Katze platziert.
Dabei sollte darauf geachtet werden, dass das Ende der UV-Sphere mit den
Tris nach oben gerichtet ist.

\marginnote{Kopf erstellen und ausrichten}

Anschliessend wird die UV-Sphere im Object-Mode mit der
Tastenkombination \kbd{Shift} + \kbd{D} dupliziert. Das Duplikat wird
als Kopf verwendet und wird deshalb mittig des Kopfes ausgerichtet. Das
Duplikat der UV-Sphere sollte zudem um 180Â° entlang der X- oder Y-Achse
rotiert werden, damit die Seite mit den Tris bei dieser Kugel nach unten
ausgerichtet ist. Zudem kann der Kopf um den Faktor 1.2 skaliert werden,
damit er dieselbe GrÃ¶sse wie auf dem Bild der Katze aufweist.

\subsection{KÃ¶rper und Kopf
verbinden}\label{kuxf6rper-und-kopf-verbinden}

\marginnote{Subdivision-Surface-Modifier anwenden}

Als NÃ¤chstes soll der Kopf mit dem KÃ¶rper der Katze verbunden werden.
Dies erfordert zunÃ¤chst allerdings noch Vorbereitungen. Zuerst wird der
Subdivision Surface-Modifier bei beiden UV-Spheres angewendet. HierfÃ¼r
muss jeweils bei dem entsprechenden Modifier das Dropdown-MenÃ¼ geÃ¶ffnet
und auf Â«\emph{Apply}Â» geklickt werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_42/42_3_Head.png}

\caption{\label{fig-1_3}Die UV-Sphere wird zur Form des Kopfes
ausgerichtet. Dabei befindet sich die Seite mit den Tris unten.}

\end{figure}%

\marginnote{ÃœberschÃ¼ssige Vertices lÃ¶schen und UV-Spheres verbinden}

Bei der UV-Sphere, welche den KÃ¶rper der Katze bildet, kÃ¶nnen nun alle
Vertices, welche sich Ã¼ber dem Hals befinden, ausgewÃ¤hlt und gelÃ¶scht
werden. Bei der UV-Sphere, welche den Kopf der Katze darstellt, kÃ¶nnen
zudem alle Vertices, welche sich unterhalb des Halses der Katze befinden
gelÃ¶scht werden. Anschliessend kÃ¶nnen die beiden UV-Spheres im
Object-Mode ausgewÃ¤hlt und mit der Tastenkombination \kbd{Ctrl} +
\kbd{J} verbunden werden. Dadurch werden die beiden UV-Spheres zu einem
einzigen Objekt verbunden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_42/42_4_Connection_Head_Body.png}

\caption{\label{fig-1_4}Die Ã¼berlappenden Vertices werden von beiden
UV-Spheres entfernt und die beiden UV-Spheres miteinander verbunden.}

\end{figure}%

\marginnote{Kopf mit KÃ¶rper verbinden}

Als NÃ¤chstes kÃ¶nnen die Vertices der beiden KugelÃ¶ffnungen ausgewÃ¤hlt
werden. Diese Vertices sollten nun miteinander verbunden werden. Im
Edge-MenÃ¼, welches mit der Tastenkombination \kbd{Ctrl} + \kbd{E}
geÃ¶ffnet werden kann, ist dies direkt mit der Option Â«\emph{Bridge Edge
Loops}Â» mÃ¶glich. Dadurch werden die Edges der unteren Kugel passend mit
den Edges der oberen Kugel verbunden.

\marginnote{Hals der Katze anpassen}

Um den Hals der Katze etwas anzupassen, wird ihm eine zusÃ¤tzliche Reihe
an Edges hinzugefÃ¼gt. Mittels der Tastenkombination \kbd{Ctrl} + \kbd{R}
wird ein Loop-Cut gestartet und damit eine neue Reihe von Edges in der
Mitte des Halses hinzugefÃ¼gt. Diese Edges kÃ¶nnen anschliessend um den
Faktor 0.85 skaliert werden.

\subsection{ExtremitÃ¤ten
hinzufÃ¼gen}\label{extremituxe4ten-hinzufuxfcgen}

\marginnote{ExtremitÃ¤ten hinzufÃ¼gen}

Der nÃ¤chste Schritt besteht darin, der Katze ExtremitÃ¤ten -- also Arme,
Beine und Ohren -- hinzuzufÃ¼gen. Diese ExtremitÃ¤ten sind auf der linken
und der rechten Seite des KatzenkÃ¶rpers identisch. Deshalb macht es
Sinn, eine symmetrische Bearbeitung der Katze vorzunehmen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_42/42_5_Head_Body_Modifiers.png}

\caption{\label{fig-1_5}Die HÃ¤lfte des Meshes wird entfernt, damit es
mit einem Mirror-Modifier fÃ¼r die weitere Bearbeitung gespiegelt werden
kann.}

\end{figure}%

\marginnote{Mirror-Modifier hinzufÃ¼gen}

Um die Katze symmetrisch bearbeiten zu kÃ¶nnen, wird ein Mirror-Modifier
verwendet. Dieser macht allerdings nur Sinn, wenn vorher alle Vertices
der einen KÃ¶rper hÃ¤lfte der Katze entfernt wurden. Deshalb werden alle
Vertices der einen KÃ¶rperhÃ¤lfte -- aber nicht diejenigen in der
KÃ¶rpermitte -- ausgewÃ¤hlt und mit der Taste \kbd{X} gelÃ¶scht.
Anschliessend kann der Mirror-Modifier hinzugefÃ¼gt werden. Im
Mirror-Modifier sollte zudem die Option Â«\emph{Clipping}Â» aktiviert
werden, damit die Vertices nicht Ã¼ber die KÃ¶permitte hinaus verschoben
werden, und es sollte Ã¼berprÃ¼ft werden, dass die Option Â«\emph{Merge}Â»
aktiviert ist. Zudem kann ein Subdivision-Surface-Modifier hinzugefÃ¼gt
werden, um die Kanten des Meshes etwas zu glÃ¤tten.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_42/42_6_Arm_Vertices.png}

\caption{\label{fig-1_6}Die Faces, aus denen der Arm extrudiert werden
soll, werden ausgewÃ¤hlt.}

\end{figure}%

\marginnote{Armansatz erstellen}

Um die Arme der Katze zu erstellen, kÃ¶nnen vier Faces auf der rechten
Seite des Torsos ausgewÃ¤hlt werden, an denen sich nachfolgend die Arme
befinden werden. Diese Faces kÃ¶nnen anschliessend mittels der Taste
\kbd{E} extrudiert und entlang der Arme der Katze platziert werden,
sodass sich ein Armansatz bildet. Hierbei wird idealerweise die
Frontalansicht verwendet, damit die Arme nicht schrÃ¤g nach hinter oder
vorne extrudiert werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_42/42_7_Arms.png}

\caption{\label{fig-1_7}Ein Ansatz fÃ¼r den Arm wird extrudiert.}

\end{figure}%

\marginnote{Arme abrunden}

Die extrudierten Arme sind aufgrund der Quads viereckig und wÃ¼rden
blockartige Arme mit abgerundeten Kanten ergeben. Deshalb werden die
Vertices in den Ecken der vier extrudierten Faces ausgewÃ¤hlt. Diese
kÃ¶nnen anschliessend um den Faktor 0.75 skaliert werden. Dadurch werden
die Ecken jeweils nÃ¤her zueinandergezogen, wÃ¤hrend die Vertices in der
Mitte der extrudierten Faces an ihrer Position bleiben. Dies fÃ¼hrt zu
einer runden Form des Armes.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_42/42_8_Arms_Round.png}

\caption{\label{fig-1_8}Die Vertices, des extrudierten Armes werden
kreisfÃ¶rmig angeordnet.}

\end{figure}%

\marginnote{Arme extrudieren}

Die Faces, welche das Ende des Armansatzes bilden, kÃ¶nnen nun wieder
ausgewÃ¤hlt und schrittweise entlang des Armes extrudiert werden. Dabei
sollten bei jedem Schritt nebst der Position auch die Rotation und die
Skalierung etwas angepasst werden, sodass die Form der Arme aus dem
Referenzbild dargestellt wird.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_42/42_9_Arms_Extrusion.png}

\caption{\label{fig-1_9}Die Arme werden entsprechend dem Referenzbild
schrittweise extrudiert.}

\end{figure}%

\marginnote{Faces subdividen}

FÃ¼r die Beine werden mehr Faces benÃ¶tigt. Deshalb wird das gesamte Mesh
ausgewÃ¤hlt und im Edge-MenÃ¼ die Option Â«\emph{Subdivide}Â» ausgewÃ¤hlt.
Dadurch werden alle Faces in kleinere Faces unterteilt, was mehr Faces
zum Erstellen der weiteren ExtremitÃ¤ten bietet.

\marginnote{Beinansatz erstellen}

Am UnterkÃ¶rper der Katze kÃ¶nnen nun 4x4 Faces ausgewÃ¤hlt werden, welche
gemeinsam die Beine der Katze bilden werden. Diese Faces kÃ¶nnen
anschliessend entlang der Beine extrudiert werden, sodass sie einen
Ansatz der Beine bilden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_42/42_10_Vertices_Legs.png}

\caption{\label{fig-1_10}Die Faces, aus denen die Beine extrudiert
werden, werden ausgewÃ¤hlt.}

\end{figure}%

\marginnote{Beinansatz rund verformen}

Auch bei den Beinen macht es Sinn, die Vertices des Ansatzes kreisfÃ¶rmig
anzuordnen. HierfÃ¼r kÃ¶nnen zunÃ¤chst alle Vertices, welche diagonal
zwischen den Ecken und in den Ecken liegen, ausgewÃ¤hlt und um den Faktor
0.7 skaliert werden. Anschliessend kÃ¶nnen die Vertices, welche an den
Kanten zwischen den Ecken und den Kantenmitten liegen, ausgewÃ¤hlt und um
den Faktor 0.9 skaliert werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_42/42_11_Legs_Circle.png}

\caption{\label{fig-1_11}Die Vertices des Beinansatzes werden
kreisfÃ¶rmig angeordnet.}

\end{figure}%

\marginnote{Beine extrudieren}

Die Faces, welche den Beinansatz bilden, kÃ¶nnen nun ausgewÃ¤hlt und
schrittweise entlang der Beine extrudiert werden. Dabei sollte, wie
bereits bei den Armen, die Position, Rotation und Skalierung der Faces
bei jedem Zwischenschritt Ã¼berprÃ¼ft werden. Damit sind die Beine bereits
erstellt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_42/42_12_Legs_Extrusion.png}

\caption{\label{fig-1_12}Die Beine werden schrittweise entlang der
Referenzvorlage extrudiert.}

\end{figure}%

\marginnote{Ohren extrudieren}

Um die Ohren der Katze zu erstellen, kÃ¶nnen 3x2 Faces ausgewÃ¤hlt werden,
aus denen die Ohren anschliessend schrittweise extrudiert werden. Dabei
sollten bei jeder Extrusion die Faces kleiner skaliert werden. Es kÃ¶nnte
etwa folgendermassen vorgegangen werden:

\begin{itemize}
\tightlist
\item
  Die Faces werden um 0.1 Meter extrudiert.
\item
  Die Faces werden um den Faktor 0.9 skaliert.
\item
  Die Faces werden um 0.1 Meter extrudiert.
\item
  Die Faces werden um den Faktor 0.7 skaliert.
\item
  Die Faces werden um 0.1 Meter extrudiert.
\item
  Die Faces werden um den Faktor 0.6 skaliert.
\item
  Die Faces werden um 0.05 Meter extrudiert.
\item
  Die Faces werden um den Faktor 0.4 skaliert.
\end{itemize}

\begin{figure}

\includegraphics{Chapters/Images/Chapter_42/42_13_Ears_Faces.png}

\caption{\label{fig-1_13}Die Faces, aus denen die Ohren extrudiert
werden, werden ausgewÃ¤hlt.}

\end{figure}%

\begin{figure}

\includegraphics{Chapters/Images/Chapter_42/42_14_Ears_Extrusion.png}

\caption{\label{fig-1_14}Die Ohren werden schrittweise entlang der
Referenzvorlage extrudiert.}

\end{figure}%

\subsection{Schwanz hinzufÃ¼gen}\label{schwanz-hinzufuxfcgen}

\marginnote{Mirror-Modifier anwenden}

Der Schwanz der Katze stellt die letzte ExtremitÃ¤t dar, welche noch
erstellt werden muss. Dieser verlÃ¤uft allerdings nicht symmetrisch und
gerade. Deshalb muss von nun an eine nicht-symmetrische Bearbeitung
erfolgen. Aus diesem Grund wird der Mirror-Modifier auf das Mesh
angewendet. Dadurch kÃ¶nnen im Edit-Mode weitere Ã„nderungen durchgefÃ¼hrt
werden, welche keine Symmetrie benÃ¶tigen.

\marginnote{Mehrere 3D-Viewport-Editoren Ã¶ffnen}

Zudem benÃ¶tigt die Erstellung des Schwanzes einen Abgleich der
Vertex-Position aus verschiedenen Ansichten heraus. HierfÃ¼r kÃ¶nnen
mehrere weitere 3D-Viewport-Editoren aus den Ecken des
3D-Viewport-Editors herausgezogen und in den jeweiligen Editoren eine
andere Kameraansicht ausgewÃ¤hlt werden. Dadurch kann in jedem Editor
betrachtet werden, was die VerÃ¤nderungen aus einer anderen Perspektive
bewirken. DafÃ¼r sollte die Ansicht von oben und von der Seite verwendet
werden. Bei Bedarf kÃ¶nnen zusÃ¤tzliche 3D-Viewport-Editore fÃ¼r die
Ansicht von hinten und von der anderen Seite verwendet werden.

\marginnote{Schwanz extrudieren}

FÃ¼r den Schwanz der Katze kÃ¶nnen 4x4 Faces ausgewÃ¤hlt werden. Diese
kÃ¶nnen zunÃ¤chst einmal extrudiert und anschliessend nach demselben
Schema wie bei den Beinen kreisfÃ¶rmig angeordnet werden. Anschliessend
kÃ¶nnen die Faces schrittweise entlang des Schwanzes extrudiert werden.
Auch hier sollte darauf geachtet werden, dass die Position, Rotation und
Skalierung der extrudierten Faces bei jedem Zwischenschritt angepasst
werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_42/42_15_Tail_Vertices.png}

\caption{\label{fig-1_15}Die Faces, aus denen der Schwanz extrudiert
wird, werden ausgewÃ¤hlt.}

\end{figure}%

\marginnote{Shade-Smooth}

Nach diesem Schritt ist die Mesh-Bearbeitung beendet. Damit das Mesh
etwas glatter aussieht, kann der Wert fÃ¼r die Subdivisions im
Subdivision-Surface-Modifier erhÃ¶ht werden. ZusÃ¤tzlich kann im
Object-Mode unter Â«\emph{Object \textbar{} Shade Smooth}Â» eine glatte
Darstellung der Faces aktiviert werden.

\section{Textur-Vorbereitung}\label{textur-vorbereitung}

\marginnote{UVs der Katze}

Durch die Bearbeitung der Katze sind die UVs des Meshes stark verzerrt
worden. Zudem Ã¼berlappen sich einige UVs, da das Mesh ursprÃ¼nglich aus
zwei UV-Spheres erstellt wurde. Deshalb sollte das UV-Mapping der Katze
verbessert werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_42/42_16_UVs.png}

\caption{\label{fig-1_16}Die UV-Map der erstellten Katze ist aufgrund
der Mesh-Bearbeitung durcheinander geraten.}

\end{figure}%

\marginnote{UVs sollten dem Detailgrad der Textur angepasst werden}

Im Verlaufe der Texturierung wird sich allerdings herausstellen, dass
das UV-Mapping in diesem Projekt besonders relevant ist. Einige Bereiche
des Meshes weisen in der Textur einen grÃ¶sseren Detailgrad auf als
andere Bereiche. Damit diese Details auch auf der Textur dargestellt
werden kÃ¶nnen, benÃ¶tigen diese mehr FlÃ¤che auf der Textur. Deshalb ist
es sinnvoll darauf zu achten, dass die entsprechenden Faces, welche mehr
Details aufweisen, auch grÃ¶ssere UVs einnehmen.

\marginnote{Seams}

Um die UVs gezielt vergrÃ¶ssern oder verkleinern zu kÃ¶nnen, muss
definiert werden, welche Bereiche grÃ¶ssere UVs benÃ¶tigen. Damit diese
FlÃ¤chen angesteuert werden kÃ¶nnen, kann im Edit-Mode definiert werden,
an welchen Edges entlang UVs auseinandergeschnitten werden sollen. Dabei
handelt es sich um die Seams der Edges. Um Seams zu definieren, mÃ¼ssen
zunÃ¤chst die entsprechenden Edges, welche mit einem Seam versehen werden
sollen, ausgewÃ¤hlt werden. Anschliessend kann das Edge-MenÃ¼ mit der
Tastenkombination \kbd{Ctrl} + \kbd{E} geÃ¶ffnet werden. Mit der Option
Â«\emph{Mark Seam}Â» wird diesen Edges anschliessend ein Seam zugewiesen.
Wenn ein Seam entfernt werden soll, kann das entsprechende Edge
ausgewÃ¤hlt und die Option Â«\emph{Clear Seam}Â» im Edge-MenÃ¼ verwendet
werden. Die Seams werden mit einer roten Markierung im Edit-Mode
dargestellt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_42/42_17_Seams.png}

\caption{\label{fig-1_17}Durch die Seams wird vorgegeben, welche Faces
in der UV-Map als gemeinsame Insel dargestellt werden sollen.}

\end{figure}%

\marginnote{Seams dem Mesh hinzufÃ¼gen}

Die wichtigen Konturen der Katze, welche mehr Details erfordern, stellen
die Ohren, die Arme, die Beine, den Schwanz und den Gesichtsbereich dar.
Dementsprechend mÃ¼ssen diese Bereiche durch die Zuweisung von Seams in
verschiedene Areale unterteilt werden. Bei den Ohren sollte zudem darauf
geachtet werden, dass ein Seam entlang des Ohres verlÃ¤uft, sodass die
Vorderseite des Ohres eine separate FlÃ¤che bildet, die mit Seams
abgegrenzt wird.

\marginnote{UV-Unwrapping}

Nachdem die Seams definiert wurden, sollten die UVs erneut erstellt
werden. HierfÃ¼r werden zunÃ¤chst alle Vertices mit der Taste \kbd{A}
ausgewÃ¤lht. Mit der \kbd{U}-Taste kann das MenÃ¼ Â«\emph{UV Mapping}Â»
geÃ¶ffnet und darin die Option Â«\emph{Unwrap}Â» ausgewÃ¤hlt werden. Dadurch
werden die UVs neu berechnet und dabei die Seams berÃ¼cksichtigt. Im
Kontext-MenÃ¼ kann zudem unter Â«\emph{Margin}Â» angegeben werden, dass ein
gewisser Abstand zwischen den einzelnen UVs im Mapping berÃ¼cksichtig
werden soll. Dieser Wert kann beispielsweise auf 0.01 gesetzt werden.

\marginnote{ZugehÃ¶rigkeit der UVs ermitteln}

Im UV-Editor kÃ¶nnen anschliessend die erstellten UVs betrachtet werden.
Dort sollte darauf geachtet werden, dass die UVs der Ohren etwas
vergrÃ¶ssert werden, sodass sie einen grÃ¶sseren Bereich innerhalb der
Textur einnehmen. Durch die Auswahl der Faces, welche die Vorderseite
der Ohren abbilden, werden deren UVs im UV-Editor sichtbar. Wenn mittels
der Taste \kbd{A} anschliessend alle Faces des Meshes ausgewÃ¤hlt werden,
erscheinen die anderen UVs ebenfalls wieder im UV-Editor. Anschliessend
kann der Mauszeiger Ã¼ber die UV-Insel der Ohren gelegt werden und die
Taste \kbd{L} gedrÃ¼ckt werden, um alle Vertices der Ohren auszuwÃ¤hlen.

\marginnote{UVs anpassen}

Die ausgewÃ¤hlten UVs der Ohren kÃ¶nnen anschliessend, so wie auch
Elemente im 3D-Viewport-Editor, mit der Taste \kbd{G} bewegt, der Taste
\kbd{S} skaliert und der Taste \kbd{R} rotiert werden. So kÃ¶nnen die UVs
der vorderen Ohrenseite vergrÃ¶ssert werden. Dabei sollte dann darauf
geachtet werden, dass sich die vergrÃ¶sserten Ohren nicht Ã¼ber anderen
UVs befinden. Bei Bedarf kÃ¶nnen auch die UV-Inseln der anderen
KÃ¶rperteile, welche mehr Details benÃ¶tigen vergrÃ¶ssert werden. Um sich
mehr Platz im UV-Raum zu verschaffen mÃ¼ssen hierfÃ¼r mÃ¶glicherweise
andere Inseln, welche weniger Details beinhalten, verkleinert werden.

\section{Textur-Erstellung}\label{textur-erstellung}

\marginnote{Material hinzufÃ¼gen}

Im nÃ¤chsten Schritt wird die Katze texturiert. HierfÃ¼r wird dem Mesh ein
neues Material hinzugefÃ¼gt und im Shader-Editor wird dem
Principled-BSDF-Shader eine Textur hinzugefÃ¼gt. HierfÃ¼r sollte der
Principled-BSDF-Shader ausgewÃ¤hlt und die Tastenkombination \kbd{Ctrl} +
\kbd{T} gedrÃ¼ckt werden. Dadurch wird ein Image-Texture-Node mitsamt
einem Mapping- und einem Texture-Coordinate-Node hinzugefÃ¼gt.

\marginnote{Neue Textur erstellen}

Im Image-Texture-Node wird nun eine neue Textur erstellt, indem auf die
SchaltflÃ¤che Â«\emph{New}Â» geklickt wird. Dadurch Ã¶ffnet sich ein
Dialogfeld, in dem der Name definiert werden kann. Unter Â«\emph{Width}Â»
und Â«\emph{Height}Â» kÃ¶nnen die GrÃ¶ssenverhÃ¤ltnisse und die AuflÃ¶sung der
Textur definiert werden. HierfÃ¼r kann die standardmÃ¤ssige AuflÃ¶sung von
1024 x 1024 Pixel verwendet werden. Zudem kann unter Â«\emph{Color}Â» eine
Farbe ausgewÃ¤hlt werden, mit der die Textur erstellt wird. In diesem
Falle kann eine graue Farbe ausgewÃ¤hlt werden. Diese wird anschliessend
die Grundfarbe der Katze darstellen.

\marginnote{Image-Editor}

Anschliessend kann der Image-Editor statt des Shader-Editors geÃ¶ffnet
werden. Dort kann anschliessend im Dropdown-MenÃ¼ links neben der
SchaltflÃ¤che Â«\emph{New}Â» die soeben erstellte Textur ausgewÃ¤hlt werden.
Diese sollte anschliessend innerhalb des Image-Editors angezeigt werden.

\marginnote{Texturen mÃ¼ssen separat abgespeichert werden}

Diese Textur stellt nun allerdings lediglich ein Bild dar, welches
innerhalb von Blender erzeugt wird. Beim Schliessen des Programmes wird
diese Textur nicht abgespeichert. Es ist deshalb jeweils notwendig,
diese Textur im Image-Editor unter Â«\emph{Image \textbar{} Save}Â» als
externe Bilddatei abzuspeichern.

HierfÃ¼r kann beispielsweise ein Bild im PNG-Format abgespeichert werden.
Auch zusÃ¤tzliche Ã„nderungen auf der Textur mÃ¼ssen unter diesem MenÃ¼punkt
nochmals abgespeichert werden. Sobald eine Textur bearbeitet wurde und
es nicht abgespeicherte Ã„nderungen gibt, wird dies mit einem Sternchen
in der MenÃ¼leiste signalisiert. Die MenÃ¼leiste Â«\emph{Image}Â» wird dann
als Â«\emph{Image*}Â» gekennzeichnet.

\marginnote{Wo wird die Textur bemalt?}

Als NÃ¤chstes geht es darum, die Textur zu bemalen. Dabei gibt es zwei
MÃ¶glichkeiten. Entweder wird im Image-Editor direkt die Textur bemalt.
HierfÃ¼r muss allerdings die Einstellung des Â«\emph{View}Â» Modes in der
linken oberen Ecke des Image-Editors auf den Â«\emph{Paint}Â»-Mode
umgestellt werden. Die zweite Methode besteht darin, dass die Textur auf
dem Mesh im 3D-Viewport-Editor bemalt wird. HierfÃ¼r muss der
Texture-Paint-Mode anstelle des Object- oder Edit-Modes ausgewÃ¤hlt
werden. Diese Methode ist in der Regel praktischer. UnabhÃ¤ngig davon,
welche der beiden Methoden verwendet wird, sind die Tools identisch.

\marginnote{Toolbar des Texture-Paint-Modes}

In der Toolbar des Texture-Paint-Modes finden sich ein paar Werkzeuge,
um die Textur zu bemalen. Mittels der Option Â«\emph{Draw}Â» kann etwa
gemalt werden und mittels der Option Â«\emph{Fill}Â» kann eine FarbflÃ¤che
mit einer Farbe gefÃ¼llt werden. Zudem besteht auch die MÃ¶glichkeit,
FarbÃ¼bergÃ¤nge zu verwischen mittels Â«\emph{Smear}Â» oder weicher zu
gestalten mittels Â«\emph{Soften}Â».

\begin{figure}

\includegraphics{Chapters/Images/Chapter_42/42_18_Toolbar_Texture_Paint.png}

\caption{\label{fig-1_18}Icons in der Tool-Bar des Texture-Paint-Modes.}

\end{figure}%

\marginnote{Brush-Settings}

In der Sidebar auf der rechten Seite des 3D-Viewport-Editors finden sich
zudem weitere Einstellungen zu dem ausgewÃ¤hlten Werkzeug unter dem
Reiter Â«\emph{Brush Settings}Â». So kÃ¶nnen an dieser Stelle die
anzuwendende Farbe und die StÃ¤rke, mit der die Farbe auf die Textur
angewendet wird, definiert werden. Im Bereich Â«\emph{Radius}Â» kann zudem
der Radius des Pinsels definiert werden. Dies kann allerdings, wie im
Sculpt-Mode, auch mit der Taste \kbd{F} und einer Mausbewegung
geschehen. Dabei fÃ¼hrt eine Mausbewegung nach links zu einer
Verkleinerung des Radius und eine Mausbewegung nach rechts zu einer
VergrÃ¶sserung des Radius.

\marginnote{Farbpaletten}

Wenn eine Farbe hÃ¤ufiger verwendet wird, kann eine Farbpalette erstellt
werden und diese Farbe der Farbpalette hinzugefÃ¼gt werden. Unter dem
Reiter Â«\emph{Color Palette}Â» kann mit der SchaltflÃ¤che Â«\emph{New}Â»
eine neue Farbpalette hinzugefÃ¼gt werden, und mittels der
Â«+Â»-SchaltflÃ¤che die aktuell ausgewÃ¤hlte Farbe der Farbpalette
hinzugefÃ¼gt werden. Durch einen Klick auf eine Farbe innerhalb der
Farbpalette wird diese automatisch ausgewÃ¤hlt.

\marginnote{Texture-Slots}

Eine wichtige Einstellung findet sich im Reiter Â«\emph{Texture Slots}Â».
Dort wird die aktuell bearbeitete Textur angezeigt. Wenn sich keine
VerÃ¤nderungen in der Textur des Meshes bei der Bearbeitung ergeben,
sollte Ã¼berprÃ¼ft werden, ob die korrekte Textur in diesem Slot
ausgewÃ¤hlt ist.

\marginnote{Linien stabilisieren}

Innerhalb des Reiters Â«\emph{Stroke}Â» der Â«\emph{Brush Settings}Â» findet
sich eine nÃ¼tzliche Einstellung zur Erstellung von Linien. Die Option
Â«\emph{Stabilize Stroke}Â» hilft bei der Stabilisierung der Maus beim
Zeichnen. Dabei wird eine Linie jeweils mit einer VerzÃ¶gerung
gezeichnet. WÃ¤hrend dieser VerzÃ¶gerung wird die derweil zurÃ¼ckgelegte
Bewegung der Maus berechnet und geglÃ¤ttet. Dadurch ergeben sich klarere
Linien.

\marginnote{Katze bemalen}

Nun kann die Katze bemalt werden. HierfÃ¼r mÃ¼ssen jeweils die korrekten
Farben ausgewÃ¤hlt werden und die entsprechenden Bereiche auf dem Objekt
mit dem Draw-Tool bemalt werden. Die bemalten Bereiche werden
anschliessend direkt auf die Textur Ã¼bertragen, anhand der UVs. Sollten
sich mehrere UVs Ã¼bereinander befinden, werden automatisch auch die
anderen UVs mit bemalt.

\marginnote{Symmetrisches bemalen}

Viele Aspekte der Katze, welche bemalt wird, erfolgen symmetrisch. Die
weissen FÃ¼sse, die weissen Arme, die Augen, die Nase und die Ohren
sollten auf beiden Seiten symmetrisch bemalt werden. Im Reiter
Â«\emph{Symmetry}Â» der Sidebar kann eine Achse aktiviert werden, damit
eine symmetrische Bearbeitung erfolgt. In diesem Fall kann die X-Achse
ausgewÃ¤hlt werden, damit gleichzeitig beide Seiten des Meshes bearbeitet
werden. Um die Schwanzspitze weiss einzufÃ¤rben, sollte jeweils darauf
geachtet werden, dass die Symmetrie wieder ausgeschaltet wird.

\marginnote{Maximaler Detailgrad}

Der Detailgrad, mit dem auf die Textur gemalt werden kann, hÃ¤ngt nebst
der Anordnung der UVs auch von der AuflÃ¶sung der Textur ab. Je hÃ¶her die
erstellte Textur aufgelÃ¶st ist, desto detaillierter kann gezeichnet
werden. Wenn die ZeichnungsflÃ¤che auf der Textur zu klein ist und somit
mehrere Pixel Ã¼berproportional auf das Mesh angewendet werden, kann dies
dazu fÃ¼hren, dass verformte Zeichnungen entstehen. Eine hÃ¶her aufgelÃ¶ste
Textur bringt allerdings auch den Nachteil, dass es abhÃ¤ngig von der
Rechenleistung des Computers zu lÃ¤ngeren Wartezeiten wÃ¤hrend des
Bemalens der Textur kommt.

\marginnote{Textur abspeichern}

Sobald die Katze fertig bemalt wurde, sollte unbedingt daran gedacht
werden, die Textur im Image-Editor nochmals zu speichern. Ansonsten geht
die erstellte Textur beim Beenden von Blender verloren.

Ãœbung 18: Katze bemalen

\textbf{Ãœbung 18.1}

FÃ¼gen Sie einen zweiten Image-Texture-Node im Material der Katze ein und
verbinden Sie diesen mit dem Color-Input des Principled-BSDF-Shaders.
Erstellen Sie eine neue Textur und bemalen Sie die Katze nach eigenen
Vorstellungen.

\section{Die Katze geht zum Friseur}\label{die-katze-geht-zum-friseur}

\marginnote{Zweites Material der Katze hinzufÃ¼gen}

Zu guter Letzt wird noch aufgezeigt, wie der Katze Haare hinzugefÃ¼gt
werden kÃ¶nnen. HierfÃ¼r wird der Katze ein zusÃ¤tzliches Material
hinzugefÃ¼gt. Diesem Material kann ebenfalls die Textur der Katze als
Grundfarbe zugewiesen werden. Dieses Material wird anschliessend das
Material der Katzenhaare darstellen.

\marginnote{Haare hinzufÃ¼gen}

Im Particle-Properties-Reiter des Properties-Editors kann anschliessend
ein neues Partikelsystem auf die Katze angewendet werden und dafÃ¼r die
Einstellung Â«\emph{Hair}Â» verwendet werden. Die Anzahl der Haare kann
dabei deutlich reduziert werden, da anschliessend manuell weitere Haare
hinzugefÃ¼gt werden. Zudem kann die LÃ¤nge der Haare ebenfalls reduziert
werden, beispielsweise auf 0.1 Meter. Ebenso kÃ¶nnen die Anzahl Segmente
der Haare reduziert werden, etwa auf den Wert 3. Unter dem Reiter
Â«\emph{Render}Â» kann im Dropdown-MenÃ¼ Â«\emph{Material}Â» das neu
erstellte Material fÃ¼r die Haare ausgewÃ¤hlt werden. Dieses wird
anschliessend auf die erstellen Haare angewendet.

\marginnote{Particle-Edit-Mode}

Durch das neu hinzugefÃ¼gte Haar-Partikelsystem ist im 3D-Viewport-Editor
nun ein neuer Bearbeitungsmodus verfÃ¼gbar. Statt des Object-Modes wird
deshalb nun der Particle-Edit-Mode verwendet. Mit dieser Option kÃ¶nnen
die Haare eines Objektes innerhalb des 3D-Viewport-Editors bearbeitet
werden. Durch diese Bearbeitung gehen allerdings einige
EinstellungsmÃ¶glichkeiten im Particle-Properties-Editor verloren.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_42/42_19_Toolbar_Particles_Editor.png}

\caption{\label{fig-1_19}Icons in der Toolbar des Particle-Edit-Modes.}

\end{figure}%

\marginnote{Speichern nicht vergessen}

An dieser Stelle ist es allerdings je nach Rechenleistung empfehlenswert
das aktuelle Blender-Projekt nochmals abzuspeichern, falls die Hardware
nicht mehr mit den Partikeln mithalten kann. Zudem sollte auch in den
nÃ¤chsten Bearbeitungsschritten jeweils zwischengespeichert werden.

\marginnote{Haare hinzufÃ¼gen}

In der Toolbar des Particle-Properties-Editors findet sich die Option
Â«\emph{Add}Â». Wenn diese Option ausgewÃ¤hlt ist, kÃ¶nnen neue Haare mit
der Maus auf dem Mesh platziert werden. In der Sidebar lassen sich zudem
der Radius und die Anzahl Haare, die gemeinsam platziert werden,
einstellen. Mittels der Option Â«\emph{Keys}Â» kann definiert werden, wie
viele Segmente die hinzugefÃ¼gten Haare aufweisen sollen. HierfÃ¼r sollten
bereits 3 Segmente ausreichen.

\marginnote{HaarlÃ¤nge bearbeiten}

Mittels der Funktion Â«\emph{Length}Â» kann die LÃ¤nge der Haare variiert
werden. In der Sidebar kann dabei ausgewÃ¤hlt werden, ob man gerade Haare
verlÃ¤ngern oder kÃ¼rzen mÃ¶chte. Ist die Funktion Â«\emph{Length Mode}Â» auf
Â«\emph{Grow}Â» gestellt, werden die Haare verlÃ¤ngert, und wenn sie auf
Â«\emph{Shrink}Â» gestellt ist, werden die Haare verkÃ¼rzt. Um Haare ganz
zu entfernen, kann zudem in der Toolbar die Funktion Â«\emph{Cut}Â»
ausgewÃ¤hlt werden.

\marginnote{Haare kÃ¤mmen}

Mit der Funktion Â«\emph{Comb}Â» kÃ¶nnen diese Haare in verschiedene
Richtungen gekÃ¤mmt werden. Je mehr Segmente dem Haar hinzugefÃ¼gt wurden,
desto mehr WinkelverÃ¤nderungen kÃ¶nnen durch das KÃ¤mmen erzielt werden
und umso glatter kÃ¶nnen die Haare verformt werden.

Ãœbung 19: Particle-Edit-Mode

\textbf{Ãœbung 19.1}

Frisieren Sie die Katze im Particle-Edit-Mode.

\chapter{Was ist Rigging?}\label{was-ist-rigging}

\marginnote{Posen als verschiedene Mesh-ZustÃ¤nde}

Ein 3D-Charakter kann im Unterschied zu anderen Objekten --
beispielsweise einem Stuhl -- verschiedene Posen einnehmen. Dadurch
kÃ¶nnen Informationen, beispielsweise Ã¼ber die aktuelle Handlung des
Charakters oder dessen scheinbare Stimmung vermittelt werden. Jede
dieser Posen stellt dabei einen spezifischen Zustand des
Charakter-Meshes dar. Es wÃ¤re mÃ¶glich, das Mesh fÃ¼r eine Pose abzuÃ¤ndern
und verschiedene Meshes fÃ¼r verschieden Posen zu erstellen (z.B. ein
Mesh fÃ¼r eine winkende Pose eines Charakters, ein Mesh fÃ¼r eine
nachdenkliche Pose eines Charakters, usw.). Dies fÃ¼hrt allerdings dazu,
dass es fÃ¼r jede Pose ein einzelnes Mesh braucht. Zudem sind dadurch
auch keine Animationen des Meshes mÃ¶glich.

\marginnote{Rigging}

Um diese Probleme zu lÃ¶sen, kÃ¶nnen den Charakteren -- aber auch generell
Meshes, welche verschiedene Posen einnehmen kÃ¶nnen -- mit einem Rigging
versehen werden. Dabei wird ein GerÃ¼st erstellt, anhand dessen sich das
Mesh verformen lÃ¤sst. Dieses GerÃ¼st stellt ein Skelet dar, mit
verschiedenen Knochen, anhand deren sich das Mesh verformen lÃ¤sst.

\marginnote{Skelet}

Abbildung 1 zeigt einen Charakter mit einem dazugehÃ¶rigen Skelet. Indem
der Charakter anschliessend diesem Skelet zugewiesen wird, kann er
anhand der einzelnen Knochen bewegt und posiert werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_43/43_1_Character_Mesh.png}

\caption{\label{fig-1_1}Das Mesh eines Charakters, mit einem
dazugehÃ¶rigen Skelet fÃ¼r das Rigging.}

\end{figure}%

\marginnote{Knochen}

Die einzelnen Knochen des Skelets werden als Oktaeder -- ein Objekt mit
vier FlÃ¤chen -- dargestellt. Am Anfang und am Ende des Oktaeders
befinden sich je eine Kugel, welche den Kopf oder den Schwanz des
Oktaeders darstellen. Diese Kugeln werden jeweils verwendet, um Gelenke
darzustellen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_43/43_2_Bone.png}

\caption{\label{fig-1_2}Ein Knochen.}

\end{figure}%

\marginnote{Knochen als Grundlage fÃ¼r Verformungen}

Die Knochen ermÃ¶glichen eine Verformung des Meshes entlang der LÃ¤nge der
jeweiligen Knochen. Der Knochen selbst, kann allerdings nicht verbogen
werden. Dies entspricht auch den Bewegungsmustern von realen Menschen.
Menschliche Verbiegungen ergeben sich jeweils an den Gelenken zwischen
mehreren Knochen und werden dann entlang der Knochen ausgerichtet. Ein
Knochen selbst wird allerdings (zumindest bei gesunden Bewegungen) nicht
verformt.

\chapter{Objekte mit Armaturen
verformen}\label{objekte-mit-armaturen-verformen}

\marginnote{Datei Â«SchwimmnudelÂ»}

In der Datei Â«SchwimmnudelÂ» ist ein langgezogener Zylinder vorzufinden
-- Ã¤hnlich einer Schwimmnudel. Dieser kann mittels eines Skelets mit
Knochen wie eine Schwimmnudel dynamisch verformt werden. So kann die
Schwimmnudel etwa verbogen werden.

\section{Skelet erstellen}\label{skelet-erstellen}

\marginnote{Skelet hinzufÃ¼gen}

Um ein neues Skelet zu erstellen, kann im Â«\emph{Add}Â»-MenÃ¼ die Option
Â«\emph{Armature \textbar{} Single Bone}Â» ausgewÃ¤hlt werden. Dadurch wird
ein Armature-Objekt erstellt mit einem einzelnen Knochen erstellt.
Dieses Objekt kann danach im Edit-Mode bearbeitet werden. Dabei ist es
ratsam, den RÃ¶ntgenblick mittels Â«\emph{Toggle X Ray}Â» zu aktivieren.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_44/44_1_Pool_Noodle.png}

\caption{\label{fig-1_1}Die Schwimmnudel und ein hinzugefÃ¼gter Knochen.}

\end{figure}%

\marginnote{Auswahl von Knochenelementen}

Im Edit-Mode kÃ¶nnen nun drei Elemente des Knochens ausgewÃ¤hlt werden:

\begin{itemize}
\tightlist
\item
  Â«\textbf{\emph{Head}}Â»: Dabei handelt es sich um den Kopf des
  Knochens, welcher sich jeweils am Ende des kÃ¼rzeren Teiles des
  Knochens befindet. Seine Position ist in der Sidebar unter dem Reiter
  Â«\emph{Head}Â» aufgelistet
\item
  Â«\textbf{\emph{Tail}}Â»: Dabei handelt es sich um den Schwanz des
  Knochens, welcher sich jeweils am Ende des langgezogenen Teiles des
  Knochens befindet. Seine Position ist in der Sidebar unter dem Reiter
  Â«\emph{Tail}Â» aufgelistet.
\item
  Oktaeder: Durch die Auswahl des Oktaeders werden der dazugehÃ¶rige Kopf
  und der dazugehÃ¶rige Schwanz ebenfalls mit ausgewÃ¤hlt. Der Oktaeder
  kann nicht unabhÃ¤ngig von diesen beiden Gelenken ausgewÃ¤hlt werden.
\end{itemize}

\marginnote{Knochen extrudieren mittels \kbd{E}}

Der Schwanz des hinzugefÃ¼gten Knochens kann nun entlang der X-Achse
platziert werden. Dabei sollte darauf geachtet werden, dass er sich
innerhalb des Meshes der Schwimmnudel befindet (beispielsweise an der
Position X = 0, Y = 0, Z = 0.5). Um einen neuen Knochen hinzuzufÃ¼gen,
wird nun der Schwanz ausgewÃ¤hlt werden und ein neuer Knochen mittels der
Taste \kbd{E} extrudiert. Der neue Knochen kann anschliessend entlang
der X-Achse weiter entlang dem Mesh platziert werden (beispielsweise X =
0, Y = 0, Z = 1).

\marginnote{Kopf/Schwanz zwischen Knochen}

Der neu extrudierte Knochen ist direkt mit dem alten Knochen Ã¼ber das
dazwischen liegende Gelenk verbunden. Der Kopf des neuen Knochens stellt
dabei den Schwanz des alten Knochens dar. Dementsprechend wird die
Ausrichtung der Knochen durch eine Verschiebung des Kopfes/Schwanzes
zwischen den Knochen verÃ¤ndert. Um einen Knochen von den mit ihm
verbundenen Knochen zu lÃ¶sen, kann der Befehl Â«\emph{Split}Â» mittels der
Taste \kbd{Y} ausgefÃ¼hrt werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_44/44_2_Bone_Placement.png}

\caption{\label{fig-1_2}Der Knochen wird entlang der Schwimmnudel
platziert.}

\end{figure}%

\marginnote{VollstÃ¤ndiges Skelett extrudieren}

Um ein vollstÃ¤ndiges Skelett zu erhalten, kÃ¶nnen nun weitere Knochen
entlang der X-Achse extrudiert werden. Dies sollte anschliessend
ebenfalls entlang der anderen Seite der Schwimmnudel erfolgen. Am
Schluss sollte das Skelet Ã¤hnlich der Abbildung 3 aussehen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_44/44_3_Bone_Placements.png}

\caption{\label{fig-1_3}Der Knochen wird entlang der Schwimmnudel
platziert.}

\end{figure}%

\section{Mesh dem Skelet zuweisen}\label{mesh-dem-skelet-zuweisen}

\marginnote{Verbindung von Mesh und Skelet}

Als NÃ¤chstes geht es darum, das Mesh der Schwimmnudel und das Skelet
miteinander zu verbinden. Das Ziel ist es, dass das Mesh basierend auf
den VerÃ¤nderungen im Skelet verformt wird. Deshalb wird das Mesh als
Kind des Skeletes definiert.

\marginnote{Parenting}

Um das Mesh als Kind des Skeletes zu definieren, mÃ¼ssen das Mesh und das
Skelet nacheinander ausgewÃ¤hlt werden. Dabei ist die Reihenfolge zu
beachten, sodass das Skelet als letztes Objekt ausgewÃ¤hlt wird. In
diesem Falle ist das Skelet nun das aktive Objekt. Mittels der
Tastenkombination \kbd{Ctrl} + \kbd{P} kann beim Mauszeiger das MenÃ¼
Â«\emph{Set Parent to}Â» geÃ¶ffnet werden, in dem nun die Option
Â«\emph{Armature Deform \textbar{} with automatic Weights}Â» ausgewÃ¤hlt
werden kann. Dadurch wird das Mesh nun hierarchisch als Kind des
Skeletes definiert. Als Folge dessen, ist das Mesh der Schwimmnudel nun
auch im Outliner-Editor im Dropdown-Bereich des Skelets aufgelistet.

\section{Skelet verformen}\label{skelet-verformen}

\marginnote{Pose-Mode}

Objekte des Typs Â«\emph{Armature}Â» verfÃ¼gen nebst dem Object- und dem
Edit-Mode Ã¼ber einen weiteren Bearbeitungsmodus. Dabei handelt es sich
um den Pose-Mode. Dieser kann im Dropdown-MenÃ¼ zur Auswahl des
Bearbeitungsmodus ausgewÃ¤hlt werden, sobald das Skelet ausgewÃ¤hlt wird.

\marginnote{Pose verformen}

Innerhalb des Pose-Mode sind nun ebenfalls alle Knochen auswÃ¤hlbar. Der
Kopf und der Schwanz des Knochens werden jeweils automatisch mit
ausgewÃ¤hlt. Anders als im Edit-Mode kÃ¶nnen allerdings nur die Knochen
als Ganzes ausgewÃ¤hlt werden. Durch eine VerÃ¤nderung der Knochen in
ihrer Rotation wird anschliessend ebenfalls das Mesh entsprechend dieser
Knochen verformt.

\marginnote{Schwimmnudel verbiegen}

Um die Schwimmnudel zu biegen, kÃ¶nnen alle Knochen auf der einen Seite
des Skelets ausgewÃ¤hlt werden und um einen bestimmten Wert rotiert
werden. Damit dieselbe Verformung auch auf der anderen Seite vollzogen
wird, sollten auch diese Knochen ausgewÃ¤hlt werden und um den gleichen
Betrag in die entgegengesetzte Richtung rotiert werden. Um dies zu
erzielen, muss lediglich ein negativer Betrag eingegeben werden.

\marginnote{Vertices fÃ¼r Verformung benÃ¶tigt}

Die Verformung des Meshes erfolgt anhand der Struktur des Meshes. Wenn
sich entlang mehrerer Knochen keine Vertices befinden, kÃ¶nnen die
Strukturen der Knochen entlang dieser FlÃ¤che nicht mitberÃ¼cksichtigt
werden. Deshalb ist darauf zu achten, dass im Mesh genug Vertices
entlang der dazugehÃ¶rigen Knochen aufzufinden sind.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_44/44_4_Arched_Pool_Noodle.png}

\caption{\label{fig-1_4}Die gebogene Schwimmnudel.}

\end{figure}%

\marginnote{Armature-Modifier}

Meshes, welche einer Armature zugewiesen wurde, erhalten jeweils einen
neuen Modifier. Dabei handelt es sich um den Â«\emph{Armature}Â»-Modifier,
welcher jeweils in der dritten Spalte der Modifier-Auswahl aufzufinden
ist. Sobald ein Mesh einem Armature-Objekt zugewiesen wurde, wird diesem
automatisch der Armature-Modifier hinzugefÃ¼gt. Dieser Modifier kann
anschliessend innerhalb der Reihenfolge der Modifier platziert werden.
So kÃ¶nnen beispielsweise mittels eines Subdivision Surface-Modifiers
nach dem Armature-Modifier die Verformungen durch die Posen geglÃ¤ttet
werden.

\section{Posen abspeichern}\label{posen-abspeichern}

\marginnote{Posen-Bibliothek}

Um eine erstellte Pose schnell aufrufen zu kÃ¶nnen, lassen sich
verschiedene Posen in einer Posen-Bibliothek abspeichern. Diese sind im
Reiter Â«\emph{Object-Data-Properties}Â» von Armaturen aufzufinden. Unter
dem Reiter Â«\emph{Pose Library}Â» kann anschliessend eine neue
Posen-Bibliothek erstellt werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_44/44_5_Icon_Object_Data_Properties_Armature.png}

\caption{\label{fig-1_5}Icon des Reiters Â«\emph{Object Data Properties}Â»
bei Armaturen.}

\end{figure}%

\marginnote{Posen abspeichern}

Um eine neue Pose abzuspeichern, mÃ¼ssen im Pose-Mode jeweils alle
Knochen ausgewÃ¤hlt werden, deren Anordnung fÃ¼r eine Pose gespeichert
werden sollen. Um die aktuelle Anordnung abzuspeichern, kann
anschliessend auf die SchaltflÃ¤che Â«+Â» geklickt werden. Anschliessend
wird eine neue Pose innerhalb der Posen-Bibliothek erstellt. Dabei ist
zu beachten, dass lediglich die ausgewÃ¤hlten Knochen fÃ¼r diese Pose
abgespeichert werden. Sind nicht alle relevanten Knochen ausgewÃ¤hlt,
wird die entsprechende Pose nur unvollstÃ¤ndig abgespeichert. Mittels der
SchaltflÃ¤che Â«\emph{Apply Pose Library Pose}Â» wird zudem eine bereits
ausgewÃ¤hlte Pose aufgerufen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_44/44_6_Icon_Apply_Pose_Library_Pose.png}

\caption{\label{fig-1_6}Icon fÃ¼r die SchaltflÃ¤che ``\emph{Apply Pose
Library Pose}''.}

\end{figure}%

\chapter{Charakter-Rigging}\label{charakter-rigging}

\section{Charakter-Rigging mittels
Rigify}\label{charakter-rigging-mittels-rigify}

\subsection{Skelet erstellen}\label{skelet-erstellen-1}

\marginnote{Skelet fÃ¼r Charakteren}

Das Prinzip der Knochenerstellung fÃ¼r Armaturen kann auch verwendet
werden, um ein Skelet fÃ¼r Charakteren zu erstellen. Dabei handelt es
sich allerdings um einen etwas aufwÃ¤ndigeren Prozess, da deutlich mehr
Knochen benÃ¶tigt werden. Nebst den Knochen fÃ¼r Arme, HÃ¤nde, Beine und
FÃ¼sse kÃ¶nnen auch Knochen verwendet werden, um das Gesicht zu verformen
und so Charakteren mit unterschiedlicher Mimik darzustellen.

\marginnote{Datei Â«CharakterÂ»}

Die Datei Â«CharakterÂ» beinhaltet einen Charakter, welcher mittels
MakeHuman erstellt wurde. Um diesen Charakter zu posieren, wird nun ein
entsprechendes Skelet benÃ¶tigt.

\marginnote{Add-on Â«RigifyÂ»}

Mittels dem Add-on Â«RigifyÂ» kann direkt eine Vorlage fÃ¼r ein Skelet
geladen werden. Dies erspart bereits einige Schritte bei der Skelet
Erstellung. Das entsprechende Add-on muss zunÃ¤chst in den Einstellungen
(Â«\emph{Edit \textbar{} Preferences}Â») unter Â«\emph{Add-ons}Â» aktiviert
werden. Durch das Aktivieren dieses Add-ons stehen im Â«\emph{Add}Â»-MenÃ¼
unter dem Reiter Â«\emph{Armature}Â» nun weitere Optionen zur VerfÃ¼gung.
Statt eines einzelnen Knochens kann nun etwa direkt ein ganzes
menschliches Skelett mittels Â«\emph{Human (Meta-Rig)}Â» hinzugefÃ¼gt
werden. Zudem sind unter Â«\emph{Animals}Â» auch SkeletefÃ¼r verschiedene
Tiere auffindbar.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_45/45_1_Add_on_Rigify.png}

\caption{\label{fig-1_1}Das Add-on ``\emph{Rigify}'' muss zunÃ¤chst in
den Eistellungen aktiviert werden.}

\end{figure}%

\marginnote{Basic Human Armature}

Unter der Option Â«\emph{Basic \textbar{} Basic Human (Meta-Rig)}Â» ist
eine vereinfachte Version eines menschlichen Skeletes vorzufinden,
welches auf Knochen im Gesicht verzichtet. Dieses Skelet kann
beispielsweise verwendet werden, wenn lediglich die ExtremitÃ¤ten eines
Charakters posiert werden sollen. FÃ¼r die ersten Schritte mit einem
menschlichen Skelet ist dies wohl die einfachere Variante.

\marginnote{Knochen anordnen}

Das hinzugefÃ¼gte Skelet sollte genaue an derselben Position hinzugefÃ¼gt
werden, an der sich der Ursprung des Charakters befindet. Zudem sollte
der Charakter keine Transformationen (beispielsweise Position,
Skalierung oder Rotation) aufweisen. Anschliessend kann das Skelet im
Edit-Mode bearbeitet werden, sodass die einzelnen Knochen das jeweilige
KÃ¶rperteil abbilden. Wenn die Viewport-Overlays aktiviert sind, wird in
der oberen linken Ecke jeweils beschrieben, wofÃ¼r der ausgewÃ¤hlte
Knochen steht. Wichtig ist dabei, dass keine Knochen gelÃ¶scht oder
entfernt werden.

\marginnote{Symmetrische Bearbeitung}

Damit die Knochen jeweils nur auf einer Seite angeordnet werden mÃ¼ssen,
kann die Option Â«\emph{X-Axis Mirror}Â» in der Sidebar unter dem Reiter
Â«\emph{Tool}Â» aktiviert werden. Dadurch werden automatisch die Knochen
auf der gegenÃ¼berliegenden Seite entsprechend mit bearbeitet. Dies
ermÃ¶glicht eine symmetrische Bearbeitung des Skelets und halbiert den
Aufwand bei der Ausrichtung der Knochen.

\marginnote{Knochen anordnen}

Am Schluss sollten alle Knochen dem Mesh angepasst worden sein. Dabei
sollten sich diese Knochen jeweils innerhalb des Meshes auffinden.
Abbildung 2 zeigt eine mÃ¶gliche Anordnung der Knochen.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_45/45_2_Character_Skeleton.png}

\caption{\label{fig-1_2}Der Charakter mit einem Skelet.}

\end{figure}%

\subsection{Rig generieren}\label{rig-generieren}

\marginnote{Automatisierung durch Rigify}

Durch das Rigify-Add-on werden nicht nur Vorlagen fÃ¼r Armaturen zur
VerfÃ¼gung gestellt, sondern auch Automatisierungsprozesse fÃ¼r das
Character-Rigging. Nebst der Zuweisung des Meshes zum Skelett lassen
sich noch eine Reihe weiterer Verfeinerungen vornehmen, die jedoch
deutlich komplexer sind. Durch das Rigify-Add-on lassen sich einige
dieser Prozesse im Hintergrund automatisch durchfÃ¼hren.

\marginnote{Rig erstellen}

In den Object-Data-Properties des Skelets, welches sich im
Properties-Editor befinden, sind durch das Aktivieren des Rigify-Add-ons
einige weitere Reiter erstellt werden. Im Reiter Â«\emph{Rigify Buttons}Â»
kann Ã¼ber die SchaltflÃ¤che Â«\emph{Generate Rig}Â» aus dem Skelett ein Rig
erstellt werden. Damit diese SchaltflÃ¤che ersichtlich ist, muss das
Skelet im Object-Mode ausgewÃ¤hlt sein.

\marginnote{Neue Objekte nach Rig-Erstellung}

Nach der Erstellung des Rigs erscheint ein neues Skelet im
3D-Viewport-Editor. Dieses besteht nicht aus Knochen, sondern aus
verschiedenen Formen. Bei diesem Skelet handelt es sich nun um den
erstellten Rig. Dieser Rig verfÃ¼gt Ã¼ber zusÃ¤tzliche Funktionen und
angepasste Steuerungen im Vergleich zu den normalen Knochen. Im Outliner
ist zudem eine neue Collection entstanden (Â«\emph{WGTS\_rig}Â»). Dabei
handelt es sich um Datenstrukturen, welche fÃ¼r den Rig benÃ¶tigt werden.
Daher sollten die entsprechenden Objekte nicht gelÃ¶scht werden.
Allerdings kann die Collection weiterhin deaktiviert bleiben. Der
Meta-Rig als solches wird von nun an nicht mehr benÃ¶tigt und kann
ebenfalls in einer deaktivierten Collection versteckt werden.

\marginnote{Charakter dem Rig zuweisen}

Nun kann der Charakter als Kind dem Rig hinzugefÃ¼gt werden. HierfÃ¼r wird
nacheinander das Mesh des Charakters und der Rig ausgewÃ¤hlt. Dabei
sollte der Rig anschliessend das aktive Objekt sein. Sollte ein
Charakter aus mehreren Teilen bestehen, so mÃ¼ssen alle Mesh-Teile des
Charakters ausgewÃ¤hlt werden und zuletzt der Rig, damit dieser das
aktive Objekt darstellt. Mittels der Tastenkombination \kbd{Ctrl} +
\kbd{P} kann anschliessend das MenÃ¼ Â«\emph{Set Parent to}Â» geÃ¶ffnet und
die Option Â«\emph{Armature Deform \textbar{} with automatic Weights}Â»
ausgewÃ¤hlt werden.

\marginnote{Rig-Objekte}

Wenn nun der Rig ausgewÃ¤hlt und in den Pose-Mode gewechselt wird, kann
der Charakter nun anhand der verschiedenen Formen innerhalb des Rigs
posiert werden. In der Sidebar sind durch das Rigify-Add-on zwei neue
Reiter unter Â«\emph{Item}Â» erstellt worden: Â«\emph{Rig Main Properties}Â»
und Â«\emph{Rig Layers}Â». Die verschiedenen KÃ¶rperteile des Rigs werden
unter dem Reiter Â«\emph{Rig Layers}Â» aufgelistet. Dabei kÃ¶nnen einzelne
Symbole ausgeblendet werden, damit nur die relevanten Formen des Rigs
angezeigt werden.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_45/45_3_Character_Rig.png}

\caption{\label{fig-1_3}Der Charakter mit dem dazugehÃ¶rigen Rig.}

\end{figure}%

\marginnote{Arten von Rig-Strukturen}

FÃ¼r einzelne KÃ¶rperteile werden mehrere Elemente in den Rig-Layers
aufgelistet, beispielsweise fÃ¼r die Arme. In Klammern werden die
Unterschiede dieser Formen beschrieben.

\begin{itemize}
\tightlist
\item
  Â«\textbf{\emph{IK}}Â»: Die AbkÃ¼rzung IK steht fÃ¼r Inverse Kinematics.
  Dies stellt eine alternative Form zur bisher verwendeten Forward
  Kinematics dar. Strukturen im Rig, welche sich der Inverse Kinematics
  bedienen, werden jeweils in roter Farbe dargestellt.
\item
  Â«\textbf{\emph{FK}}Â»: Die AbkÃ¼rzung FK steht fÃ¼r Forward Kinematics.
  Dies stellt eine alternative Form zur Inverse Kinematics dar.
  Strukturen im Rig, welche sich der Forward Kinematics bedienen, werden
  jeweils in grÃ¼ner Farbe dargestellt.
\item
  Â«\textbf{\emph{Tweak}}Â»: Die Strukturen aus der Kategorie Tweak werden
  fÃ¼r genauere Anpassungen verwendet. Die entsprechenden Elemente werden
  in blauer Farbe dargestellt.
\end{itemize}

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Bei der Forward Kinematics mÃ¼ssen alle Knochen und Gelenke einzeln posiert werden. Soll die Hand eines Charakters etwa eine bestimmte Position einnehmen, mÃ¼ssen die Schulter, der Oberarm, der Ellbogen und der Unterarm so angepasst und verschoben werden, damit die Hand am Schluss an der korrekten Position liegt. Mittels Inverse Kinematics kann lediglich die Hand verschoben werden und die anderen Knochen und Gelenke werden automatisch ausgerichtet. Dies erleichtert den Prozess des Posierens deutlich.
\end{tipp}

\marginnote{Inverse Kinematics}

Der grosse Vorteil des Rigs, welcher mit Rigify erstellt wurde, besteht
darin, dass Inverse Kinematics zur VerfÃ¼gung steht. Per Default ist
dementsprechend auch das gesamte Skelet auf Inverse Kinematics
ausgerichtet. Daher kÃ¶nnen alle Elemente der Forward Kinematics
deaktiviert werden.

\marginnote{Zwischen Forward und Inverse Kinematics wechseln}

MÃ¶chte man trotzdem Forward Kinematics fÃ¼r ein KÃ¶rperteil verwenden,
kÃ¶nnen stattdessen die Strukturen in grÃ¼ner Farbe verwendet werden. Im
Bereich Â«\emph{Rig Main Properties}Â» muss allerdings der Wert fÃ¼r
Â«\emph{IK-FK}Â» auf 1 gesetzt werden. Mittels dieses Wertes wird
definiert, ob das aktuell ausgewÃ¤hlte KÃ¶rperteil mittels Inverse
Kinematics oder Forwards Kinematics bearbeitet werden soll. FÃ¼r eine
Bearbeitung mit Inverse Kinematics wird der Wert 0 angegeben, fÃ¼r eine
Bearbeitung mit Forward Kinematics wird der Wert 1 angegeben.

\section{Charakter-Rigs und Charakter-Animation mit
Mixamo}\label{charakter-rigs-und-charakter-animation-mit-mixamo}

\marginnote{Mixamo}

Eine weitere Option, um den Rig fÃ¼r einen Charakter zu erstellen, stellt
die Online-Plattform \url{https://www.mixamo.com/\#/}. Dabei handelt es
sich um ein Tool von Adobe -- dementsprechend muss ein Adobe-Account
erstellt oder verwendet werden. In Mixamo mÃ¼ssen lediglich ein paar
Markierungen fÃ¼r verschiedene KÃ¶rperteile auf dem Objekt hinzugefÃ¼gt
werden, anschliessend generiert Mixamo automatisch einen Rig fÃ¼r den
Charakter.

\marginnote{Charakter herunterladen}

Der Charakter mit dem dazugehÃ¶rigen Rig kann anschliessend als 3D-Datei
heruntergeladen werden. ZusÃ¤tzlich kann dem Charakter eine Animation
hinzugefÃ¼gt werden, welche Mixamo aus einer Animations-Bibliothek zur
VerfÃ¼gung stellt.

\marginnote{Import/Export}

Um einen Charakter aus Blender in Mixamo verwenden zu kÃ¶nnen, muss
dieser als 3D-Datei exportiert werden - entweder als .fbx- oder
.obj.-Datei. HierfÃ¼r muss der Charakter ausgewÃ¤hlt werden und unter
Â«\emph{File \textbar{} Export}Â» die Option Â«\emph{FBX (.fbx)}Â» oder
Â«\emph{Wavefront (.obj)}Â» gewÃ¤hlt werden. Anschliessend kann ein
Speicherort fÃ¼r die entsprechende 3D-Datei ausgewÃ¤hlt werden. Ãœber die
Einstellung Â«\emph{File \textbar{} Import}Â» kann anschliessend der
Charakter, welcher mit Mixamo geriggt und allenfalls auch animiert
wurde, wieder importiert werden.

\chapter{Vom Bild zur Animation}\label{vom-bild-zur-animation}

\section{Was sind Animationen?}\label{was-sind-animationen}

\marginnote{VerÃ¤nderungen kÃ¶nnen in Bildern lediglich angedeutet werden}

Bislang wurde lediglich die Erstellung von statischen Bildern
betrachtet. Das Bild ist dann jeweils ein Abbild einer Szene. Das
einzelne Bild als solches ermÃ¶glicht keine VerÃ¤nderung der Objekte. So
ist es etwa nicht mÃ¶glich, in einem Bild zu sehen, wie sich jemand
bewegt, da das Bild statisch aufgebaut ist. Anhand verschiedener Posen
oder Annahmen in Bildern kann allerdings eine Bewegung angedeutet
werden, welche vor oder nach dem Bild vollzogen wird. Die Bewegung
selbst ist dabei allerdings nie im Bild sichtbar.

\marginnote{Animationen beinhalten VerÃ¤nderungen}

Anders als bei statischen Bildern weisen Animationen eine VerÃ¤nderung
von Elementen innerhalb einer Szene auf. Eine Bewegung wird dabei nicht
angedeutet oder in einem Bild suggeriert, sondern ist direkt als solche
sichtbar. Dies hat zur Folge, dass man sich keine Gedanken machen muss,
wie man innerhalb eines einzigen Bildes einen Ablauf darstellen will.

\marginnote{Animationen als Anreihung von einzelnen Bildern}

TatsÃ¤chlich sind Animationen auch Bilder, respektive die Abfolge
mehrerer Bilder. Indem diese Bilder schnell aneinandergereiht werden,
entsteht der Eindruck, dass es sich um eine Animation handelt. Dieses
Prinzip entspricht etwa demjenigen eines Daumenkinos.

\section{Framerate}\label{framerate}

\marginnote{Framerate beschreibt die Anzahl Bilder pro Sekunde}

Die Anzahl Bilder, welche wÃ¤hrend einer Sekunde in einer Animation
dargestellt werden, wird als Framerate bezeichnet. Wenn in einer
Animation innerhalb von einer Sekunde 24 Bilder angezeigt werden,
spricht man dementsprechend von einer Framerate von 24 Â«frames per
secondÂ» (fps). Die Frames beschreiben dabei die einzelnen Bilder, welche
wÃ¤hrend dieser Sekunde dargestellt werden. 24 fps werden in der
Videobranche als Standard angesehen.

\marginnote{Bildwiederholrate}

UnabhÃ¤ngig davon, wie viele Frames eine Animation beinhaltet, kann ein
Bildschirm nur eine gewisse Anzahl Bilder pro Sekunde erzeugen. Die
Anzahl dieser Bilder, die ein Bildschirm erzeugen kann, wird als
Bildwiederholrate bezeichnet und mit der Einheit Hertz angegeben. Eine
Bildwiederholrate von 120 Hertz bedeutet dabei, dass 120 Bilder pro
Sekunde erzeugt werden kÃ¶nnen. Einige GerÃ¤te verfÃ¼gen dabei Ã¼ber
Funktionen, mit denen sie Zwischenbilder berechnen kÃ¶nnen. Dadurch
werden zusÃ¤tzliche Frames erzeugt, wenn beispielsweise eine Animation
weniger Frames in einer Sekunde beinhaltet, als der Bildschirm
darstellen kÃ¶nnte.

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Teilweise wird die Framerate bei Produkten zusammen mit der BildauflÃ¶sung angegeben. Dabei wird die BildauflÃ¶sung mit der vertikalen Anzahl Pixel angegeben (beispielsweise 2160 p), gefolgt von der Framerate (beispielsweise 30). Die Bezeichnung 2160p30 wÃ¼rde dementsprechend bedeuten, dass in der vertikalen Ausrichtung 2160 Pixel angezeigt werden und die Framerate 30 fps betrÃ¤gt.
\end{tipp}

\marginnote{Framerate-EinbrÃ¼che bei Echtzeit-Rendering}

In Videos sind die Animationen jeweils vorgegeben und der Betrachter
kann keinen aktiven Einfluss auf das Geschehen nehmen. Dementsprechend
betrachten alle Nutzer dieselbe Abfolge von Einzelbilder, welche
vorproduziert werden kÃ¶nnen. Bei anderen Medien wie etwa Videospielen
werden unterschiedliche Bilder erzeugt, abhÃ¤ngig von Entscheidungen des
Nutzers. In diesen FÃ¤llen muss jedes Bild in Echtzeit gerendert werden.
Je nach KomplexitÃ¤t der Szenen und Hardware der benutzten GerÃ¤te kann es
dabei zu EinbrÃ¼chen in der Framerate kommen.

\section{Animationseinstellungen in Blender
definieren}\label{animationseinstellungen-in-blender-definieren}

\marginnote{Default-Einstellungen}

Per Default werden in Blender 250 Frames im Rahmen einer Animation mit
einer Framerate von 24 fps abgespielt. Im Timeline-Editor wird ein
Zeitstrahl dargestellt, welcher diese 250 Frames von links nach rechts
anordnet. Mithilfe eines blauen Markers wird signalisiert, welcher Frame
gerade ausgewÃ¤hlt ist und im 3D-Viewport-Editor dargestellt wird.

\marginnote{Start- und End-Frame}

In der oberen rechten Ecke des Timeline-Editors wird angegeben, ab
welchem Frame eine Animation beginnt und bis zu welchem Frame die
Animation andauert. Im Feld Â«\emph{Start}Â» lÃ¤sst sich dabei der
Start-Frame fÃ¼r eine Animation definieren und im Feld Â«\emph{End}Â» der
End-Frame fÃ¼r eine Animation. Durch eine VerÃ¤nderung der Start- und
End-Frames kann die Animationsdauer angepasst werden.

\marginnote{Frames auswÃ¤hlen}

Links neben dem Feld Â«\emph{Start}Â» wird in einem zusÃ¤tzlichen Feld der
aktuell dargestellte Frame angegeben. Durch eine VerÃ¤nderung dieser Zahl
kann ein anderer Frame ausgewÃ¤hlt werden. Alternativ lÃ¤sst sich auch
durch ein Verschieben des blauen Markers in der Zeitleiste ein anderer
Frame auswÃ¤hlen. Im 3D-Viewport-Editor wird zudem ebenfalls angezeigt,
welcher Frame gerade dargestellt wird. Sofern die Viewport-Overlays
aktiviert sind, wird in der linken oberen Ecke anhand einer
Textinformation angegeben, welche Ansicht auf die Szene gerade verwendet
wird. Darunter wird der aktuelle Frame in einer Klammer angegeben.

\marginnote{Framerate Ã¤ndern}

Die Einstellung der Framerate fÃ¼r ein Blender-File lÃ¤sst sich in den
Output-Properties des Properties-Editors einstellen. Unter dem Reiter
Â«\emph{Format}Â» kann die Framerate ausgewÃ¤hlt werden. Dadurch wird
allerdings lediglich angepasst, wie viele Frames Blender innerhalb einer
Sekunde darstellen soll. Dies hat zur Folge, dass bereits erstellte
Animationen schneller ablaufen, weil die Frames nun zeitlich schneller
getaktet werden. Wenn dies verhindert werden soll, kann unter
Â«\emph{Frame Range}Â» und Â«\emph{Time Stretching}Â» die Animation
angepasst werden. HierfÃ¼r wird im Bereich Â«\emph{Old}Â» die alte Frame
rate angegeben und im Bereich Â«\emph{New}Â» die neue Framerate. Dadurch
werden anschliessend die bereits gesetzten Animationen umgerechnet.

Merke\ldots{}

Eine Animation ergibt sich aus der schnellen Abfolge von einzelnen
Bildern. Die Zeitspanne fÃ¼r ein Bild wird als Frame bezeichnet.

Die Anzahl Bilder/Frames pro Sekunde wird als Framerate bezeichnet.

\chapter{Animationen erstellen}\label{animationen-erstellen}

\section{Keyframes erstellen}\label{keyframes-erstellen}

\marginnote{Animation verlÃ¤uft von Situation zu Situation}

Eine Animation stellt jeweils eine VerÃ¤nderung von einer Situation zu
einer anderen Situation dar. Beispielsweise befindet sich ein Objekt
zunÃ¤chst an einer bestimmten Position A und bei einem spÃ¤teren Frame an
einer anderen Position B. Dementsprechend stellt die erste Position A
die Ausgangssituation dar und im Verlaufe der Animation wird das Objekt
zur Position B verschoben. Die Animation verlÃ¤uft also von der Position
A beim Beginn der Animation zu Position B beim Ende der Animation.

\marginnote{Keyframes geben Situationen vor}

Ein solcher Gedankengang ist jeweils zentral bei der Erstellung von
Animationen. Es wird jeweils eine Ausgangslage zum Beginn der Animation
definiert und eine Endsituation zum Ende der Animation. HierfÃ¼r werden
die Frames, bei denen sich die Objekte an der Ausgangs- und Endlage
befinden, mit sogenannten Keyframes versehen. Keyframes stellen Frames
dar, welche eine bestimmte Vorgabe fÃ¼r eine Animation aufweisen --
beispielsweise, dass sich ein Objekt an einer Stelle befindet oder dass
es eine bestimmte Rotation aufweist. Die Animation verlÃ¤uft
anschliessend automatisch von einem Keyframe zum nÃ¤chsten Keyframe ab,
wobei die Frames die dazwischenliegenden Animationsschritte automatisch
darstellen.

\marginnote{Keyframe hinzufÃ¼gen}

Um dies zu veranschaulichen, kann eine neue Szene in Blender erstellt
werden. Per Default sollte der StandardwÃ¼rfel im Mittelpunkt der Welt
festgelegt und der erste Frame ausgewÃ¤hlt worden sein. Um nun einen
Keyframe fÃ¼r die Position des StandardwÃ¼rfels festzulegen, kann die
Sidebar mit der Taste \kbd{N} geÃ¶ffnet werden. Sobald der StandardwÃ¼rfel
ausgewÃ¤hlt wurde, wird nun im Reiter Â«\emph{Location}Â» dessen Position
angezeigt. Wenn der Mauszeiger nun auf den Positionswerten in diesem
Reiter platziert wurde, kann die Taste \kbd{I} gedrÃ¼ckt werden. Dadurch
wird beim aktuell ausgewÃ¤hlten Frame ein Keyframe mit der Position des
Objektes erstellt.

\marginnote{Gelbe Markierung signalisiert Keyframes beim aktuellen Frame}

Wenn ein Wert in Blender mit einem Keyframe versehen wurde, wird dies
jeweils dadurch angezeigt, dass das entsprechende Feld fÃ¼r einen Wert
mit einer Hintergrundfarbe dargestellt wird. In diesem Beispiel sollten
die Werte fÃ¼r die Position mit einer gelben Hintergrundfarbe dargestellt
werden. Damit wird signalisiert, dass wÃ¤hrend des aktuellen Frames ein
Keyframe gesetzt wurde. ZusÃ¤tzlich erscheint im Timeline-Editor beim
aktuellen Frame ein gelbes Viereck. Dadurch wird signalisiert, dass das
aktuell ausgewÃ¤hlte Objekt bei diesem Frame auf der Zeitachse einen
Keyframe beinhaltet.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_47/47_1_Postions_Marked.png}

\caption{\label{fig-1_1}Die Markierung der Positionswerte, welche beim
aktuellen Frame mit einem Keyframe versehen wurden.}

\end{figure}%

\marginnote{GrÃ¼ne Markierung von Werten}

Wenn nun im Timeline-Editor ein anderer Frame ausgewÃ¤hlt wird
(beispielsweise der Frame 50), fÃ¼hrt dies dazu, dass sich die farbliche
Markierung der Positionswerte des WÃ¼rfels in der Sidebar verÃ¤ndert.
Statt mit einer gelben Farbe werden die Werte nun in einer grÃ¼nen Farbe
markiert. Dadurch wird signalisiert, dass dieser Wert im Rahmen eines
Keyframes definiert wurde.

\marginnote{Organe Markierung von Werten}

Sollte nun die Position des WÃ¼rfels verÃ¤ndert werden -- entweder, indem
er im 3D-Viewport-Editor verschoben wird, oder, indem die Werte fÃ¼r die
Position in der Sidebar verÃ¤ndert werden -- werden die Werte fÃ¼r die
Position in einer orangen Farbe dargestellt. Damit soll signalisiert
werden, dass die Positionswerte einen Keyframe auf der Zeitachse
beinhalten, aber beim aktuellen Frame ein anderer Wert eingestellt
wurde. Wenn nun der Mauszeiger wieder Ã¼ber die Werte fÃ¼r die Position in
der Sidebar gelegt und erneut die Taste \kbd{I} gedrÃ¼ckt wird, erscheint
eine gelbe statt einer orangen Markierung bei diesen Werten. Damit wird
signalisiert, dass die nun eingestellte Position ebenfalls als Keyframe
beim aktuell ausgewÃ¤hlten Frame abgespeichert wurde.

\marginnote{Animation wird automatisch zwischen Keyframes erstellt}

Nun sollte es zwei Keyframes fÃ¼r die Position geben, welche im Timeline
Editor angezeigt werden. Wenn nun Frames zwischen den beiden Keyframes
ausgewÃ¤hlt werden, wird der WÃ¼rfel im 3D-Viewport-Editor an einer
Position zwischen der Ausgangsposition und der Endposition liegen.
Blender verschiebt den WÃ¼rfel automatisch Ã¼ber die Dauer der Frames
zwischen den beiden Keyframes von einer Position zur anderen. Wenn die
Animation nun abgespielt wird (entweder mit der \kbd{Space}-Taste oder
der Tatenkombination \kbd{Shift} + \kbd{Space}), lÃ¤uft die Animation im
3D-Viewport-Editor ab und die Bewegung des WÃ¼rfels sollte angezeigt
werden. Indem der Wert des Ende-Frames in der Timeline auf den zweiten
Keyframe gesetzt wird, kann zudem eingestellt werden, dass lediglich die
erstellte Bewegungsanimation wiederholt wird.

\begin{tipp}{WeiterfÃ¼hrende Informationen}
In der Timeline werden jeweils die Keyframes der ausgewÃ¤hlten Objekte angezeigt. Wenn kein Objekt ausgewÃ¤hlt ist, werden auch keine Keyframes angezeigt. Sollten also bereits gesetzte Keyframes plÃ¶tzlich verschwunden sein, sollte Ã¼berprÃ¼ft werden, ob das richtige Objekt ausgewÃ¤hlt wurde.
\end{tipp}

\marginnote{Keyframes im Timeline-Editor verschieben}

Die Keyframes, welche in der Timeline gesetzt werden, kÃ¶nnen jeweils mit
dem Mauszeiger ausgewÃ¤hlt und verschoben werden. Ebenso kÃ¶nnen
ausgewÃ¤hlte Keyframes mittels der Taste \kbd{G} verschoben werden und
mit einer Zahleneingabe um eine bestimmte Anzahl Frames versetzt werden.
Zudem kÃ¶nnen die AbstÃ¤nde zwischen den Keyframes zum aktuellen Frame
vergrÃ¶ssert oder verkleinert werden, indem die Taste \kbd{S} gedrÃ¼ckt
wird.

Merke\ldots{}

Keyframes stellen Frames dar, bei denen bestimmte Vorgaben fÃ¼r Werte in
einer Animation definiert werden.

Bei Animationen werden automatisch die Zwischenschritte zwischen zwei
Keyframes animiert.

Keyframes kÃ¶nnen mit der Taste hinzugefÃ¼gt werden.

Keyframes fÃ¼r die ausgewÃ¤hlten Objekte werden im Timeline-Editor
dargestellt und kÃ¶nnen dort verschoben werden.

\chapter{Animationen verfeinern}\label{animationen-verfeinern}

\subsection{Beispiel Pendel}\label{beispiel-pendel}

\marginnote{Pendel-Datei}

In der Datei Â«\emph{Pendel}Â» ist ein 3D-Modell eines Pendels
vorzufinden. Das Ziel ist es, eine Animation zu erstellen, in der dieses
Pendel von links nach rechts schwingt und wieder zurÃ¼ck. Diese Animation
soll anschliessend unendlich oft wiederholt werden.

\marginnote{Frame 0 auswÃ¤hlen}

ZunÃ¤chst wird eine Position des Pendels zum Frame 0 definiert. HierfÃ¼r
wird der Marker im Timeline-Editor auf den Frame 0 platziert.
Anschliessend kann die Schwingung des Pendels zu diesem Frame erstellt
werden.

\marginnote{Pendel schwingen}

Der Ursprung des Pendel-Objektes befindet sich am Ende von dessen
Schnur. Wenn die Rotation dieses Pendels im Object-Mode verÃ¤ndert wird,
wird das Pendel dementsprechend um das Ende der Schnur gedreht. Dadurch
kann zunÃ¤chst eine Rotation des Pendels entlang der Y-Achse um 60 Grad
definiert werden. Anschliessend kann der Mauszeiger Ã¼ber das Eingabefeld
fÃ¼r die Rotation in der Sidebar platziert und die Taste \kbd{I} gedrÃ¼ckt
werden, um den ersten Keyframe fÃ¼r die Rotation zu setzen.

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Im Timeline-Editor kann unter Â«*View \| Show Seconds*Â» eingestellt werden, dass statt der Anzahl Frames oberhalb der Timeline die Anzahl Sekunden angezeigt wird. Dadurch werden in der Timeline jeweils ganze Sekunden plus die Anzahl Frames der laufenden Sekunde angezeigt.
\end{tipp}

\marginnote{Zweiten Keyframe platzieren}

Das Pendel soll rund 1.5 Sekunden benÃ¶tigen, um von der einen Seite zur
anderen Seite zu schwingen. Die Animation betrÃ¤gt 24 fps.
Dementsprechend werden 1.5 x 24 Frames benÃ¶tigt, bis das Pendel auf der
anderen Seite angekommen ist. Deshalb wird der blaue Marker im
Timeline-Editor nun auf Frame 36 platziert. In der Sidebar kann nun der
Wert fÃ¼r die Rotation des Pendels entlang der Y-Achse auf -60 Grad
gesetzt werden und dieser Wert mit der Taste \kbd{I} als Keyframe fÃ¼r
Frame 36 hinzugefÃ¼gt werden.

\marginnote{Dritten Keyframe setzen}

Mit diesen Schritten wurde nun bereits die Schwingung des Pendels von
links nach rechts animiert. Um die Schwingung von rechts nach links zu
animieren, muss nun lediglich beim Keyframe 72 die Rotation der Y-Achse
wieder auf 60 Grad gesetzt werden und dies als Keyframe eingespeichert
werden. Alternativ kann allerdings auch im Timeline-Editor der erste
Keyframe ausgewÃ¤hlt und mit der Tasten kombination \kbd{Shift} + \kbd{D}
dupliziert und beim Frame 72 platziert werden.

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Wenn die Aufnahme-SchaltflÃ¤che Â«Auto KeyingÂ» im Timeline-Editor aktiviert ist, werden alle Ã„nderungen zum aktuellen Frame automatisch als Keyframe hinzugefÃ¼gt. Dadurch mÃ¼ssen diese Ã„nderungen nicht manuell als Keyframes definiert werden.
\end{tipp}

\marginnote{Animation kopieren fÃ¼r Wiederholungen}

Die Animation des Pendels ist nun bereits mithilfe dieser drei Keyframes
vollzogen worden. Allerdings wird diese Animation nun nicht wiederholt.
Um eine Wiederholung zu erzielen, kÃ¶nnten nun immer mit einem Abstand
von 72 Frames die Animationspunkte wiederholt werden. Es gibt allerdings
eine elegantere Methode, um eine Wiederholung der Animation zu erzielen.

\subsection{Animationen im Graph-Editor
nachbearbeiten}\label{animationen-im-graph-editor-nachbearbeiten}

\marginnote{Graph-Editor}

Im sogenannten Graph-Editor werden die gesetzten Keyframes jeweils
anhand von Kurven dargestellt. Jeder Wert des ausgewÃ¤hlten Objektes, der
mit einem Keyframe ausgestattet wurde, wird dabei mit einer Kurve
dargestellt. Zudem werden individuelle Kurven fÃ¼r die X-, Y- und Z-Achse
erstellt.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_48/48_1_Icon_Graph_Editor.png}

\caption{\label{fig-1_1}Icon fÃ¼r den Graph-Editor.}

\end{figure}%

\begin{figure}

\includegraphics{Chapters/Images/Chapter_48/48_2_Pendel_Rotation.jpg}

\caption{\label{fig-1_2}Der Graf fÃ¼r die Rotationen des Pendels. Die X-
und die Z-Achsen-Rotation liegen beide konstant auf dem Wert 0, wÃ¤hrend
die Y-Achsen-Rotation entlang der Werte bei den entsprechenden Keyframes
verlÃ¤uft.}

\end{figure}%

\begin{figure}[H]

{\centering \includegraphics{Chapters/Images/Chapter_48/48_2_Pendel_Rotation.jpg}

}

\caption{Der Graf fÃ¼r die Rotationen des Pendels. Die X- und die
Z-Achsen-Rotation liegen beide konstant auf dem Wert 0, wÃ¤hrend die
Y-Achsen-Rotation entlang der Werte bei den entsprechenden Keyframes
verlÃ¤uft.}

\end{figure}%

\marginnote{Kurven im Graph-Editor}

In diesem Beispiel wurde das Pendel in den verschiedenen Keyframes
entlang der Y-Achse rotiert. Deshalb wurden drei Kurven fÃ¼r die Rotation
des Objektes entlang der drei Achsen erstellt. Eine rote Kurve fÃ¼r die
Rotation entlang der X-Achse, eine grÃ¼ne Kurve fÃ¼r die Rotation entlang
der Y-Achse und eine blaue Kurve fÃ¼r die Rotation entlang der Z-Achse.
Die einzelnen Kurven verlaufen entlang der X-Achse des Graph-Editors den
einzelnen Frames entlang und entlang der Y-Achse werden die
tatsÃ¤chlichen Werte fÃ¼r die jeweiligen Keyframes angezeigt. Da die
Rotationen des Pendels entlang der X- und Z-Achse konstant bei 0
belassen wurden, sind deren Kurven konstant auf dem Wert 0 platziert und
lediglich die Kurve fÃ¼r die Y-Rotation weist eine VerÃ¤nderung auf.

\marginnote{Cycles-Modifier}

Damit die erstellte Animation nun unendlich verlÃ¤uft, mÃ¼sste die
erstellte Kurve wiederholt werden. Um dies zu erzielen, kann entweder
ein Keyframe der Y-Achsen-Rotations-Kurve ausgewÃ¤hlt werden oder in der
Toolbar auf der linken Seite des Graph-Editors die Â«\emph{Y Euler
Rotation}Â» ausgewÃ¤hlt werden. Anschliessend kann in der Sidebar auf der
rechten Seite des Graph-Editors auf den Reiter Â«\emph{Modifiers}Â»
geklickt werden. Dadurch kann nun ein Modifier auf diese Animationskurve
angewendet werden. Durch das HinzufÃ¼gen des Modifiers Â«\emph{Cycles}Â» im
Dropdown-MenÃ¼ Â«\emph{Add Modifier}Â» wird die Kurve der Y-Achsen-Rotation
nun zyklisch wiederholt. Diese Wiederholung erfolgt unendlich oft. Es
ist allerdings mÃ¶glich zu definieren, dass die Kurve lediglich einmal
vor der erstellten Animation wiederholt wird, indem der Wert
Â«\emph{Count}Â» unterhalb des Â«\emph{Before Mode}Â» von 0 auf 1 gesetzt
wird. Ebenso kann mit dem Wert Â«\emph{Count}Â» unterhalb des Â«\emph{After
Mode}Â» die Anzahl Wiederholungen nach der erstellten Animation
eingestellt werden.

\begin{tipp}{WeiterfÃ¼hrende Informationen}
Nebst dem Cycles-Modifier gibt es noch weitere nÃ¼tzliche Modifier, um Animationskurven zu erstellen. Mithilfe des Generator-Modifiers kÃ¶nnen etwa lineare Regressionskurven fÃ¼r Animationen erstellt werden oder mittels des Noise-Modifiers kÃ¶nnen dir Kurven zufÃ¤llig verzerrt werden.
\end{tipp}

\begin{figure}

\includegraphics{Chapters/Images/Chapter_48/48_3_Y_Rotation.png}

\caption{\label{fig-1_3}Der Graf fÃ¼r die Y-Achsen-Rotation mit einem
Cycles-Modifier. Dadurch wird die Animation unendlich oft wiederholt.}

\end{figure}%

\marginnote{Kurven-Interpolation anpassen}

Die erstellten Graphen werden an den Keyframes jeweils mittels einer
BÃ©zierkurve ausgestattet. Dadurch kÃ¶nnen die Ausrichtungen der Kurven
etwas nachbearbeitet werden. Es ist allerdings auch mÃ¶glich,
Interpolationen fÃ¼r die Transformation zwischen den Keyframes
auszuwÃ¤hlen. HierfÃ¼r mÃ¼ssen alle Keyframes der entsprechenden Kurve
ausgewÃ¤hlt werden. Indem die Maus Ã¼ber einen dieser Keyframes platziert
wird und anschliessend die Taste \kbd{L} gedrÃ¼ckt wird, werden alle
Keyframes dieser Kurve ausgewÃ¤hlt. Mit einem Rechtsklick mit der Maus
kann anschliessend das Â«\emph{F-Curve Context Menu}Â» geÃ¶ffnet werden und
darunter der Reiter Â«\emph{Interpolation Mode}Â» anvisiert werden. Dieses
Kontext-MenÃ¼ zum Interpolationsmodus kann auch mittels der Taste \kbd{T}
geÃ¶ffnet werden. In diesem MenÃ¼ kÃ¶nnen anschliessende verschiedene Modi
zur Interpolation der Kurven ausgewÃ¤hlt werden. StandardmÃ¤ssig ist die
Option Â«\emph{Bezier}Â» ausgewÃ¤hlt, aber je nach Situation kÃ¶nnen andere
Interpolationen ebenfalls sinnvoll sein.

\chapter{Animationen rendern}\label{animationen-rendern}

\subsection{Animationen direkt
rendern}\label{animationen-direkt-rendern}

\marginnote{Animationen rendern}

Erstellte Animationen lassen sich, so wie auch Bilder, rendern. Dabei
ist allerdings zu berÃ¼cksichtigen, dass eine Animation aus einer
Aneinanderreihung von mehreren Bildern besteht. Um eine gesamte
Animation zu Rendern, kann im MenÃ¼band unter Â«\emph{Render}Â» die Option
Â«\emph{Render Animation}Â» ausgewÃ¤hlt werden. Anschliessend werden alle
Frames vom Start-Frame bis zum End-Frame nacheinander gerendert. Das
bedeutet allerdings auch, dass sich die Ã¼bliche Renderzeit erhÃ¶ht, da
nun so viele Bilder gerendert werden mÃ¼ssen, wie auch Frames vorhanden
sind.

\marginnote{Video-Output einstellen}

Per Default werden Animationen als einzelne Bilder gerendert, welche
noch kein Video darstellen. Um ein Video zu erstellen, muss das
entsprechende Videoformat als Output des Render-Prozesses angegeben
werden. Dies kann im Output-Properties-Reiter des Properties-Editors
unter Â«\emph{Output}Â» definiert werden. Besonders wichtig ist dabei,
dass unter diesem Reiter ein Speicherort fÃ¼r das Output-Video definiert
wird. Anders als bei Bildern, kÃ¶nnen Videos nicht nachtrÃ¤glich in
Blender abgespeichert werden. Aus diesem Grund ist es wichtig sich zu
vergegenwÃ¤rtigen, wo das Video abgespeichert wird.

\marginnote{Videoformat definieren}

Zudem sollte das Dropdown-MenÃ¼ Â«\emph{File Format}Â» von Â«\emph{PNG}Â» auf
Â«\emph{FFmpeg Video}Â» umgestellt werden. Dadurch erscheint zuunterst im
Reiter Â«\emph{Output}Â» ein neuer Unterreiter Â«\emph{Encoding}Â». Unter
diesem Reiter mÃ¼ssen weitere Einstellungen definiert werden, wie das
Video jeweils enkodiert werden soll. Auf dem Listen-Symbol rechts des
Â«\emph{Encoding}Â»-Reiters kÃ¶nnen verschiedene Voreinstellungen
ausgewÃ¤hlt werden. Um ein MP4-Video zu erstellen, kann etwa die
Voreinstellung Â«\emph{H264 in MP4}Â» ausgewÃ¤hlt werden. Dadurch werden
alle anderen Einstellungen automatisch fÃ¼r dieses Dateiformat angepasst.

\marginnote{Animations-Rendering darf nicht unterbrochen werden}

Beim Rendern der Animation werden anschliessend die Bilder aller Frames
innerhalb der Animation nacheinander gerendert. Sobald alle einzelnen
Bilder gerendert wurden, erfolgt ein weiterer Render-Schritt, bei dem
die einzelnen Bilder zu einem Video zusammengefÃ¼hrt werden. Dieser
gesamte Prozess sollte nicht unterbrochen werden, ansonsten sind alle
bereits gerenderten Inhalte verloren.

\subsection{Bilder rendern und anschliessend Animationen
rendern}\label{bilder-rendern-und-anschliessend-animationen-rendern}

\marginnote{Arbeitsschritte fÃ¼r das Rendern aufteilen}

Eine alternative Vorgehensweise beim Rendern von Animationen besteht
darin, dass der Renderprozess in zwei Schritte aufgeteilt wird: das
Rendern der einzelnen Bilder und das Rendern der Animation. Es handelt
sich dabei um den identischen Ablauf wie bereits beschrieben, allerdings
werden dabei die einzelnen Frames als einzelne Bilder auf dem Rechner
abgespeichert, welche anschliessend wieder in Blender hineingeladen
werden, um die finale Animation zu rendern. Dies hat den Vorteil, dass
dadurch der Renderprozess jederzeit abgebrochen werden kann und spÃ¤ter
lediglich die Bilder der noch fehlenden Frames gerendert werden kÃ¶nnen.
HierfÃ¼r muss lediglich der Start-Frame in der Timeline zu demjenigen
Frame abgeÃ¤ndert werden, welcher als Erster noch nicht gerendert wurde.

\marginnote{Einzelne PNG-Bilder pro Frames rendern}

Um statt einer gesamten Animation lediglich die einzelnen Bilder zu
rendern, kann in den Output Properties des Properties-Editors die Option
Â«\emph{File Format}Â» auf Â«\emph{PNG}Â» belassen werden. Allerdings ist es
auch hier unerlÃ¤sslich, einen sinnvollen Speicherort fÃ¼r die einzelnen
Bilder auszuwÃ¤hlen. Wenn anschliessend die Animation gerendert wird,
werden alle einzelnen Frame-Bilder in diesem Ordner als separates Bild
abgespeichert.

\marginnote{Bildsequenz im Video-Sequencer-Editor hinzufÃ¼gen}

Um nach dem Rendern die Bilder zu einem Video zu verknÃ¼pfen, kann der
VideoSequencer-Editor in Blender verwendet werden. In diesem kÃ¶nnen
unter Â«\emph{Add \textbar{} Image/Sequence}Â» die ausgewÃ¤hlten Bilder
eingelesen werden. Anschliessend kann die Output-Einstellung im
Properties-Editor auf das Videoformat angepasst werden und durch das
Rendern der Animation werden nun lediglich die bereits vorproduzierten
einzelnen Bilder noch zu einem Video verknÃ¼pft.

\begin{figure}

\includegraphics{Chapters/Images/Chapter_49/49_1_Icon_Video_Sequencer.png}

\caption{\label{fig-1_1}Icon fÃ¼r den Video-Sequencer-Editor.}

\end{figure}%


\backmatter


\end{document}
